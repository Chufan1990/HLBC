// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: autoagric/planning/decision.proto

#include "autoagric/planning/decision.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace autoagric {
namespace planning {
constexpr TargetLane::TargetLane(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , start_s_(0)
  , end_s_(0)
  , speed_limit_(0){}
struct TargetLaneDefaultTypeInternal {
  constexpr TargetLaneDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TargetLaneDefaultTypeInternal() {}
  union {
    TargetLane _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TargetLaneDefaultTypeInternal _TargetLane_default_instance_;
constexpr ObjectIgnore::ObjectIgnore(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ObjectIgnoreDefaultTypeInternal {
  constexpr ObjectIgnoreDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectIgnoreDefaultTypeInternal() {}
  union {
    ObjectIgnore _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectIgnoreDefaultTypeInternal _ObjectIgnore_default_instance_;
constexpr ObjectStop::ObjectStop(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : wait_for_obstacle_()
  , stop_point_(nullptr)
  , distance_s_(0)
  , stop_heading_(0)
  , reason_code_(0)
{}
struct ObjectStopDefaultTypeInternal {
  constexpr ObjectStopDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectStopDefaultTypeInternal() {}
  union {
    ObjectStop _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectStopDefaultTypeInternal _ObjectStop_default_instance_;
constexpr ObjectNudge::ObjectNudge(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : distance_l_(0)
  , type_(0)
{}
struct ObjectNudgeDefaultTypeInternal {
  constexpr ObjectNudgeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectNudgeDefaultTypeInternal() {}
  union {
    ObjectNudge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectNudgeDefaultTypeInternal _ObjectNudge_default_instance_;
constexpr ObjectYield::ObjectYield(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fence_point_(nullptr)
  , distance_s_(0)
  , fence_heading_(0)
  , time_buffer_(0){}
struct ObjectYieldDefaultTypeInternal {
  constexpr ObjectYieldDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectYieldDefaultTypeInternal() {}
  union {
    ObjectYield _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectYieldDefaultTypeInternal _ObjectYield_default_instance_;
constexpr ObjectFollow::ObjectFollow(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fence_point_(nullptr)
  , distance_s_(0)
  , fence_heading_(0){}
struct ObjectFollowDefaultTypeInternal {
  constexpr ObjectFollowDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectFollowDefaultTypeInternal() {}
  union {
    ObjectFollow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectFollowDefaultTypeInternal _ObjectFollow_default_instance_;
constexpr ObjectOvertake::ObjectOvertake(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fence_point_(nullptr)
  , distance_s_(0)
  , fence_heading_(0)
  , time_buffer_(0){}
struct ObjectOvertakeDefaultTypeInternal {
  constexpr ObjectOvertakeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectOvertakeDefaultTypeInternal() {}
  union {
    ObjectOvertake _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectOvertakeDefaultTypeInternal _ObjectOvertake_default_instance_;
constexpr ObjectSidePass::ObjectSidePass(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(0)
{}
struct ObjectSidePassDefaultTypeInternal {
  constexpr ObjectSidePassDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectSidePassDefaultTypeInternal() {}
  union {
    ObjectSidePass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectSidePassDefaultTypeInternal _ObjectSidePass_default_instance_;
constexpr ObjectAvoid::ObjectAvoid(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ObjectAvoidDefaultTypeInternal {
  constexpr ObjectAvoidDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectAvoidDefaultTypeInternal() {}
  union {
    ObjectAvoid _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectAvoidDefaultTypeInternal _ObjectAvoid_default_instance_;
constexpr ObjectStatus::ObjectStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : motion_type_(nullptr)
  , decision_type_(nullptr){}
struct ObjectStatusDefaultTypeInternal {
  constexpr ObjectStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectStatusDefaultTypeInternal() {}
  union {
    ObjectStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectStatusDefaultTypeInternal _ObjectStatus_default_instance_;
constexpr ObjectStatic::ObjectStatic(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ObjectStaticDefaultTypeInternal {
  constexpr ObjectStaticDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectStaticDefaultTypeInternal() {}
  union {
    ObjectStatic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectStaticDefaultTypeInternal _ObjectStatic_default_instance_;
constexpr ObjectDynamic::ObjectDynamic(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ObjectDynamicDefaultTypeInternal {
  constexpr ObjectDynamicDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectDynamicDefaultTypeInternal() {}
  union {
    ObjectDynamic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectDynamicDefaultTypeInternal _ObjectDynamic_default_instance_;
constexpr ObjectMotionType::ObjectMotionType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct ObjectMotionTypeDefaultTypeInternal {
  constexpr ObjectMotionTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectMotionTypeDefaultTypeInternal() {}
  union {
    ObjectMotionType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectMotionTypeDefaultTypeInternal _ObjectMotionType_default_instance_;
constexpr ObjectDecisionType::ObjectDecisionType(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct ObjectDecisionTypeDefaultTypeInternal {
  constexpr ObjectDecisionTypeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectDecisionTypeDefaultTypeInternal() {}
  union {
    ObjectDecisionType _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectDecisionTypeDefaultTypeInternal _ObjectDecisionType_default_instance_;
constexpr ObjectDecision::ObjectDecision(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : object_decision_()
  , id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , perception_id_(0){}
struct ObjectDecisionDefaultTypeInternal {
  constexpr ObjectDecisionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectDecisionDefaultTypeInternal() {}
  union {
    ObjectDecision _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectDecisionDefaultTypeInternal _ObjectDecision_default_instance_;
constexpr ObjectDecisions::ObjectDecisions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : decision_(){}
struct ObjectDecisionsDefaultTypeInternal {
  constexpr ObjectDecisionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObjectDecisionsDefaultTypeInternal() {}
  union {
    ObjectDecisions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObjectDecisionsDefaultTypeInternal _ObjectDecisions_default_instance_;
}  // namespace planning
}  // namespace autoagric
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[16];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_autoagric_2fplanning_2fdecision_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_autoagric_2fplanning_2fdecision_2eproto = nullptr;

const uint32_t TableStruct_autoagric_2fplanning_2fdecision_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::TargetLane, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::TargetLane, id_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::TargetLane, start_s_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::TargetLane, end_s_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::TargetLane, speed_limit_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectIgnore, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectStop, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectStop, reason_code_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectStop, distance_s_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectStop, stop_point_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectStop, stop_heading_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectStop, wait_for_obstacle_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectNudge, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectNudge, type_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectNudge, distance_l_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectYield, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectYield, distance_s_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectYield, fence_point_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectYield, fence_heading_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectYield, time_buffer_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectFollow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectFollow, distance_s_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectFollow, fence_point_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectFollow, fence_heading_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectOvertake, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectOvertake, distance_s_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectOvertake, fence_point_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectOvertake, fence_heading_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectOvertake, time_buffer_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectSidePass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectSidePass, type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectAvoid, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectStatus, motion_type_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectStatus, decision_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectStatic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectDynamic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectMotionType, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectMotionType, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectMotionType, motion_tag_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectDecisionType, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectDecisionType, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectDecisionType, object_tag_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectDecision, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectDecision, id_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectDecision, perception_id_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectDecision, object_decision_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectDecisions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::ObjectDecisions, decision_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::autoagric::planning::TargetLane)},
  { 10, -1, -1, sizeof(::autoagric::planning::ObjectIgnore)},
  { 16, -1, -1, sizeof(::autoagric::planning::ObjectStop)},
  { 27, -1, -1, sizeof(::autoagric::planning::ObjectNudge)},
  { 35, -1, -1, sizeof(::autoagric::planning::ObjectYield)},
  { 45, -1, -1, sizeof(::autoagric::planning::ObjectFollow)},
  { 54, -1, -1, sizeof(::autoagric::planning::ObjectOvertake)},
  { 64, -1, -1, sizeof(::autoagric::planning::ObjectSidePass)},
  { 71, -1, -1, sizeof(::autoagric::planning::ObjectAvoid)},
  { 77, -1, -1, sizeof(::autoagric::planning::ObjectStatus)},
  { 85, -1, -1, sizeof(::autoagric::planning::ObjectStatic)},
  { 91, -1, -1, sizeof(::autoagric::planning::ObjectDynamic)},
  { 97, -1, -1, sizeof(::autoagric::planning::ObjectMotionType)},
  { 106, -1, -1, sizeof(::autoagric::planning::ObjectDecisionType)},
  { 121, -1, -1, sizeof(::autoagric::planning::ObjectDecision)},
  { 130, -1, -1, sizeof(::autoagric::planning::ObjectDecisions)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_TargetLane_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectIgnore_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectStop_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectNudge_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectYield_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectFollow_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectOvertake_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectSidePass_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectAvoid_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectStatic_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectDynamic_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectMotionType_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectDecisionType_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectDecision_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_ObjectDecisions_default_instance_),
};

const char descriptor_table_protodef_autoagric_2fplanning_2fdecision_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n!autoagric/planning/decision.proto\022\022aut"
  "oagric.planning\032\037autoagric/common/geomet"
  "ry.proto\"M\n\nTargetLane\022\n\n\002id\030\001 \001(\t\022\017\n\007st"
  "art_s\030\002 \001(\001\022\r\n\005end_s\030\003 \001(\001\022\023\n\013speed_limi"
  "t\030\004 \001(\001\"\016\n\014ObjectIgnore\"\272\001\n\nObjectStop\0227"
  "\n\013reason_code\030\001 \001(\0162\".autoagric.planning"
  ".StopReasonCode\022\022\n\ndistance_s\030\002 \001(\001\022.\n\ns"
  "top_point\030\003 \001(\0132\032.autoagric.common.Point"
  "ENU\022\024\n\014stop_heading\030\004 \001(\001\022\031\n\021wait_for_ob"
  "stacle\030\005 \003(\t\"\274\001\n\013ObjectNudge\0222\n\004type\030\001 \001"
  "(\0162$.autoagric.planning.ObjectNudge.Type"
  "\022\022\n\ndistance_l\030\002 \001(\001\"e\n\004Type\022\013\n\007UNKNOWN\020"
  "\000\022\016\n\nLEFT_NUDGE\020\001\022\017\n\013RIGHT_NUDGE\020\002\022\026\n\022DY"
  "NAMIC_LEFT_NUDGE\020\003\022\027\n\023DYNAMIC_RIGHT_NUDG"
  "E\020\004\"~\n\013ObjectYield\022\022\n\ndistance_s\030\001 \001(\001\022/"
  "\n\013fence_point\030\002 \001(\0132\032.autoagric.common.P"
  "ointENU\022\025\n\rfence_heading\030\003 \001(\001\022\023\n\013time_b"
  "uffer\030\004 \001(\001\"j\n\014ObjectFollow\022\022\n\ndistance_"
  "s\030\001 \001(\001\022/\n\013fence_point\030\002 \001(\0132\032.autoagric"
  ".common.PointENU\022\025\n\rfence_heading\030\003 \001(\001\""
  "\201\001\n\016ObjectOvertake\022\022\n\ndistance_s\030\001 \001(\001\022/"
  "\n\013fence_point\030\002 \001(\0132\032.autoagric.common.P"
  "ointENU\022\025\n\rfence_heading\030\003 \001(\001\022\023\n\013time_b"
  "uffer\030\004 \001(\001\"q\n\016ObjectSidePass\0225\n\004type\030\001 "
  "\001(\0162\'.autoagric.planning.ObjectSidePass."
  "Type\"(\n\004Type\022\013\n\007UNKNOWN\020\000\022\010\n\004LEFT\020\001\022\t\n\005R"
  "IGHT\020\002\"\r\n\013ObjectAvoid\"\210\001\n\014ObjectStatus\0229"
  "\n\013motion_type\030\001 \001(\0132$.autoagric.planning"
  ".ObjectMotionType\022=\n\rdecision_type\030\002 \001(\013"
  "2&.autoagric.planning.ObjectDecisionType"
  "\"\016\n\014ObjectStatic\"\017\n\rObjectDynamic\"\212\001\n\020Ob"
  "jectMotionType\0222\n\006static\030\001 \001(\0132 .autoagr"
  "ic.planning.ObjectStaticH\000\0224\n\007dynamic\030\002 "
  "\001(\0132!.autoagric.planning.ObjectDynamicH\000"
  "B\014\n\nmotion_tag\"\301\003\n\022ObjectDecisionType\0222\n"
  "\006ignore\030\001 \001(\0132 .autoagric.planning.Objec"
  "tIgnoreH\000\022.\n\004stop\030\002 \001(\0132\036.autoagric.plan"
  "ning.ObjectStopH\000\0222\n\006follow\030\003 \001(\0132 .auto"
  "agric.planning.ObjectFollowH\000\0220\n\005yield\030\004"
  " \001(\0132\037.autoagric.planning.ObjectYieldH\000\022"
  "6\n\010overtake\030\005 \001(\0132\".autoagric.planning.O"
  "bjectOvertakeH\000\0220\n\005nudge\030\006 \001(\0132\037.autoagr"
  "ic.planning.ObjectNudgeH\000\0220\n\005avoid\030\007 \001(\013"
  "2\037.autoagric.planning.ObjectAvoidH\000\0227\n\ts"
  "ide_pass\030\010 \001(\0132\".autoagric.planning.Obje"
  "ctSidePassH\000B\014\n\nobject_tag\"t\n\016ObjectDeci"
  "sion\022\n\n\002id\030\001 \001(\t\022\025\n\rperception_id\030\002 \001(\005\022"
  "\?\n\017object_decision\030\003 \003(\0132&.autoagric.pla"
  "nning.ObjectDecisionType\"G\n\017ObjectDecisi"
  "ons\0224\n\010decision\030\001 \003(\0132\".autoagric.planni"
  "ng.ObjectDecision*\267\004\n\016StopReasonCode\022\027\n\023"
  "STOP_REASON_UNKNOWN\020\000\022\034\n\030STOP_REASON_HEA"
  "D_VEHICLE\020\001\022\033\n\027STOP_REASON_DESTINATION\020\002"
  "\022\032\n\026STOP_REASON_PEDESTRIAN\020\003\022\030\n\024STOP_REA"
  "SON_OBSTACLE\020\004\022\032\n\026STOP_REASON_PREPARKING"
  "\020\005\022\026\n\022STOP_REASON_SIGNAL\020d\022\031\n\025STOP_REASO"
  "N_STOP_SIGN\020e\022\032\n\026STOP_REASON_YIELD_SIGN\020"
  "f\022\032\n\026STOP_REASON_CLEAR_ZONE\020g\022\031\n\025STOP_RE"
  "ASON_CROSSWALK\020h\022\027\n\023STOP_REASON_CREEPER\020"
  "i\022\035\n\031STOP_REASON_REFERENCE_END\020j\022\035\n\031STOP"
  "_REASON_YELLOW_SIGNAL\020k\022\031\n\025STOP_REASON_P"
  "ULL_OVER\020l\022\037\n\033STOP_REASON_SIDEPASS_SAFET"
  "Y\020m\022$\n\037STOP_REASON_PRE_OPEN_SPACE_STOP\020\310"
  "\001\022$\n\037STOP_REASON_LANE_CHANGE_URGENCY\020\311\001\022"
  "\032\n\025STOP_REASON_EMERGENCY\020\312\001b\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_autoagric_2fplanning_2fdecision_2eproto_deps[1] = {
  &::descriptor_table_autoagric_2fcommon_2fgeometry_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_autoagric_2fplanning_2fdecision_2eproto = {
  false, false, 2595, descriptor_table_protodef_autoagric_2fplanning_2fdecision_2eproto, "autoagric/planning/decision.proto", 
  &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once, descriptor_table_autoagric_2fplanning_2fdecision_2eproto_deps, 1, 16,
  schemas, file_default_instances, TableStruct_autoagric_2fplanning_2fdecision_2eproto::offsets,
  file_level_metadata_autoagric_2fplanning_2fdecision_2eproto, file_level_enum_descriptors_autoagric_2fplanning_2fdecision_2eproto, file_level_service_descriptors_autoagric_2fplanning_2fdecision_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter() {
  return &descriptor_table_autoagric_2fplanning_2fdecision_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_autoagric_2fplanning_2fdecision_2eproto(&descriptor_table_autoagric_2fplanning_2fdecision_2eproto);
namespace autoagric {
namespace planning {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjectNudge_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_autoagric_2fplanning_2fdecision_2eproto);
  return file_level_enum_descriptors_autoagric_2fplanning_2fdecision_2eproto[0];
}
bool ObjectNudge_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ObjectNudge_Type ObjectNudge::UNKNOWN;
constexpr ObjectNudge_Type ObjectNudge::LEFT_NUDGE;
constexpr ObjectNudge_Type ObjectNudge::RIGHT_NUDGE;
constexpr ObjectNudge_Type ObjectNudge::DYNAMIC_LEFT_NUDGE;
constexpr ObjectNudge_Type ObjectNudge::DYNAMIC_RIGHT_NUDGE;
constexpr ObjectNudge_Type ObjectNudge::Type_MIN;
constexpr ObjectNudge_Type ObjectNudge::Type_MAX;
constexpr int ObjectNudge::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjectSidePass_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_autoagric_2fplanning_2fdecision_2eproto);
  return file_level_enum_descriptors_autoagric_2fplanning_2fdecision_2eproto[1];
}
bool ObjectSidePass_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ObjectSidePass_Type ObjectSidePass::UNKNOWN;
constexpr ObjectSidePass_Type ObjectSidePass::LEFT;
constexpr ObjectSidePass_Type ObjectSidePass::RIGHT;
constexpr ObjectSidePass_Type ObjectSidePass::Type_MIN;
constexpr ObjectSidePass_Type ObjectSidePass::Type_MAX;
constexpr int ObjectSidePass::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StopReasonCode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_autoagric_2fplanning_2fdecision_2eproto);
  return file_level_enum_descriptors_autoagric_2fplanning_2fdecision_2eproto[2];
}
bool StopReasonCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 200:
    case 201:
    case 202:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class TargetLane::_Internal {
 public:
};

TargetLane::TargetLane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.TargetLane)
}
TargetLane::TargetLane(const TargetLane& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&start_s_, &from.start_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_limit_) -
    reinterpret_cast<char*>(&start_s_)) + sizeof(speed_limit_));
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.TargetLane)
}

inline void TargetLane::SharedCtor() {
id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_s_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&speed_limit_) -
    reinterpret_cast<char*>(&start_s_)) + sizeof(speed_limit_));
}

TargetLane::~TargetLane() {
  // @@protoc_insertion_point(destructor:autoagric.planning.TargetLane)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TargetLane::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TargetLane::ArenaDtor(void* object) {
  TargetLane* _this = reinterpret_cast< TargetLane* >(object);
  (void)_this;
}
void TargetLane::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TargetLane::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TargetLane::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.TargetLane)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_.ClearToEmpty();
  ::memset(&start_s_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&speed_limit_) -
      reinterpret_cast<char*>(&start_s_)) + sizeof(speed_limit_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TargetLane::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "autoagric.planning.TargetLane.id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double start_s = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          start_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double end_s = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          end_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double speed_limit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          speed_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TargetLane::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.TargetLane)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "autoagric.planning.TargetLane.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // double start_s = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_start_s = this->_internal_start_s();
  uint64_t raw_start_s;
  memcpy(&raw_start_s, &tmp_start_s, sizeof(tmp_start_s));
  if (raw_start_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_start_s(), target);
  }

  // double end_s = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_end_s = this->_internal_end_s();
  uint64_t raw_end_s;
  memcpy(&raw_end_s, &tmp_end_s, sizeof(tmp_end_s));
  if (raw_end_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_end_s(), target);
  }

  // double speed_limit = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed_limit = this->_internal_speed_limit();
  uint64_t raw_speed_limit;
  memcpy(&raw_speed_limit, &tmp_speed_limit, sizeof(tmp_speed_limit));
  if (raw_speed_limit != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_speed_limit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.TargetLane)
  return target;
}

size_t TargetLane::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.TargetLane)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // double start_s = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_start_s = this->_internal_start_s();
  uint64_t raw_start_s;
  memcpy(&raw_start_s, &tmp_start_s, sizeof(tmp_start_s));
  if (raw_start_s != 0) {
    total_size += 1 + 8;
  }

  // double end_s = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_end_s = this->_internal_end_s();
  uint64_t raw_end_s;
  memcpy(&raw_end_s, &tmp_end_s, sizeof(tmp_end_s));
  if (raw_end_s != 0) {
    total_size += 1 + 8;
  }

  // double speed_limit = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed_limit = this->_internal_speed_limit();
  uint64_t raw_speed_limit;
  memcpy(&raw_speed_limit, &tmp_speed_limit, sizeof(tmp_speed_limit));
  if (raw_speed_limit != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TargetLane::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TargetLane::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TargetLane::GetClassData() const { return &_class_data_; }

void TargetLane::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TargetLane *>(to)->MergeFrom(
      static_cast<const TargetLane &>(from));
}


void TargetLane::MergeFrom(const TargetLane& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.TargetLane)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _internal_set_id(from._internal_id());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_start_s = from._internal_start_s();
  uint64_t raw_start_s;
  memcpy(&raw_start_s, &tmp_start_s, sizeof(tmp_start_s));
  if (raw_start_s != 0) {
    _internal_set_start_s(from._internal_start_s());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_end_s = from._internal_end_s();
  uint64_t raw_end_s;
  memcpy(&raw_end_s, &tmp_end_s, sizeof(tmp_end_s));
  if (raw_end_s != 0) {
    _internal_set_end_s(from._internal_end_s());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed_limit = from._internal_speed_limit();
  uint64_t raw_speed_limit;
  memcpy(&raw_speed_limit, &tmp_speed_limit, sizeof(tmp_speed_limit));
  if (raw_speed_limit != 0) {
    _internal_set_speed_limit(from._internal_speed_limit());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TargetLane::CopyFrom(const TargetLane& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.TargetLane)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TargetLane::IsInitialized() const {
  return true;
}

void TargetLane::InternalSwap(TargetLane* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TargetLane, speed_limit_)
      + sizeof(TargetLane::speed_limit_)
      - PROTOBUF_FIELD_OFFSET(TargetLane, start_s_)>(
          reinterpret_cast<char*>(&start_s_),
          reinterpret_cast<char*>(&other->start_s_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TargetLane::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[0]);
}

// ===================================================================

class ObjectIgnore::_Internal {
 public:
};

ObjectIgnore::ObjectIgnore(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectIgnore)
}
ObjectIgnore::ObjectIgnore(const ObjectIgnore& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectIgnore)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectIgnore::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectIgnore::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ObjectIgnore::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[1]);
}

// ===================================================================

class ObjectStop::_Internal {
 public:
  static const ::autoagric::common::PointENU& stop_point(const ObjectStop* msg);
};

const ::autoagric::common::PointENU&
ObjectStop::_Internal::stop_point(const ObjectStop* msg) {
  return *msg->stop_point_;
}
void ObjectStop::clear_stop_point() {
  if (GetArenaForAllocation() == nullptr && stop_point_ != nullptr) {
    delete stop_point_;
  }
  stop_point_ = nullptr;
}
ObjectStop::ObjectStop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  wait_for_obstacle_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectStop)
}
ObjectStop::ObjectStop(const ObjectStop& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      wait_for_obstacle_(from.wait_for_obstacle_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stop_point()) {
    stop_point_ = new ::autoagric::common::PointENU(*from.stop_point_);
  } else {
    stop_point_ = nullptr;
  }
  ::memcpy(&distance_s_, &from.distance_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&reason_code_) -
    reinterpret_cast<char*>(&distance_s_)) + sizeof(reason_code_));
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectStop)
}

inline void ObjectStop::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&stop_point_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reason_code_) -
    reinterpret_cast<char*>(&stop_point_)) + sizeof(reason_code_));
}

ObjectStop::~ObjectStop() {
  // @@protoc_insertion_point(destructor:autoagric.planning.ObjectStop)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObjectStop::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete stop_point_;
}

void ObjectStop::ArenaDtor(void* object) {
  ObjectStop* _this = reinterpret_cast< ObjectStop* >(object);
  (void)_this;
}
void ObjectStop::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObjectStop::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObjectStop::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.ObjectStop)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  wait_for_obstacle_.Clear();
  if (GetArenaForAllocation() == nullptr && stop_point_ != nullptr) {
    delete stop_point_;
  }
  stop_point_ = nullptr;
  ::memset(&distance_s_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reason_code_) -
      reinterpret_cast<char*>(&distance_s_)) + sizeof(reason_code_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectStop::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autoagric.planning.StopReasonCode reason_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_reason_code(static_cast<::autoagric::planning::StopReasonCode>(val));
        } else
          goto handle_unusual;
        continue;
      // double distance_s = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          distance_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.PointENU stop_point = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double stop_heading = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          stop_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated string wait_for_obstacle = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_wait_for_obstacle();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "autoagric.planning.ObjectStop.wait_for_obstacle"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectStop::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.ObjectStop)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .autoagric.planning.StopReasonCode reason_code = 1;
  if (this->_internal_reason_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_reason_code(), target);
  }

  // double distance_s = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = this->_internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_distance_s(), target);
  }

  // .autoagric.common.PointENU stop_point = 3;
  if (this->_internal_has_stop_point()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::stop_point(this), target, stream);
  }

  // double stop_heading = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop_heading = this->_internal_stop_heading();
  uint64_t raw_stop_heading;
  memcpy(&raw_stop_heading, &tmp_stop_heading, sizeof(tmp_stop_heading));
  if (raw_stop_heading != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_stop_heading(), target);
  }

  // repeated string wait_for_obstacle = 5;
  for (int i = 0, n = this->_internal_wait_for_obstacle_size(); i < n; i++) {
    const auto& s = this->_internal_wait_for_obstacle(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "autoagric.planning.ObjectStop.wait_for_obstacle");
    target = stream->WriteString(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.ObjectStop)
  return target;
}

size_t ObjectStop::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.ObjectStop)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string wait_for_obstacle = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(wait_for_obstacle_.size());
  for (int i = 0, n = wait_for_obstacle_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      wait_for_obstacle_.Get(i));
  }

  // .autoagric.common.PointENU stop_point = 3;
  if (this->_internal_has_stop_point()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *stop_point_);
  }

  // double distance_s = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = this->_internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    total_size += 1 + 8;
  }

  // double stop_heading = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop_heading = this->_internal_stop_heading();
  uint64_t raw_stop_heading;
  memcpy(&raw_stop_heading, &tmp_stop_heading, sizeof(tmp_stop_heading));
  if (raw_stop_heading != 0) {
    total_size += 1 + 8;
  }

  // .autoagric.planning.StopReasonCode reason_code = 1;
  if (this->_internal_reason_code() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_reason_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectStop::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectStop::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectStop::GetClassData() const { return &_class_data_; }

void ObjectStop::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectStop *>(to)->MergeFrom(
      static_cast<const ObjectStop &>(from));
}


void ObjectStop::MergeFrom(const ObjectStop& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.ObjectStop)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  wait_for_obstacle_.MergeFrom(from.wait_for_obstacle_);
  if (from._internal_has_stop_point()) {
    _internal_mutable_stop_point()->::autoagric::common::PointENU::MergeFrom(from._internal_stop_point());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = from._internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    _internal_set_distance_s(from._internal_distance_s());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_stop_heading = from._internal_stop_heading();
  uint64_t raw_stop_heading;
  memcpy(&raw_stop_heading, &tmp_stop_heading, sizeof(tmp_stop_heading));
  if (raw_stop_heading != 0) {
    _internal_set_stop_heading(from._internal_stop_heading());
  }
  if (from._internal_reason_code() != 0) {
    _internal_set_reason_code(from._internal_reason_code());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectStop::CopyFrom(const ObjectStop& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.ObjectStop)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectStop::IsInitialized() const {
  return true;
}

void ObjectStop::InternalSwap(ObjectStop* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  wait_for_obstacle_.InternalSwap(&other->wait_for_obstacle_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObjectStop, reason_code_)
      + sizeof(ObjectStop::reason_code_)
      - PROTOBUF_FIELD_OFFSET(ObjectStop, stop_point_)>(
          reinterpret_cast<char*>(&stop_point_),
          reinterpret_cast<char*>(&other->stop_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectStop::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[2]);
}

// ===================================================================

class ObjectNudge::_Internal {
 public:
};

ObjectNudge::ObjectNudge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectNudge)
}
ObjectNudge::ObjectNudge(const ObjectNudge& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&distance_l_, &from.distance_l_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&distance_l_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectNudge)
}

inline void ObjectNudge::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&distance_l_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&distance_l_)) + sizeof(type_));
}

ObjectNudge::~ObjectNudge() {
  // @@protoc_insertion_point(destructor:autoagric.planning.ObjectNudge)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObjectNudge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ObjectNudge::ArenaDtor(void* object) {
  ObjectNudge* _this = reinterpret_cast< ObjectNudge* >(object);
  (void)_this;
}
void ObjectNudge::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObjectNudge::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObjectNudge::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.ObjectNudge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&distance_l_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&distance_l_)) + sizeof(type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectNudge::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autoagric.planning.ObjectNudge.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::autoagric::planning::ObjectNudge_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // double distance_l = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          distance_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectNudge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.ObjectNudge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .autoagric.planning.ObjectNudge.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // double distance_l = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_l = this->_internal_distance_l();
  uint64_t raw_distance_l;
  memcpy(&raw_distance_l, &tmp_distance_l, sizeof(tmp_distance_l));
  if (raw_distance_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_distance_l(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.ObjectNudge)
  return target;
}

size_t ObjectNudge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.ObjectNudge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double distance_l = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_l = this->_internal_distance_l();
  uint64_t raw_distance_l;
  memcpy(&raw_distance_l, &tmp_distance_l, sizeof(tmp_distance_l));
  if (raw_distance_l != 0) {
    total_size += 1 + 8;
  }

  // .autoagric.planning.ObjectNudge.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectNudge::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectNudge::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectNudge::GetClassData() const { return &_class_data_; }

void ObjectNudge::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectNudge *>(to)->MergeFrom(
      static_cast<const ObjectNudge &>(from));
}


void ObjectNudge::MergeFrom(const ObjectNudge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.ObjectNudge)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_l = from._internal_distance_l();
  uint64_t raw_distance_l;
  memcpy(&raw_distance_l, &tmp_distance_l, sizeof(tmp_distance_l));
  if (raw_distance_l != 0) {
    _internal_set_distance_l(from._internal_distance_l());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectNudge::CopyFrom(const ObjectNudge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.ObjectNudge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectNudge::IsInitialized() const {
  return true;
}

void ObjectNudge::InternalSwap(ObjectNudge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObjectNudge, type_)
      + sizeof(ObjectNudge::type_)
      - PROTOBUF_FIELD_OFFSET(ObjectNudge, distance_l_)>(
          reinterpret_cast<char*>(&distance_l_),
          reinterpret_cast<char*>(&other->distance_l_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectNudge::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[3]);
}

// ===================================================================

class ObjectYield::_Internal {
 public:
  static const ::autoagric::common::PointENU& fence_point(const ObjectYield* msg);
};

const ::autoagric::common::PointENU&
ObjectYield::_Internal::fence_point(const ObjectYield* msg) {
  return *msg->fence_point_;
}
void ObjectYield::clear_fence_point() {
  if (GetArenaForAllocation() == nullptr && fence_point_ != nullptr) {
    delete fence_point_;
  }
  fence_point_ = nullptr;
}
ObjectYield::ObjectYield(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectYield)
}
ObjectYield::ObjectYield(const ObjectYield& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_fence_point()) {
    fence_point_ = new ::autoagric::common::PointENU(*from.fence_point_);
  } else {
    fence_point_ = nullptr;
  }
  ::memcpy(&distance_s_, &from.distance_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_buffer_) -
    reinterpret_cast<char*>(&distance_s_)) + sizeof(time_buffer_));
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectYield)
}

inline void ObjectYield::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fence_point_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&time_buffer_) -
    reinterpret_cast<char*>(&fence_point_)) + sizeof(time_buffer_));
}

ObjectYield::~ObjectYield() {
  // @@protoc_insertion_point(destructor:autoagric.planning.ObjectYield)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObjectYield::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete fence_point_;
}

void ObjectYield::ArenaDtor(void* object) {
  ObjectYield* _this = reinterpret_cast< ObjectYield* >(object);
  (void)_this;
}
void ObjectYield::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObjectYield::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObjectYield::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.ObjectYield)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && fence_point_ != nullptr) {
    delete fence_point_;
  }
  fence_point_ = nullptr;
  ::memset(&distance_s_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_buffer_) -
      reinterpret_cast<char*>(&distance_s_)) + sizeof(time_buffer_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectYield::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double distance_s = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          distance_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.PointENU fence_point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fence_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fence_heading = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          fence_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double time_buffer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          time_buffer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectYield::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.ObjectYield)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double distance_s = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = this->_internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_distance_s(), target);
  }

  // .autoagric.common.PointENU fence_point = 2;
  if (this->_internal_has_fence_point()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::fence_point(this), target, stream);
  }

  // double fence_heading = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fence_heading = this->_internal_fence_heading();
  uint64_t raw_fence_heading;
  memcpy(&raw_fence_heading, &tmp_fence_heading, sizeof(tmp_fence_heading));
  if (raw_fence_heading != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_fence_heading(), target);
  }

  // double time_buffer = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_buffer = this->_internal_time_buffer();
  uint64_t raw_time_buffer;
  memcpy(&raw_time_buffer, &tmp_time_buffer, sizeof(tmp_time_buffer));
  if (raw_time_buffer != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_time_buffer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.ObjectYield)
  return target;
}

size_t ObjectYield::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.ObjectYield)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .autoagric.common.PointENU fence_point = 2;
  if (this->_internal_has_fence_point()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *fence_point_);
  }

  // double distance_s = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = this->_internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    total_size += 1 + 8;
  }

  // double fence_heading = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fence_heading = this->_internal_fence_heading();
  uint64_t raw_fence_heading;
  memcpy(&raw_fence_heading, &tmp_fence_heading, sizeof(tmp_fence_heading));
  if (raw_fence_heading != 0) {
    total_size += 1 + 8;
  }

  // double time_buffer = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_buffer = this->_internal_time_buffer();
  uint64_t raw_time_buffer;
  memcpy(&raw_time_buffer, &tmp_time_buffer, sizeof(tmp_time_buffer));
  if (raw_time_buffer != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectYield::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectYield::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectYield::GetClassData() const { return &_class_data_; }

void ObjectYield::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectYield *>(to)->MergeFrom(
      static_cast<const ObjectYield &>(from));
}


void ObjectYield::MergeFrom(const ObjectYield& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.ObjectYield)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_fence_point()) {
    _internal_mutable_fence_point()->::autoagric::common::PointENU::MergeFrom(from._internal_fence_point());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = from._internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    _internal_set_distance_s(from._internal_distance_s());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fence_heading = from._internal_fence_heading();
  uint64_t raw_fence_heading;
  memcpy(&raw_fence_heading, &tmp_fence_heading, sizeof(tmp_fence_heading));
  if (raw_fence_heading != 0) {
    _internal_set_fence_heading(from._internal_fence_heading());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_buffer = from._internal_time_buffer();
  uint64_t raw_time_buffer;
  memcpy(&raw_time_buffer, &tmp_time_buffer, sizeof(tmp_time_buffer));
  if (raw_time_buffer != 0) {
    _internal_set_time_buffer(from._internal_time_buffer());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectYield::CopyFrom(const ObjectYield& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.ObjectYield)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectYield::IsInitialized() const {
  return true;
}

void ObjectYield::InternalSwap(ObjectYield* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObjectYield, time_buffer_)
      + sizeof(ObjectYield::time_buffer_)
      - PROTOBUF_FIELD_OFFSET(ObjectYield, fence_point_)>(
          reinterpret_cast<char*>(&fence_point_),
          reinterpret_cast<char*>(&other->fence_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectYield::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[4]);
}

// ===================================================================

class ObjectFollow::_Internal {
 public:
  static const ::autoagric::common::PointENU& fence_point(const ObjectFollow* msg);
};

const ::autoagric::common::PointENU&
ObjectFollow::_Internal::fence_point(const ObjectFollow* msg) {
  return *msg->fence_point_;
}
void ObjectFollow::clear_fence_point() {
  if (GetArenaForAllocation() == nullptr && fence_point_ != nullptr) {
    delete fence_point_;
  }
  fence_point_ = nullptr;
}
ObjectFollow::ObjectFollow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectFollow)
}
ObjectFollow::ObjectFollow(const ObjectFollow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_fence_point()) {
    fence_point_ = new ::autoagric::common::PointENU(*from.fence_point_);
  } else {
    fence_point_ = nullptr;
  }
  ::memcpy(&distance_s_, &from.distance_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&fence_heading_) -
    reinterpret_cast<char*>(&distance_s_)) + sizeof(fence_heading_));
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectFollow)
}

inline void ObjectFollow::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fence_point_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fence_heading_) -
    reinterpret_cast<char*>(&fence_point_)) + sizeof(fence_heading_));
}

ObjectFollow::~ObjectFollow() {
  // @@protoc_insertion_point(destructor:autoagric.planning.ObjectFollow)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObjectFollow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete fence_point_;
}

void ObjectFollow::ArenaDtor(void* object) {
  ObjectFollow* _this = reinterpret_cast< ObjectFollow* >(object);
  (void)_this;
}
void ObjectFollow::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObjectFollow::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObjectFollow::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.ObjectFollow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && fence_point_ != nullptr) {
    delete fence_point_;
  }
  fence_point_ = nullptr;
  ::memset(&distance_s_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fence_heading_) -
      reinterpret_cast<char*>(&distance_s_)) + sizeof(fence_heading_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectFollow::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double distance_s = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          distance_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.PointENU fence_point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fence_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fence_heading = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          fence_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectFollow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.ObjectFollow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double distance_s = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = this->_internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_distance_s(), target);
  }

  // .autoagric.common.PointENU fence_point = 2;
  if (this->_internal_has_fence_point()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::fence_point(this), target, stream);
  }

  // double fence_heading = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fence_heading = this->_internal_fence_heading();
  uint64_t raw_fence_heading;
  memcpy(&raw_fence_heading, &tmp_fence_heading, sizeof(tmp_fence_heading));
  if (raw_fence_heading != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_fence_heading(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.ObjectFollow)
  return target;
}

size_t ObjectFollow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.ObjectFollow)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .autoagric.common.PointENU fence_point = 2;
  if (this->_internal_has_fence_point()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *fence_point_);
  }

  // double distance_s = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = this->_internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    total_size += 1 + 8;
  }

  // double fence_heading = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fence_heading = this->_internal_fence_heading();
  uint64_t raw_fence_heading;
  memcpy(&raw_fence_heading, &tmp_fence_heading, sizeof(tmp_fence_heading));
  if (raw_fence_heading != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectFollow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectFollow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectFollow::GetClassData() const { return &_class_data_; }

void ObjectFollow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectFollow *>(to)->MergeFrom(
      static_cast<const ObjectFollow &>(from));
}


void ObjectFollow::MergeFrom(const ObjectFollow& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.ObjectFollow)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_fence_point()) {
    _internal_mutable_fence_point()->::autoagric::common::PointENU::MergeFrom(from._internal_fence_point());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = from._internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    _internal_set_distance_s(from._internal_distance_s());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fence_heading = from._internal_fence_heading();
  uint64_t raw_fence_heading;
  memcpy(&raw_fence_heading, &tmp_fence_heading, sizeof(tmp_fence_heading));
  if (raw_fence_heading != 0) {
    _internal_set_fence_heading(from._internal_fence_heading());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectFollow::CopyFrom(const ObjectFollow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.ObjectFollow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectFollow::IsInitialized() const {
  return true;
}

void ObjectFollow::InternalSwap(ObjectFollow* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObjectFollow, fence_heading_)
      + sizeof(ObjectFollow::fence_heading_)
      - PROTOBUF_FIELD_OFFSET(ObjectFollow, fence_point_)>(
          reinterpret_cast<char*>(&fence_point_),
          reinterpret_cast<char*>(&other->fence_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectFollow::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[5]);
}

// ===================================================================

class ObjectOvertake::_Internal {
 public:
  static const ::autoagric::common::PointENU& fence_point(const ObjectOvertake* msg);
};

const ::autoagric::common::PointENU&
ObjectOvertake::_Internal::fence_point(const ObjectOvertake* msg) {
  return *msg->fence_point_;
}
void ObjectOvertake::clear_fence_point() {
  if (GetArenaForAllocation() == nullptr && fence_point_ != nullptr) {
    delete fence_point_;
  }
  fence_point_ = nullptr;
}
ObjectOvertake::ObjectOvertake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectOvertake)
}
ObjectOvertake::ObjectOvertake(const ObjectOvertake& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_fence_point()) {
    fence_point_ = new ::autoagric::common::PointENU(*from.fence_point_);
  } else {
    fence_point_ = nullptr;
  }
  ::memcpy(&distance_s_, &from.distance_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_buffer_) -
    reinterpret_cast<char*>(&distance_s_)) + sizeof(time_buffer_));
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectOvertake)
}

inline void ObjectOvertake::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fence_point_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&time_buffer_) -
    reinterpret_cast<char*>(&fence_point_)) + sizeof(time_buffer_));
}

ObjectOvertake::~ObjectOvertake() {
  // @@protoc_insertion_point(destructor:autoagric.planning.ObjectOvertake)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObjectOvertake::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete fence_point_;
}

void ObjectOvertake::ArenaDtor(void* object) {
  ObjectOvertake* _this = reinterpret_cast< ObjectOvertake* >(object);
  (void)_this;
}
void ObjectOvertake::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObjectOvertake::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObjectOvertake::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.ObjectOvertake)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && fence_point_ != nullptr) {
    delete fence_point_;
  }
  fence_point_ = nullptr;
  ::memset(&distance_s_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_buffer_) -
      reinterpret_cast<char*>(&distance_s_)) + sizeof(time_buffer_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectOvertake::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double distance_s = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          distance_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.PointENU fence_point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fence_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fence_heading = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          fence_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double time_buffer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          time_buffer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectOvertake::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.ObjectOvertake)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double distance_s = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = this->_internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_distance_s(), target);
  }

  // .autoagric.common.PointENU fence_point = 2;
  if (this->_internal_has_fence_point()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::fence_point(this), target, stream);
  }

  // double fence_heading = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fence_heading = this->_internal_fence_heading();
  uint64_t raw_fence_heading;
  memcpy(&raw_fence_heading, &tmp_fence_heading, sizeof(tmp_fence_heading));
  if (raw_fence_heading != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_fence_heading(), target);
  }

  // double time_buffer = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_buffer = this->_internal_time_buffer();
  uint64_t raw_time_buffer;
  memcpy(&raw_time_buffer, &tmp_time_buffer, sizeof(tmp_time_buffer));
  if (raw_time_buffer != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_time_buffer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.ObjectOvertake)
  return target;
}

size_t ObjectOvertake::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.ObjectOvertake)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .autoagric.common.PointENU fence_point = 2;
  if (this->_internal_has_fence_point()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *fence_point_);
  }

  // double distance_s = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = this->_internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    total_size += 1 + 8;
  }

  // double fence_heading = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fence_heading = this->_internal_fence_heading();
  uint64_t raw_fence_heading;
  memcpy(&raw_fence_heading, &tmp_fence_heading, sizeof(tmp_fence_heading));
  if (raw_fence_heading != 0) {
    total_size += 1 + 8;
  }

  // double time_buffer = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_buffer = this->_internal_time_buffer();
  uint64_t raw_time_buffer;
  memcpy(&raw_time_buffer, &tmp_time_buffer, sizeof(tmp_time_buffer));
  if (raw_time_buffer != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectOvertake::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectOvertake::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectOvertake::GetClassData() const { return &_class_data_; }

void ObjectOvertake::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectOvertake *>(to)->MergeFrom(
      static_cast<const ObjectOvertake &>(from));
}


void ObjectOvertake::MergeFrom(const ObjectOvertake& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.ObjectOvertake)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_fence_point()) {
    _internal_mutable_fence_point()->::autoagric::common::PointENU::MergeFrom(from._internal_fence_point());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance_s = from._internal_distance_s();
  uint64_t raw_distance_s;
  memcpy(&raw_distance_s, &tmp_distance_s, sizeof(tmp_distance_s));
  if (raw_distance_s != 0) {
    _internal_set_distance_s(from._internal_distance_s());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fence_heading = from._internal_fence_heading();
  uint64_t raw_fence_heading;
  memcpy(&raw_fence_heading, &tmp_fence_heading, sizeof(tmp_fence_heading));
  if (raw_fence_heading != 0) {
    _internal_set_fence_heading(from._internal_fence_heading());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_buffer = from._internal_time_buffer();
  uint64_t raw_time_buffer;
  memcpy(&raw_time_buffer, &tmp_time_buffer, sizeof(tmp_time_buffer));
  if (raw_time_buffer != 0) {
    _internal_set_time_buffer(from._internal_time_buffer());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectOvertake::CopyFrom(const ObjectOvertake& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.ObjectOvertake)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectOvertake::IsInitialized() const {
  return true;
}

void ObjectOvertake::InternalSwap(ObjectOvertake* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObjectOvertake, time_buffer_)
      + sizeof(ObjectOvertake::time_buffer_)
      - PROTOBUF_FIELD_OFFSET(ObjectOvertake, fence_point_)>(
          reinterpret_cast<char*>(&fence_point_),
          reinterpret_cast<char*>(&other->fence_point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectOvertake::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[6]);
}

// ===================================================================

class ObjectSidePass::_Internal {
 public:
};

ObjectSidePass::ObjectSidePass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectSidePass)
}
ObjectSidePass::ObjectSidePass(const ObjectSidePass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectSidePass)
}

inline void ObjectSidePass::SharedCtor() {
type_ = 0;
}

ObjectSidePass::~ObjectSidePass() {
  // @@protoc_insertion_point(destructor:autoagric.planning.ObjectSidePass)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObjectSidePass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ObjectSidePass::ArenaDtor(void* object) {
  ObjectSidePass* _this = reinterpret_cast< ObjectSidePass* >(object);
  (void)_this;
}
void ObjectSidePass::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObjectSidePass::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObjectSidePass::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.ObjectSidePass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectSidePass::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autoagric.planning.ObjectSidePass.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::autoagric::planning::ObjectSidePass_Type>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectSidePass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.ObjectSidePass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .autoagric.planning.ObjectSidePass.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.ObjectSidePass)
  return target;
}

size_t ObjectSidePass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.ObjectSidePass)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .autoagric.planning.ObjectSidePass.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectSidePass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectSidePass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectSidePass::GetClassData() const { return &_class_data_; }

void ObjectSidePass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectSidePass *>(to)->MergeFrom(
      static_cast<const ObjectSidePass &>(from));
}


void ObjectSidePass::MergeFrom(const ObjectSidePass& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.ObjectSidePass)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectSidePass::CopyFrom(const ObjectSidePass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.ObjectSidePass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectSidePass::IsInitialized() const {
  return true;
}

void ObjectSidePass::InternalSwap(ObjectSidePass* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectSidePass::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[7]);
}

// ===================================================================

class ObjectAvoid::_Internal {
 public:
};

ObjectAvoid::ObjectAvoid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectAvoid)
}
ObjectAvoid::ObjectAvoid(const ObjectAvoid& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectAvoid)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectAvoid::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectAvoid::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ObjectAvoid::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[8]);
}

// ===================================================================

class ObjectStatus::_Internal {
 public:
  static const ::autoagric::planning::ObjectMotionType& motion_type(const ObjectStatus* msg);
  static const ::autoagric::planning::ObjectDecisionType& decision_type(const ObjectStatus* msg);
};

const ::autoagric::planning::ObjectMotionType&
ObjectStatus::_Internal::motion_type(const ObjectStatus* msg) {
  return *msg->motion_type_;
}
const ::autoagric::planning::ObjectDecisionType&
ObjectStatus::_Internal::decision_type(const ObjectStatus* msg) {
  return *msg->decision_type_;
}
ObjectStatus::ObjectStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectStatus)
}
ObjectStatus::ObjectStatus(const ObjectStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_motion_type()) {
    motion_type_ = new ::autoagric::planning::ObjectMotionType(*from.motion_type_);
  } else {
    motion_type_ = nullptr;
  }
  if (from._internal_has_decision_type()) {
    decision_type_ = new ::autoagric::planning::ObjectDecisionType(*from.decision_type_);
  } else {
    decision_type_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectStatus)
}

inline void ObjectStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&motion_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&decision_type_) -
    reinterpret_cast<char*>(&motion_type_)) + sizeof(decision_type_));
}

ObjectStatus::~ObjectStatus() {
  // @@protoc_insertion_point(destructor:autoagric.planning.ObjectStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObjectStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete motion_type_;
  if (this != internal_default_instance()) delete decision_type_;
}

void ObjectStatus::ArenaDtor(void* object) {
  ObjectStatus* _this = reinterpret_cast< ObjectStatus* >(object);
  (void)_this;
}
void ObjectStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObjectStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObjectStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.ObjectStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && motion_type_ != nullptr) {
    delete motion_type_;
  }
  motion_type_ = nullptr;
  if (GetArenaForAllocation() == nullptr && decision_type_ != nullptr) {
    delete decision_type_;
  }
  decision_type_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autoagric.planning.ObjectMotionType motion_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_motion_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.planning.ObjectDecisionType decision_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_decision_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.ObjectStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .autoagric.planning.ObjectMotionType motion_type = 1;
  if (this->_internal_has_motion_type()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::motion_type(this), target, stream);
  }

  // .autoagric.planning.ObjectDecisionType decision_type = 2;
  if (this->_internal_has_decision_type()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::decision_type(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.ObjectStatus)
  return target;
}

size_t ObjectStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.ObjectStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .autoagric.planning.ObjectMotionType motion_type = 1;
  if (this->_internal_has_motion_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *motion_type_);
  }

  // .autoagric.planning.ObjectDecisionType decision_type = 2;
  if (this->_internal_has_decision_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *decision_type_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectStatus::GetClassData() const { return &_class_data_; }

void ObjectStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectStatus *>(to)->MergeFrom(
      static_cast<const ObjectStatus &>(from));
}


void ObjectStatus::MergeFrom(const ObjectStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.ObjectStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_motion_type()) {
    _internal_mutable_motion_type()->::autoagric::planning::ObjectMotionType::MergeFrom(from._internal_motion_type());
  }
  if (from._internal_has_decision_type()) {
    _internal_mutable_decision_type()->::autoagric::planning::ObjectDecisionType::MergeFrom(from._internal_decision_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectStatus::CopyFrom(const ObjectStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.ObjectStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectStatus::IsInitialized() const {
  return true;
}

void ObjectStatus::InternalSwap(ObjectStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObjectStatus, decision_type_)
      + sizeof(ObjectStatus::decision_type_)
      - PROTOBUF_FIELD_OFFSET(ObjectStatus, motion_type_)>(
          reinterpret_cast<char*>(&motion_type_),
          reinterpret_cast<char*>(&other->motion_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[9]);
}

// ===================================================================

class ObjectStatic::_Internal {
 public:
};

ObjectStatic::ObjectStatic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectStatic)
}
ObjectStatic::ObjectStatic(const ObjectStatic& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectStatic)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectStatic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectStatic::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ObjectStatic::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[10]);
}

// ===================================================================

class ObjectDynamic::_Internal {
 public:
};

ObjectDynamic::ObjectDynamic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectDynamic)
}
ObjectDynamic::ObjectDynamic(const ObjectDynamic& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectDynamic)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectDynamic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectDynamic::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ObjectDynamic::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[11]);
}

// ===================================================================

class ObjectMotionType::_Internal {
 public:
  static const ::autoagric::planning::ObjectStatic& static_(const ObjectMotionType* msg);
  static const ::autoagric::planning::ObjectDynamic& dynamic(const ObjectMotionType* msg);
};

const ::autoagric::planning::ObjectStatic&
ObjectMotionType::_Internal::static_(const ObjectMotionType* msg) {
  return *msg->motion_tag_.static__;
}
const ::autoagric::planning::ObjectDynamic&
ObjectMotionType::_Internal::dynamic(const ObjectMotionType* msg) {
  return *msg->motion_tag_.dynamic_;
}
void ObjectMotionType::set_allocated_static_(::autoagric::planning::ObjectStatic* static_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_motion_tag();
  if (static_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectStatic>::GetOwningArena(static_);
    if (message_arena != submessage_arena) {
      static_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, static_, submessage_arena);
    }
    set_has_static_();
    motion_tag_.static__ = static_;
  }
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectMotionType.static)
}
void ObjectMotionType::set_allocated_dynamic(::autoagric::planning::ObjectDynamic* dynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_motion_tag();
  if (dynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectDynamic>::GetOwningArena(dynamic);
    if (message_arena != submessage_arena) {
      dynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic, submessage_arena);
    }
    set_has_dynamic();
    motion_tag_.dynamic_ = dynamic;
  }
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectMotionType.dynamic)
}
ObjectMotionType::ObjectMotionType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectMotionType)
}
ObjectMotionType::ObjectMotionType(const ObjectMotionType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_motion_tag();
  switch (from.motion_tag_case()) {
    case kStatic: {
      _internal_mutable_static_()->::autoagric::planning::ObjectStatic::MergeFrom(from._internal_static_());
      break;
    }
    case kDynamic: {
      _internal_mutable_dynamic()->::autoagric::planning::ObjectDynamic::MergeFrom(from._internal_dynamic());
      break;
    }
    case MOTION_TAG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectMotionType)
}

inline void ObjectMotionType::SharedCtor() {
clear_has_motion_tag();
}

ObjectMotionType::~ObjectMotionType() {
  // @@protoc_insertion_point(destructor:autoagric.planning.ObjectMotionType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObjectMotionType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_motion_tag()) {
    clear_motion_tag();
  }
}

void ObjectMotionType::ArenaDtor(void* object) {
  ObjectMotionType* _this = reinterpret_cast< ObjectMotionType* >(object);
  (void)_this;
}
void ObjectMotionType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObjectMotionType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObjectMotionType::clear_motion_tag() {
// @@protoc_insertion_point(one_of_clear_start:autoagric.planning.ObjectMotionType)
  switch (motion_tag_case()) {
    case kStatic: {
      if (GetArenaForAllocation() == nullptr) {
        delete motion_tag_.static__;
      }
      break;
    }
    case kDynamic: {
      if (GetArenaForAllocation() == nullptr) {
        delete motion_tag_.dynamic_;
      }
      break;
    }
    case MOTION_TAG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = MOTION_TAG_NOT_SET;
}


void ObjectMotionType::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.ObjectMotionType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_motion_tag();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectMotionType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autoagric.planning.ObjectStatic static = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_static_(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.planning.ObjectDynamic dynamic = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dynamic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectMotionType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.ObjectMotionType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .autoagric.planning.ObjectStatic static = 1;
  if (_internal_has_static_()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::static_(this), target, stream);
  }

  // .autoagric.planning.ObjectDynamic dynamic = 2;
  if (_internal_has_dynamic()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::dynamic(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.ObjectMotionType)
  return target;
}

size_t ObjectMotionType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.ObjectMotionType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (motion_tag_case()) {
    // .autoagric.planning.ObjectStatic static = 1;
    case kStatic: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *motion_tag_.static__);
      break;
    }
    // .autoagric.planning.ObjectDynamic dynamic = 2;
    case kDynamic: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *motion_tag_.dynamic_);
      break;
    }
    case MOTION_TAG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectMotionType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectMotionType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectMotionType::GetClassData() const { return &_class_data_; }

void ObjectMotionType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectMotionType *>(to)->MergeFrom(
      static_cast<const ObjectMotionType &>(from));
}


void ObjectMotionType::MergeFrom(const ObjectMotionType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.ObjectMotionType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.motion_tag_case()) {
    case kStatic: {
      _internal_mutable_static_()->::autoagric::planning::ObjectStatic::MergeFrom(from._internal_static_());
      break;
    }
    case kDynamic: {
      _internal_mutable_dynamic()->::autoagric::planning::ObjectDynamic::MergeFrom(from._internal_dynamic());
      break;
    }
    case MOTION_TAG_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectMotionType::CopyFrom(const ObjectMotionType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.ObjectMotionType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectMotionType::IsInitialized() const {
  return true;
}

void ObjectMotionType::InternalSwap(ObjectMotionType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(motion_tag_, other->motion_tag_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectMotionType::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[12]);
}

// ===================================================================

class ObjectDecisionType::_Internal {
 public:
  static const ::autoagric::planning::ObjectIgnore& ignore(const ObjectDecisionType* msg);
  static const ::autoagric::planning::ObjectStop& stop(const ObjectDecisionType* msg);
  static const ::autoagric::planning::ObjectFollow& follow(const ObjectDecisionType* msg);
  static const ::autoagric::planning::ObjectYield& yield(const ObjectDecisionType* msg);
  static const ::autoagric::planning::ObjectOvertake& overtake(const ObjectDecisionType* msg);
  static const ::autoagric::planning::ObjectNudge& nudge(const ObjectDecisionType* msg);
  static const ::autoagric::planning::ObjectAvoid& avoid(const ObjectDecisionType* msg);
  static const ::autoagric::planning::ObjectSidePass& side_pass(const ObjectDecisionType* msg);
};

const ::autoagric::planning::ObjectIgnore&
ObjectDecisionType::_Internal::ignore(const ObjectDecisionType* msg) {
  return *msg->object_tag_.ignore_;
}
const ::autoagric::planning::ObjectStop&
ObjectDecisionType::_Internal::stop(const ObjectDecisionType* msg) {
  return *msg->object_tag_.stop_;
}
const ::autoagric::planning::ObjectFollow&
ObjectDecisionType::_Internal::follow(const ObjectDecisionType* msg) {
  return *msg->object_tag_.follow_;
}
const ::autoagric::planning::ObjectYield&
ObjectDecisionType::_Internal::yield(const ObjectDecisionType* msg) {
  return *msg->object_tag_.yield_;
}
const ::autoagric::planning::ObjectOvertake&
ObjectDecisionType::_Internal::overtake(const ObjectDecisionType* msg) {
  return *msg->object_tag_.overtake_;
}
const ::autoagric::planning::ObjectNudge&
ObjectDecisionType::_Internal::nudge(const ObjectDecisionType* msg) {
  return *msg->object_tag_.nudge_;
}
const ::autoagric::planning::ObjectAvoid&
ObjectDecisionType::_Internal::avoid(const ObjectDecisionType* msg) {
  return *msg->object_tag_.avoid_;
}
const ::autoagric::planning::ObjectSidePass&
ObjectDecisionType::_Internal::side_pass(const ObjectDecisionType* msg) {
  return *msg->object_tag_.side_pass_;
}
void ObjectDecisionType::set_allocated_ignore(::autoagric::planning::ObjectIgnore* ignore) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object_tag();
  if (ignore) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectIgnore>::GetOwningArena(ignore);
    if (message_arena != submessage_arena) {
      ignore = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ignore, submessage_arena);
    }
    set_has_ignore();
    object_tag_.ignore_ = ignore;
  }
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectDecisionType.ignore)
}
void ObjectDecisionType::set_allocated_stop(::autoagric::planning::ObjectStop* stop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object_tag();
  if (stop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectStop>::GetOwningArena(stop);
    if (message_arena != submessage_arena) {
      stop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop, submessage_arena);
    }
    set_has_stop();
    object_tag_.stop_ = stop;
  }
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectDecisionType.stop)
}
void ObjectDecisionType::set_allocated_follow(::autoagric::planning::ObjectFollow* follow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object_tag();
  if (follow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectFollow>::GetOwningArena(follow);
    if (message_arena != submessage_arena) {
      follow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, follow, submessage_arena);
    }
    set_has_follow();
    object_tag_.follow_ = follow;
  }
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectDecisionType.follow)
}
void ObjectDecisionType::set_allocated_yield(::autoagric::planning::ObjectYield* yield) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object_tag();
  if (yield) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectYield>::GetOwningArena(yield);
    if (message_arena != submessage_arena) {
      yield = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yield, submessage_arena);
    }
    set_has_yield();
    object_tag_.yield_ = yield;
  }
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectDecisionType.yield)
}
void ObjectDecisionType::set_allocated_overtake(::autoagric::planning::ObjectOvertake* overtake) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object_tag();
  if (overtake) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectOvertake>::GetOwningArena(overtake);
    if (message_arena != submessage_arena) {
      overtake = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overtake, submessage_arena);
    }
    set_has_overtake();
    object_tag_.overtake_ = overtake;
  }
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectDecisionType.overtake)
}
void ObjectDecisionType::set_allocated_nudge(::autoagric::planning::ObjectNudge* nudge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object_tag();
  if (nudge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectNudge>::GetOwningArena(nudge);
    if (message_arena != submessage_arena) {
      nudge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nudge, submessage_arena);
    }
    set_has_nudge();
    object_tag_.nudge_ = nudge;
  }
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectDecisionType.nudge)
}
void ObjectDecisionType::set_allocated_avoid(::autoagric::planning::ObjectAvoid* avoid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object_tag();
  if (avoid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectAvoid>::GetOwningArena(avoid);
    if (message_arena != submessage_arena) {
      avoid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, avoid, submessage_arena);
    }
    set_has_avoid();
    object_tag_.avoid_ = avoid;
  }
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectDecisionType.avoid)
}
void ObjectDecisionType::set_allocated_side_pass(::autoagric::planning::ObjectSidePass* side_pass) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object_tag();
  if (side_pass) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectSidePass>::GetOwningArena(side_pass);
    if (message_arena != submessage_arena) {
      side_pass = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, side_pass, submessage_arena);
    }
    set_has_side_pass();
    object_tag_.side_pass_ = side_pass;
  }
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectDecisionType.side_pass)
}
ObjectDecisionType::ObjectDecisionType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectDecisionType)
}
ObjectDecisionType::ObjectDecisionType(const ObjectDecisionType& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_object_tag();
  switch (from.object_tag_case()) {
    case kIgnore: {
      _internal_mutable_ignore()->::autoagric::planning::ObjectIgnore::MergeFrom(from._internal_ignore());
      break;
    }
    case kStop: {
      _internal_mutable_stop()->::autoagric::planning::ObjectStop::MergeFrom(from._internal_stop());
      break;
    }
    case kFollow: {
      _internal_mutable_follow()->::autoagric::planning::ObjectFollow::MergeFrom(from._internal_follow());
      break;
    }
    case kYield: {
      _internal_mutable_yield()->::autoagric::planning::ObjectYield::MergeFrom(from._internal_yield());
      break;
    }
    case kOvertake: {
      _internal_mutable_overtake()->::autoagric::planning::ObjectOvertake::MergeFrom(from._internal_overtake());
      break;
    }
    case kNudge: {
      _internal_mutable_nudge()->::autoagric::planning::ObjectNudge::MergeFrom(from._internal_nudge());
      break;
    }
    case kAvoid: {
      _internal_mutable_avoid()->::autoagric::planning::ObjectAvoid::MergeFrom(from._internal_avoid());
      break;
    }
    case kSidePass: {
      _internal_mutable_side_pass()->::autoagric::planning::ObjectSidePass::MergeFrom(from._internal_side_pass());
      break;
    }
    case OBJECT_TAG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectDecisionType)
}

inline void ObjectDecisionType::SharedCtor() {
clear_has_object_tag();
}

ObjectDecisionType::~ObjectDecisionType() {
  // @@protoc_insertion_point(destructor:autoagric.planning.ObjectDecisionType)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObjectDecisionType::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_object_tag()) {
    clear_object_tag();
  }
}

void ObjectDecisionType::ArenaDtor(void* object) {
  ObjectDecisionType* _this = reinterpret_cast< ObjectDecisionType* >(object);
  (void)_this;
}
void ObjectDecisionType::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObjectDecisionType::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObjectDecisionType::clear_object_tag() {
// @@protoc_insertion_point(one_of_clear_start:autoagric.planning.ObjectDecisionType)
  switch (object_tag_case()) {
    case kIgnore: {
      if (GetArenaForAllocation() == nullptr) {
        delete object_tag_.ignore_;
      }
      break;
    }
    case kStop: {
      if (GetArenaForAllocation() == nullptr) {
        delete object_tag_.stop_;
      }
      break;
    }
    case kFollow: {
      if (GetArenaForAllocation() == nullptr) {
        delete object_tag_.follow_;
      }
      break;
    }
    case kYield: {
      if (GetArenaForAllocation() == nullptr) {
        delete object_tag_.yield_;
      }
      break;
    }
    case kOvertake: {
      if (GetArenaForAllocation() == nullptr) {
        delete object_tag_.overtake_;
      }
      break;
    }
    case kNudge: {
      if (GetArenaForAllocation() == nullptr) {
        delete object_tag_.nudge_;
      }
      break;
    }
    case kAvoid: {
      if (GetArenaForAllocation() == nullptr) {
        delete object_tag_.avoid_;
      }
      break;
    }
    case kSidePass: {
      if (GetArenaForAllocation() == nullptr) {
        delete object_tag_.side_pass_;
      }
      break;
    }
    case OBJECT_TAG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = OBJECT_TAG_NOT_SET;
}


void ObjectDecisionType::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.ObjectDecisionType)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_object_tag();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectDecisionType::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autoagric.planning.ObjectIgnore ignore = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ignore(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.planning.ObjectStop stop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.planning.ObjectFollow follow = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_follow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.planning.ObjectYield yield = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_yield(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.planning.ObjectOvertake overtake = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_overtake(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.planning.ObjectNudge nudge = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_nudge(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.planning.ObjectAvoid avoid = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_avoid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.planning.ObjectSidePass side_pass = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_side_pass(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectDecisionType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.ObjectDecisionType)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .autoagric.planning.ObjectIgnore ignore = 1;
  if (_internal_has_ignore()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::ignore(this), target, stream);
  }

  // .autoagric.planning.ObjectStop stop = 2;
  if (_internal_has_stop()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::stop(this), target, stream);
  }

  // .autoagric.planning.ObjectFollow follow = 3;
  if (_internal_has_follow()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::follow(this), target, stream);
  }

  // .autoagric.planning.ObjectYield yield = 4;
  if (_internal_has_yield()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::yield(this), target, stream);
  }

  // .autoagric.planning.ObjectOvertake overtake = 5;
  if (_internal_has_overtake()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::overtake(this), target, stream);
  }

  // .autoagric.planning.ObjectNudge nudge = 6;
  if (_internal_has_nudge()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::nudge(this), target, stream);
  }

  // .autoagric.planning.ObjectAvoid avoid = 7;
  if (_internal_has_avoid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::avoid(this), target, stream);
  }

  // .autoagric.planning.ObjectSidePass side_pass = 8;
  if (_internal_has_side_pass()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::side_pass(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.ObjectDecisionType)
  return target;
}

size_t ObjectDecisionType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.ObjectDecisionType)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (object_tag_case()) {
    // .autoagric.planning.ObjectIgnore ignore = 1;
    case kIgnore: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_tag_.ignore_);
      break;
    }
    // .autoagric.planning.ObjectStop stop = 2;
    case kStop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_tag_.stop_);
      break;
    }
    // .autoagric.planning.ObjectFollow follow = 3;
    case kFollow: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_tag_.follow_);
      break;
    }
    // .autoagric.planning.ObjectYield yield = 4;
    case kYield: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_tag_.yield_);
      break;
    }
    // .autoagric.planning.ObjectOvertake overtake = 5;
    case kOvertake: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_tag_.overtake_);
      break;
    }
    // .autoagric.planning.ObjectNudge nudge = 6;
    case kNudge: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_tag_.nudge_);
      break;
    }
    // .autoagric.planning.ObjectAvoid avoid = 7;
    case kAvoid: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_tag_.avoid_);
      break;
    }
    // .autoagric.planning.ObjectSidePass side_pass = 8;
    case kSidePass: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *object_tag_.side_pass_);
      break;
    }
    case OBJECT_TAG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectDecisionType::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectDecisionType::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectDecisionType::GetClassData() const { return &_class_data_; }

void ObjectDecisionType::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectDecisionType *>(to)->MergeFrom(
      static_cast<const ObjectDecisionType &>(from));
}


void ObjectDecisionType::MergeFrom(const ObjectDecisionType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.ObjectDecisionType)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.object_tag_case()) {
    case kIgnore: {
      _internal_mutable_ignore()->::autoagric::planning::ObjectIgnore::MergeFrom(from._internal_ignore());
      break;
    }
    case kStop: {
      _internal_mutable_stop()->::autoagric::planning::ObjectStop::MergeFrom(from._internal_stop());
      break;
    }
    case kFollow: {
      _internal_mutable_follow()->::autoagric::planning::ObjectFollow::MergeFrom(from._internal_follow());
      break;
    }
    case kYield: {
      _internal_mutable_yield()->::autoagric::planning::ObjectYield::MergeFrom(from._internal_yield());
      break;
    }
    case kOvertake: {
      _internal_mutable_overtake()->::autoagric::planning::ObjectOvertake::MergeFrom(from._internal_overtake());
      break;
    }
    case kNudge: {
      _internal_mutable_nudge()->::autoagric::planning::ObjectNudge::MergeFrom(from._internal_nudge());
      break;
    }
    case kAvoid: {
      _internal_mutable_avoid()->::autoagric::planning::ObjectAvoid::MergeFrom(from._internal_avoid());
      break;
    }
    case kSidePass: {
      _internal_mutable_side_pass()->::autoagric::planning::ObjectSidePass::MergeFrom(from._internal_side_pass());
      break;
    }
    case OBJECT_TAG_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectDecisionType::CopyFrom(const ObjectDecisionType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.ObjectDecisionType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectDecisionType::IsInitialized() const {
  return true;
}

void ObjectDecisionType::InternalSwap(ObjectDecisionType* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(object_tag_, other->object_tag_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectDecisionType::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[13]);
}

// ===================================================================

class ObjectDecision::_Internal {
 public:
};

ObjectDecision::ObjectDecision(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  object_decision_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectDecision)
}
ObjectDecision::ObjectDecision(const ObjectDecision& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      object_decision_(from.object_decision_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArenaForAllocation());
  }
  perception_id_ = from.perception_id_;
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectDecision)
}

inline void ObjectDecision::SharedCtor() {
id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
perception_id_ = 0;
}

ObjectDecision::~ObjectDecision() {
  // @@protoc_insertion_point(destructor:autoagric.planning.ObjectDecision)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObjectDecision::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ObjectDecision::ArenaDtor(void* object) {
  ObjectDecision* _this = reinterpret_cast< ObjectDecision* >(object);
  (void)_this;
}
void ObjectDecision::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObjectDecision::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObjectDecision::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.ObjectDecision)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  object_decision_.Clear();
  id_.ClearToEmpty();
  perception_id_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectDecision::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "autoagric.planning.ObjectDecision.id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 perception_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          perception_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autoagric.planning.ObjectDecisionType object_decision = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_object_decision(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectDecision::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.ObjectDecision)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "autoagric.planning.ObjectDecision.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // int32 perception_id = 2;
  if (this->_internal_perception_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_perception_id(), target);
  }

  // repeated .autoagric.planning.ObjectDecisionType object_decision = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_object_decision_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_object_decision(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.ObjectDecision)
  return target;
}

size_t ObjectDecision::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.ObjectDecision)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autoagric.planning.ObjectDecisionType object_decision = 3;
  total_size += 1UL * this->_internal_object_decision_size();
  for (const auto& msg : this->object_decision_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // int32 perception_id = 2;
  if (this->_internal_perception_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_perception_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectDecision::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectDecision::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectDecision::GetClassData() const { return &_class_data_; }

void ObjectDecision::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectDecision *>(to)->MergeFrom(
      static_cast<const ObjectDecision &>(from));
}


void ObjectDecision::MergeFrom(const ObjectDecision& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.ObjectDecision)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  object_decision_.MergeFrom(from.object_decision_);
  if (!from._internal_id().empty()) {
    _internal_set_id(from._internal_id());
  }
  if (from._internal_perception_id() != 0) {
    _internal_set_perception_id(from._internal_perception_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectDecision::CopyFrom(const ObjectDecision& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.ObjectDecision)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectDecision::IsInitialized() const {
  return true;
}

void ObjectDecision::InternalSwap(ObjectDecision* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  object_decision_.InternalSwap(&other->object_decision_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  swap(perception_id_, other->perception_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectDecision::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[14]);
}

// ===================================================================

class ObjectDecisions::_Internal {
 public:
};

ObjectDecisions::ObjectDecisions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  decision_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.ObjectDecisions)
}
ObjectDecisions::ObjectDecisions(const ObjectDecisions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      decision_(from.decision_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.ObjectDecisions)
}

inline void ObjectDecisions::SharedCtor() {
}

ObjectDecisions::~ObjectDecisions() {
  // @@protoc_insertion_point(destructor:autoagric.planning.ObjectDecisions)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObjectDecisions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ObjectDecisions::ArenaDtor(void* object) {
  ObjectDecisions* _this = reinterpret_cast< ObjectDecisions* >(object);
  (void)_this;
}
void ObjectDecisions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObjectDecisions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObjectDecisions::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.ObjectDecisions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  decision_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectDecisions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autoagric.planning.ObjectDecision decision = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_decision(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectDecisions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.ObjectDecisions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autoagric.planning.ObjectDecision decision = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_decision_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_decision(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.ObjectDecisions)
  return target;
}

size_t ObjectDecisions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.ObjectDecisions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autoagric.planning.ObjectDecision decision = 1;
  total_size += 1UL * this->_internal_decision_size();
  for (const auto& msg : this->decision_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectDecisions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObjectDecisions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectDecisions::GetClassData() const { return &_class_data_; }

void ObjectDecisions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObjectDecisions *>(to)->MergeFrom(
      static_cast<const ObjectDecisions &>(from));
}


void ObjectDecisions::MergeFrom(const ObjectDecisions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.ObjectDecisions)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  decision_.MergeFrom(from.decision_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectDecisions::CopyFrom(const ObjectDecisions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.ObjectDecisions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectDecisions::IsInitialized() const {
  return true;
}

void ObjectDecisions::InternalSwap(ObjectDecisions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  decision_.InternalSwap(&other->decision_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectDecisions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_getter, &descriptor_table_autoagric_2fplanning_2fdecision_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2fdecision_2eproto[15]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace planning
}  // namespace autoagric
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::autoagric::planning::TargetLane* Arena::CreateMaybeMessage< ::autoagric::planning::TargetLane >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::TargetLane >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectIgnore* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectIgnore >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectIgnore >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectStop* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectStop >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectStop >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectNudge* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectNudge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectNudge >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectYield* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectYield >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectYield >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectFollow* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectFollow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectFollow >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectOvertake* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectOvertake >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectOvertake >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectSidePass* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectSidePass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectSidePass >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectAvoid* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectAvoid >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectAvoid >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectStatus* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectStatic* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectStatic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectStatic >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectDynamic* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectDynamic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectDynamic >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectMotionType* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectMotionType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectMotionType >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectDecisionType* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectDecisionType >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectDecisionType >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectDecision* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectDecision >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectDecision >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::ObjectDecisions* Arena::CreateMaybeMessage< ::autoagric::planning::ObjectDecisions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::ObjectDecisions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
