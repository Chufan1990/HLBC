// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: autoagric/planning/task_config.proto

#include "autoagric/planning/task_config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace autoagric {
namespace planning {
constexpr DpStSpeedOptimizerConfig::DpStSpeedOptimizerConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : unit_t_(0)
  , dense_unit_s_(0)
  , sparse_unit_s_(0)
  , speed_weight_(0)
  , accel_weight_(0)
  , jerk_weight_(0)
  , obstacle_weight_(0)
  , reference_weight_(0)
  , go_down_buffer_(0)
  , go_up_buffer_(0)
  , default_obstacle_cost_(0)
  , default_speed_cost_(0)
  , exceed_speed_penalty_(0)
  , low_speed_penalty_(0)
  , reference_speed_penalty_(0)
  , keep_clear_low_speed_penalty_(0)
  , accel_penalty_(0)
  , decel_penalty_(0)
  , dense_dimension_s_(0)
  , is_lane_changing_(false)
  , positive_jerk_coeff_(0)
  , negative_jerk_coeff_(0)
  , max_acceleration_(0)
  , max_deceleration_(0)
  , safe_time_buffer_(0)
  , safe_distance_(0)
  , spatial_potential_penalty_(0){}
struct DpStSpeedOptimizerConfigDefaultTypeInternal {
  constexpr DpStSpeedOptimizerConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DpStSpeedOptimizerConfigDefaultTypeInternal() {}
  union {
    DpStSpeedOptimizerConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DpStSpeedOptimizerConfigDefaultTypeInternal _DpStSpeedOptimizerConfig_default_instance_;
constexpr PiecewiseJerkSpeedOptimizerConfig::PiecewiseJerkSpeedOptimizerConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : acc_weight_(0)
  , jerk_weight_(0)
  , kappa_penalty_weight_(0)
  , ref_s_weight_(0)
  , ref_v_weight_(0){}
struct PiecewiseJerkSpeedOptimizerConfigDefaultTypeInternal {
  constexpr PiecewiseJerkSpeedOptimizerConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PiecewiseJerkSpeedOptimizerConfigDefaultTypeInternal() {}
  union {
    PiecewiseJerkSpeedOptimizerConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PiecewiseJerkSpeedOptimizerConfigDefaultTypeInternal _PiecewiseJerkSpeedOptimizerConfig_default_instance_;
}  // namespace planning
}  // namespace autoagric
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_autoagric_2fplanning_2ftask_5fconfig_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_autoagric_2fplanning_2ftask_5fconfig_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_autoagric_2fplanning_2ftask_5fconfig_2eproto = nullptr;

const uint32_t TableStruct_autoagric_2fplanning_2ftask_5fconfig_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, unit_t_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, dense_dimension_s_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, dense_unit_s_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, sparse_unit_s_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, speed_weight_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, accel_weight_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, jerk_weight_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, obstacle_weight_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, reference_weight_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, go_down_buffer_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, go_up_buffer_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, default_obstacle_cost_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, default_speed_cost_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, exceed_speed_penalty_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, low_speed_penalty_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, reference_speed_penalty_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, keep_clear_low_speed_penalty_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, accel_penalty_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, decel_penalty_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, positive_jerk_coeff_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, negative_jerk_coeff_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, max_acceleration_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, max_deceleration_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, safe_time_buffer_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, safe_distance_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, spatial_potential_penalty_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::DpStSpeedOptimizerConfig, is_lane_changing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::PiecewiseJerkSpeedOptimizerConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::PiecewiseJerkSpeedOptimizerConfig, acc_weight_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::PiecewiseJerkSpeedOptimizerConfig, jerk_weight_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::PiecewiseJerkSpeedOptimizerConfig, kappa_penalty_weight_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::PiecewiseJerkSpeedOptimizerConfig, ref_s_weight_),
  PROTOBUF_FIELD_OFFSET(::autoagric::planning::PiecewiseJerkSpeedOptimizerConfig, ref_v_weight_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::autoagric::planning::DpStSpeedOptimizerConfig)},
  { 33, -1, -1, sizeof(::autoagric::planning::PiecewiseJerkSpeedOptimizerConfig)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_DpStSpeedOptimizerConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::planning::_PiecewiseJerkSpeedOptimizerConfig_default_instance_),
};

const char descriptor_table_protodef_autoagric_2fplanning_2ftask_5fconfig_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n$autoagric/planning/task_config.proto\022\022"
  "autoagric.planning\"\331\005\n\030DpStSpeedOptimize"
  "rConfig\022\016\n\006unit_t\030\001 \001(\001\022\031\n\021dense_dimensi"
  "on_s\030\002 \001(\005\022\024\n\014dense_unit_s\030\003 \001(\001\022\025\n\rspar"
  "se_unit_s\030\004 \001(\001\022\024\n\014speed_weight\030\n \001(\001\022\024\n"
  "\014accel_weight\030\013 \001(\001\022\023\n\013jerk_weight\030\014 \001(\001"
  "\022\027\n\017obstacle_weight\030\r \001(\001\022\030\n\020reference_w"
  "eight\030\016 \001(\001\022\026\n\016go_down_buffer\030\017 \001(\001\022\024\n\014g"
  "o_up_buffer\030\020 \001(\001\022\035\n\025default_obstacle_co"
  "st\030\024 \001(\001\022\032\n\022default_speed_cost\030\037 \001(\001\022\034\n\024"
  "exceed_speed_penalty\030  \001(\001\022\031\n\021low_speed_"
  "penalty\030! \001(\001\022\037\n\027reference_speed_penalty"
  "\030\" \001(\001\022$\n\034keep_clear_low_speed_penalty\030#"
  " \001(\001\022\025\n\raccel_penalty\030( \001(\001\022\025\n\rdecel_pen"
  "alty\030) \001(\001\022\033\n\023positive_jerk_coeff\0302 \001(\001\022"
  "\033\n\023negative_jerk_coeff\0303 \001(\001\022\030\n\020max_acce"
  "leration\030< \001(\001\022\030\n\020max_deceleration\030= \001(\001"
  "\022\030\n\020safe_time_buffer\030F \001(\001\022\025\n\rsafe_dista"
  "nce\030G \001(\001\022!\n\031spatial_potential_penalty\030P"
  " \001(\001\022\030\n\020is_lane_changing\030Q \001(\010\"\226\001\n!Piece"
  "wiseJerkSpeedOptimizerConfig\022\022\n\nacc_weig"
  "ht\030\001 \001(\001\022\023\n\013jerk_weight\030\002 \001(\001\022\034\n\024kappa_p"
  "enalty_weight\030\003 \001(\001\022\024\n\014ref_s_weight\030\004 \001("
  "\001\022\024\n\014ref_v_weight\030\005 \001(\001b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_autoagric_2fplanning_2ftask_5fconfig_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_autoagric_2fplanning_2ftask_5fconfig_2eproto = {
  false, false, 951, descriptor_table_protodef_autoagric_2fplanning_2ftask_5fconfig_2eproto, "autoagric/planning/task_config.proto", 
  &descriptor_table_autoagric_2fplanning_2ftask_5fconfig_2eproto_once, nullptr, 0, 2,
  schemas, file_default_instances, TableStruct_autoagric_2fplanning_2ftask_5fconfig_2eproto::offsets,
  file_level_metadata_autoagric_2fplanning_2ftask_5fconfig_2eproto, file_level_enum_descriptors_autoagric_2fplanning_2ftask_5fconfig_2eproto, file_level_service_descriptors_autoagric_2fplanning_2ftask_5fconfig_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_autoagric_2fplanning_2ftask_5fconfig_2eproto_getter() {
  return &descriptor_table_autoagric_2fplanning_2ftask_5fconfig_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_autoagric_2fplanning_2ftask_5fconfig_2eproto(&descriptor_table_autoagric_2fplanning_2ftask_5fconfig_2eproto);
namespace autoagric {
namespace planning {

// ===================================================================

class DpStSpeedOptimizerConfig::_Internal {
 public:
};

DpStSpeedOptimizerConfig::DpStSpeedOptimizerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.DpStSpeedOptimizerConfig)
}
DpStSpeedOptimizerConfig::DpStSpeedOptimizerConfig(const DpStSpeedOptimizerConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&unit_t_, &from.unit_t_,
    static_cast<size_t>(reinterpret_cast<char*>(&spatial_potential_penalty_) -
    reinterpret_cast<char*>(&unit_t_)) + sizeof(spatial_potential_penalty_));
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.DpStSpeedOptimizerConfig)
}

inline void DpStSpeedOptimizerConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&unit_t_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&spatial_potential_penalty_) -
    reinterpret_cast<char*>(&unit_t_)) + sizeof(spatial_potential_penalty_));
}

DpStSpeedOptimizerConfig::~DpStSpeedOptimizerConfig() {
  // @@protoc_insertion_point(destructor:autoagric.planning.DpStSpeedOptimizerConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DpStSpeedOptimizerConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DpStSpeedOptimizerConfig::ArenaDtor(void* object) {
  DpStSpeedOptimizerConfig* _this = reinterpret_cast< DpStSpeedOptimizerConfig* >(object);
  (void)_this;
}
void DpStSpeedOptimizerConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DpStSpeedOptimizerConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DpStSpeedOptimizerConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.DpStSpeedOptimizerConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&unit_t_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&spatial_potential_penalty_) -
      reinterpret_cast<char*>(&unit_t_)) + sizeof(spatial_potential_penalty_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DpStSpeedOptimizerConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double unit_t = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          unit_t_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 dense_dimension_s = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          dense_dimension_s_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double dense_unit_s = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          dense_unit_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double sparse_unit_s = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          sparse_unit_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double speed_weight = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          speed_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double accel_weight = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          accel_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double jerk_weight = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          jerk_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double obstacle_weight = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          obstacle_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double reference_weight = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          reference_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double go_down_buffer = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 121)) {
          go_down_buffer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double go_up_buffer = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          go_up_buffer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double default_obstacle_cost = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          default_obstacle_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double default_speed_cost = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 249)) {
          default_speed_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double exceed_speed_penalty = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 1)) {
          exceed_speed_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double low_speed_penalty = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          low_speed_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double reference_speed_penalty = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          reference_speed_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double keep_clear_low_speed_penalty = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          keep_clear_low_speed_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double accel_penalty = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          accel_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double decel_penalty = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          decel_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double positive_jerk_coeff = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 145)) {
          positive_jerk_coeff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double negative_jerk_coeff = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          negative_jerk_coeff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double max_acceleration = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 225)) {
          max_acceleration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double max_deceleration = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 233)) {
          max_deceleration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double safe_time_buffer = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          safe_time_buffer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double safe_distance = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          safe_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double spatial_potential_penalty = 80;
      case 80:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          spatial_potential_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool is_lane_changing = 81;
      case 81:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          is_lane_changing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DpStSpeedOptimizerConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.DpStSpeedOptimizerConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double unit_t = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_unit_t = this->_internal_unit_t();
  uint64_t raw_unit_t;
  memcpy(&raw_unit_t, &tmp_unit_t, sizeof(tmp_unit_t));
  if (raw_unit_t != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_unit_t(), target);
  }

  // int32 dense_dimension_s = 2;
  if (this->_internal_dense_dimension_s() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_dense_dimension_s(), target);
  }

  // double dense_unit_s = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dense_unit_s = this->_internal_dense_unit_s();
  uint64_t raw_dense_unit_s;
  memcpy(&raw_dense_unit_s, &tmp_dense_unit_s, sizeof(tmp_dense_unit_s));
  if (raw_dense_unit_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_dense_unit_s(), target);
  }

  // double sparse_unit_s = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sparse_unit_s = this->_internal_sparse_unit_s();
  uint64_t raw_sparse_unit_s;
  memcpy(&raw_sparse_unit_s, &tmp_sparse_unit_s, sizeof(tmp_sparse_unit_s));
  if (raw_sparse_unit_s != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_sparse_unit_s(), target);
  }

  // double speed_weight = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed_weight = this->_internal_speed_weight();
  uint64_t raw_speed_weight;
  memcpy(&raw_speed_weight, &tmp_speed_weight, sizeof(tmp_speed_weight));
  if (raw_speed_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(10, this->_internal_speed_weight(), target);
  }

  // double accel_weight = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_accel_weight = this->_internal_accel_weight();
  uint64_t raw_accel_weight;
  memcpy(&raw_accel_weight, &tmp_accel_weight, sizeof(tmp_accel_weight));
  if (raw_accel_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(11, this->_internal_accel_weight(), target);
  }

  // double jerk_weight = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_jerk_weight = this->_internal_jerk_weight();
  uint64_t raw_jerk_weight;
  memcpy(&raw_jerk_weight, &tmp_jerk_weight, sizeof(tmp_jerk_weight));
  if (raw_jerk_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(12, this->_internal_jerk_weight(), target);
  }

  // double obstacle_weight = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_obstacle_weight = this->_internal_obstacle_weight();
  uint64_t raw_obstacle_weight;
  memcpy(&raw_obstacle_weight, &tmp_obstacle_weight, sizeof(tmp_obstacle_weight));
  if (raw_obstacle_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(13, this->_internal_obstacle_weight(), target);
  }

  // double reference_weight = 14;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reference_weight = this->_internal_reference_weight();
  uint64_t raw_reference_weight;
  memcpy(&raw_reference_weight, &tmp_reference_weight, sizeof(tmp_reference_weight));
  if (raw_reference_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(14, this->_internal_reference_weight(), target);
  }

  // double go_down_buffer = 15;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_go_down_buffer = this->_internal_go_down_buffer();
  uint64_t raw_go_down_buffer;
  memcpy(&raw_go_down_buffer, &tmp_go_down_buffer, sizeof(tmp_go_down_buffer));
  if (raw_go_down_buffer != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(15, this->_internal_go_down_buffer(), target);
  }

  // double go_up_buffer = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_go_up_buffer = this->_internal_go_up_buffer();
  uint64_t raw_go_up_buffer;
  memcpy(&raw_go_up_buffer, &tmp_go_up_buffer, sizeof(tmp_go_up_buffer));
  if (raw_go_up_buffer != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(16, this->_internal_go_up_buffer(), target);
  }

  // double default_obstacle_cost = 20;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_default_obstacle_cost = this->_internal_default_obstacle_cost();
  uint64_t raw_default_obstacle_cost;
  memcpy(&raw_default_obstacle_cost, &tmp_default_obstacle_cost, sizeof(tmp_default_obstacle_cost));
  if (raw_default_obstacle_cost != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(20, this->_internal_default_obstacle_cost(), target);
  }

  // double default_speed_cost = 31;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_default_speed_cost = this->_internal_default_speed_cost();
  uint64_t raw_default_speed_cost;
  memcpy(&raw_default_speed_cost, &tmp_default_speed_cost, sizeof(tmp_default_speed_cost));
  if (raw_default_speed_cost != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(31, this->_internal_default_speed_cost(), target);
  }

  // double exceed_speed_penalty = 32;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exceed_speed_penalty = this->_internal_exceed_speed_penalty();
  uint64_t raw_exceed_speed_penalty;
  memcpy(&raw_exceed_speed_penalty, &tmp_exceed_speed_penalty, sizeof(tmp_exceed_speed_penalty));
  if (raw_exceed_speed_penalty != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(32, this->_internal_exceed_speed_penalty(), target);
  }

  // double low_speed_penalty = 33;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_low_speed_penalty = this->_internal_low_speed_penalty();
  uint64_t raw_low_speed_penalty;
  memcpy(&raw_low_speed_penalty, &tmp_low_speed_penalty, sizeof(tmp_low_speed_penalty));
  if (raw_low_speed_penalty != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(33, this->_internal_low_speed_penalty(), target);
  }

  // double reference_speed_penalty = 34;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reference_speed_penalty = this->_internal_reference_speed_penalty();
  uint64_t raw_reference_speed_penalty;
  memcpy(&raw_reference_speed_penalty, &tmp_reference_speed_penalty, sizeof(tmp_reference_speed_penalty));
  if (raw_reference_speed_penalty != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(34, this->_internal_reference_speed_penalty(), target);
  }

  // double keep_clear_low_speed_penalty = 35;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_keep_clear_low_speed_penalty = this->_internal_keep_clear_low_speed_penalty();
  uint64_t raw_keep_clear_low_speed_penalty;
  memcpy(&raw_keep_clear_low_speed_penalty, &tmp_keep_clear_low_speed_penalty, sizeof(tmp_keep_clear_low_speed_penalty));
  if (raw_keep_clear_low_speed_penalty != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(35, this->_internal_keep_clear_low_speed_penalty(), target);
  }

  // double accel_penalty = 40;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_accel_penalty = this->_internal_accel_penalty();
  uint64_t raw_accel_penalty;
  memcpy(&raw_accel_penalty, &tmp_accel_penalty, sizeof(tmp_accel_penalty));
  if (raw_accel_penalty != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(40, this->_internal_accel_penalty(), target);
  }

  // double decel_penalty = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_decel_penalty = this->_internal_decel_penalty();
  uint64_t raw_decel_penalty;
  memcpy(&raw_decel_penalty, &tmp_decel_penalty, sizeof(tmp_decel_penalty));
  if (raw_decel_penalty != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(41, this->_internal_decel_penalty(), target);
  }

  // double positive_jerk_coeff = 50;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_positive_jerk_coeff = this->_internal_positive_jerk_coeff();
  uint64_t raw_positive_jerk_coeff;
  memcpy(&raw_positive_jerk_coeff, &tmp_positive_jerk_coeff, sizeof(tmp_positive_jerk_coeff));
  if (raw_positive_jerk_coeff != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(50, this->_internal_positive_jerk_coeff(), target);
  }

  // double negative_jerk_coeff = 51;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_negative_jerk_coeff = this->_internal_negative_jerk_coeff();
  uint64_t raw_negative_jerk_coeff;
  memcpy(&raw_negative_jerk_coeff, &tmp_negative_jerk_coeff, sizeof(tmp_negative_jerk_coeff));
  if (raw_negative_jerk_coeff != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(51, this->_internal_negative_jerk_coeff(), target);
  }

  // double max_acceleration = 60;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_acceleration = this->_internal_max_acceleration();
  uint64_t raw_max_acceleration;
  memcpy(&raw_max_acceleration, &tmp_max_acceleration, sizeof(tmp_max_acceleration));
  if (raw_max_acceleration != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(60, this->_internal_max_acceleration(), target);
  }

  // double max_deceleration = 61;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_deceleration = this->_internal_max_deceleration();
  uint64_t raw_max_deceleration;
  memcpy(&raw_max_deceleration, &tmp_max_deceleration, sizeof(tmp_max_deceleration));
  if (raw_max_deceleration != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(61, this->_internal_max_deceleration(), target);
  }

  // double safe_time_buffer = 70;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_safe_time_buffer = this->_internal_safe_time_buffer();
  uint64_t raw_safe_time_buffer;
  memcpy(&raw_safe_time_buffer, &tmp_safe_time_buffer, sizeof(tmp_safe_time_buffer));
  if (raw_safe_time_buffer != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(70, this->_internal_safe_time_buffer(), target);
  }

  // double safe_distance = 71;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_safe_distance = this->_internal_safe_distance();
  uint64_t raw_safe_distance;
  memcpy(&raw_safe_distance, &tmp_safe_distance, sizeof(tmp_safe_distance));
  if (raw_safe_distance != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(71, this->_internal_safe_distance(), target);
  }

  // double spatial_potential_penalty = 80;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spatial_potential_penalty = this->_internal_spatial_potential_penalty();
  uint64_t raw_spatial_potential_penalty;
  memcpy(&raw_spatial_potential_penalty, &tmp_spatial_potential_penalty, sizeof(tmp_spatial_potential_penalty));
  if (raw_spatial_potential_penalty != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(80, this->_internal_spatial_potential_penalty(), target);
  }

  // bool is_lane_changing = 81;
  if (this->_internal_is_lane_changing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(81, this->_internal_is_lane_changing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.DpStSpeedOptimizerConfig)
  return target;
}

size_t DpStSpeedOptimizerConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.DpStSpeedOptimizerConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double unit_t = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_unit_t = this->_internal_unit_t();
  uint64_t raw_unit_t;
  memcpy(&raw_unit_t, &tmp_unit_t, sizeof(tmp_unit_t));
  if (raw_unit_t != 0) {
    total_size += 1 + 8;
  }

  // double dense_unit_s = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dense_unit_s = this->_internal_dense_unit_s();
  uint64_t raw_dense_unit_s;
  memcpy(&raw_dense_unit_s, &tmp_dense_unit_s, sizeof(tmp_dense_unit_s));
  if (raw_dense_unit_s != 0) {
    total_size += 1 + 8;
  }

  // double sparse_unit_s = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sparse_unit_s = this->_internal_sparse_unit_s();
  uint64_t raw_sparse_unit_s;
  memcpy(&raw_sparse_unit_s, &tmp_sparse_unit_s, sizeof(tmp_sparse_unit_s));
  if (raw_sparse_unit_s != 0) {
    total_size += 1 + 8;
  }

  // double speed_weight = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed_weight = this->_internal_speed_weight();
  uint64_t raw_speed_weight;
  memcpy(&raw_speed_weight, &tmp_speed_weight, sizeof(tmp_speed_weight));
  if (raw_speed_weight != 0) {
    total_size += 1 + 8;
  }

  // double accel_weight = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_accel_weight = this->_internal_accel_weight();
  uint64_t raw_accel_weight;
  memcpy(&raw_accel_weight, &tmp_accel_weight, sizeof(tmp_accel_weight));
  if (raw_accel_weight != 0) {
    total_size += 1 + 8;
  }

  // double jerk_weight = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_jerk_weight = this->_internal_jerk_weight();
  uint64_t raw_jerk_weight;
  memcpy(&raw_jerk_weight, &tmp_jerk_weight, sizeof(tmp_jerk_weight));
  if (raw_jerk_weight != 0) {
    total_size += 1 + 8;
  }

  // double obstacle_weight = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_obstacle_weight = this->_internal_obstacle_weight();
  uint64_t raw_obstacle_weight;
  memcpy(&raw_obstacle_weight, &tmp_obstacle_weight, sizeof(tmp_obstacle_weight));
  if (raw_obstacle_weight != 0) {
    total_size += 1 + 8;
  }

  // double reference_weight = 14;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reference_weight = this->_internal_reference_weight();
  uint64_t raw_reference_weight;
  memcpy(&raw_reference_weight, &tmp_reference_weight, sizeof(tmp_reference_weight));
  if (raw_reference_weight != 0) {
    total_size += 1 + 8;
  }

  // double go_down_buffer = 15;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_go_down_buffer = this->_internal_go_down_buffer();
  uint64_t raw_go_down_buffer;
  memcpy(&raw_go_down_buffer, &tmp_go_down_buffer, sizeof(tmp_go_down_buffer));
  if (raw_go_down_buffer != 0) {
    total_size += 1 + 8;
  }

  // double go_up_buffer = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_go_up_buffer = this->_internal_go_up_buffer();
  uint64_t raw_go_up_buffer;
  memcpy(&raw_go_up_buffer, &tmp_go_up_buffer, sizeof(tmp_go_up_buffer));
  if (raw_go_up_buffer != 0) {
    total_size += 2 + 8;
  }

  // double default_obstacle_cost = 20;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_default_obstacle_cost = this->_internal_default_obstacle_cost();
  uint64_t raw_default_obstacle_cost;
  memcpy(&raw_default_obstacle_cost, &tmp_default_obstacle_cost, sizeof(tmp_default_obstacle_cost));
  if (raw_default_obstacle_cost != 0) {
    total_size += 2 + 8;
  }

  // double default_speed_cost = 31;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_default_speed_cost = this->_internal_default_speed_cost();
  uint64_t raw_default_speed_cost;
  memcpy(&raw_default_speed_cost, &tmp_default_speed_cost, sizeof(tmp_default_speed_cost));
  if (raw_default_speed_cost != 0) {
    total_size += 2 + 8;
  }

  // double exceed_speed_penalty = 32;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exceed_speed_penalty = this->_internal_exceed_speed_penalty();
  uint64_t raw_exceed_speed_penalty;
  memcpy(&raw_exceed_speed_penalty, &tmp_exceed_speed_penalty, sizeof(tmp_exceed_speed_penalty));
  if (raw_exceed_speed_penalty != 0) {
    total_size += 2 + 8;
  }

  // double low_speed_penalty = 33;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_low_speed_penalty = this->_internal_low_speed_penalty();
  uint64_t raw_low_speed_penalty;
  memcpy(&raw_low_speed_penalty, &tmp_low_speed_penalty, sizeof(tmp_low_speed_penalty));
  if (raw_low_speed_penalty != 0) {
    total_size += 2 + 8;
  }

  // double reference_speed_penalty = 34;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reference_speed_penalty = this->_internal_reference_speed_penalty();
  uint64_t raw_reference_speed_penalty;
  memcpy(&raw_reference_speed_penalty, &tmp_reference_speed_penalty, sizeof(tmp_reference_speed_penalty));
  if (raw_reference_speed_penalty != 0) {
    total_size += 2 + 8;
  }

  // double keep_clear_low_speed_penalty = 35;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_keep_clear_low_speed_penalty = this->_internal_keep_clear_low_speed_penalty();
  uint64_t raw_keep_clear_low_speed_penalty;
  memcpy(&raw_keep_clear_low_speed_penalty, &tmp_keep_clear_low_speed_penalty, sizeof(tmp_keep_clear_low_speed_penalty));
  if (raw_keep_clear_low_speed_penalty != 0) {
    total_size += 2 + 8;
  }

  // double accel_penalty = 40;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_accel_penalty = this->_internal_accel_penalty();
  uint64_t raw_accel_penalty;
  memcpy(&raw_accel_penalty, &tmp_accel_penalty, sizeof(tmp_accel_penalty));
  if (raw_accel_penalty != 0) {
    total_size += 2 + 8;
  }

  // double decel_penalty = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_decel_penalty = this->_internal_decel_penalty();
  uint64_t raw_decel_penalty;
  memcpy(&raw_decel_penalty, &tmp_decel_penalty, sizeof(tmp_decel_penalty));
  if (raw_decel_penalty != 0) {
    total_size += 2 + 8;
  }

  // int32 dense_dimension_s = 2;
  if (this->_internal_dense_dimension_s() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_dense_dimension_s());
  }

  // bool is_lane_changing = 81;
  if (this->_internal_is_lane_changing() != 0) {
    total_size += 2 + 1;
  }

  // double positive_jerk_coeff = 50;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_positive_jerk_coeff = this->_internal_positive_jerk_coeff();
  uint64_t raw_positive_jerk_coeff;
  memcpy(&raw_positive_jerk_coeff, &tmp_positive_jerk_coeff, sizeof(tmp_positive_jerk_coeff));
  if (raw_positive_jerk_coeff != 0) {
    total_size += 2 + 8;
  }

  // double negative_jerk_coeff = 51;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_negative_jerk_coeff = this->_internal_negative_jerk_coeff();
  uint64_t raw_negative_jerk_coeff;
  memcpy(&raw_negative_jerk_coeff, &tmp_negative_jerk_coeff, sizeof(tmp_negative_jerk_coeff));
  if (raw_negative_jerk_coeff != 0) {
    total_size += 2 + 8;
  }

  // double max_acceleration = 60;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_acceleration = this->_internal_max_acceleration();
  uint64_t raw_max_acceleration;
  memcpy(&raw_max_acceleration, &tmp_max_acceleration, sizeof(tmp_max_acceleration));
  if (raw_max_acceleration != 0) {
    total_size += 2 + 8;
  }

  // double max_deceleration = 61;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_deceleration = this->_internal_max_deceleration();
  uint64_t raw_max_deceleration;
  memcpy(&raw_max_deceleration, &tmp_max_deceleration, sizeof(tmp_max_deceleration));
  if (raw_max_deceleration != 0) {
    total_size += 2 + 8;
  }

  // double safe_time_buffer = 70;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_safe_time_buffer = this->_internal_safe_time_buffer();
  uint64_t raw_safe_time_buffer;
  memcpy(&raw_safe_time_buffer, &tmp_safe_time_buffer, sizeof(tmp_safe_time_buffer));
  if (raw_safe_time_buffer != 0) {
    total_size += 2 + 8;
  }

  // double safe_distance = 71;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_safe_distance = this->_internal_safe_distance();
  uint64_t raw_safe_distance;
  memcpy(&raw_safe_distance, &tmp_safe_distance, sizeof(tmp_safe_distance));
  if (raw_safe_distance != 0) {
    total_size += 2 + 8;
  }

  // double spatial_potential_penalty = 80;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spatial_potential_penalty = this->_internal_spatial_potential_penalty();
  uint64_t raw_spatial_potential_penalty;
  memcpy(&raw_spatial_potential_penalty, &tmp_spatial_potential_penalty, sizeof(tmp_spatial_potential_penalty));
  if (raw_spatial_potential_penalty != 0) {
    total_size += 2 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DpStSpeedOptimizerConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DpStSpeedOptimizerConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DpStSpeedOptimizerConfig::GetClassData() const { return &_class_data_; }

void DpStSpeedOptimizerConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DpStSpeedOptimizerConfig *>(to)->MergeFrom(
      static_cast<const DpStSpeedOptimizerConfig &>(from));
}


void DpStSpeedOptimizerConfig::MergeFrom(const DpStSpeedOptimizerConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.DpStSpeedOptimizerConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_unit_t = from._internal_unit_t();
  uint64_t raw_unit_t;
  memcpy(&raw_unit_t, &tmp_unit_t, sizeof(tmp_unit_t));
  if (raw_unit_t != 0) {
    _internal_set_unit_t(from._internal_unit_t());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dense_unit_s = from._internal_dense_unit_s();
  uint64_t raw_dense_unit_s;
  memcpy(&raw_dense_unit_s, &tmp_dense_unit_s, sizeof(tmp_dense_unit_s));
  if (raw_dense_unit_s != 0) {
    _internal_set_dense_unit_s(from._internal_dense_unit_s());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_sparse_unit_s = from._internal_sparse_unit_s();
  uint64_t raw_sparse_unit_s;
  memcpy(&raw_sparse_unit_s, &tmp_sparse_unit_s, sizeof(tmp_sparse_unit_s));
  if (raw_sparse_unit_s != 0) {
    _internal_set_sparse_unit_s(from._internal_sparse_unit_s());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed_weight = from._internal_speed_weight();
  uint64_t raw_speed_weight;
  memcpy(&raw_speed_weight, &tmp_speed_weight, sizeof(tmp_speed_weight));
  if (raw_speed_weight != 0) {
    _internal_set_speed_weight(from._internal_speed_weight());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_accel_weight = from._internal_accel_weight();
  uint64_t raw_accel_weight;
  memcpy(&raw_accel_weight, &tmp_accel_weight, sizeof(tmp_accel_weight));
  if (raw_accel_weight != 0) {
    _internal_set_accel_weight(from._internal_accel_weight());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_jerk_weight = from._internal_jerk_weight();
  uint64_t raw_jerk_weight;
  memcpy(&raw_jerk_weight, &tmp_jerk_weight, sizeof(tmp_jerk_weight));
  if (raw_jerk_weight != 0) {
    _internal_set_jerk_weight(from._internal_jerk_weight());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_obstacle_weight = from._internal_obstacle_weight();
  uint64_t raw_obstacle_weight;
  memcpy(&raw_obstacle_weight, &tmp_obstacle_weight, sizeof(tmp_obstacle_weight));
  if (raw_obstacle_weight != 0) {
    _internal_set_obstacle_weight(from._internal_obstacle_weight());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reference_weight = from._internal_reference_weight();
  uint64_t raw_reference_weight;
  memcpy(&raw_reference_weight, &tmp_reference_weight, sizeof(tmp_reference_weight));
  if (raw_reference_weight != 0) {
    _internal_set_reference_weight(from._internal_reference_weight());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_go_down_buffer = from._internal_go_down_buffer();
  uint64_t raw_go_down_buffer;
  memcpy(&raw_go_down_buffer, &tmp_go_down_buffer, sizeof(tmp_go_down_buffer));
  if (raw_go_down_buffer != 0) {
    _internal_set_go_down_buffer(from._internal_go_down_buffer());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_go_up_buffer = from._internal_go_up_buffer();
  uint64_t raw_go_up_buffer;
  memcpy(&raw_go_up_buffer, &tmp_go_up_buffer, sizeof(tmp_go_up_buffer));
  if (raw_go_up_buffer != 0) {
    _internal_set_go_up_buffer(from._internal_go_up_buffer());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_default_obstacle_cost = from._internal_default_obstacle_cost();
  uint64_t raw_default_obstacle_cost;
  memcpy(&raw_default_obstacle_cost, &tmp_default_obstacle_cost, sizeof(tmp_default_obstacle_cost));
  if (raw_default_obstacle_cost != 0) {
    _internal_set_default_obstacle_cost(from._internal_default_obstacle_cost());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_default_speed_cost = from._internal_default_speed_cost();
  uint64_t raw_default_speed_cost;
  memcpy(&raw_default_speed_cost, &tmp_default_speed_cost, sizeof(tmp_default_speed_cost));
  if (raw_default_speed_cost != 0) {
    _internal_set_default_speed_cost(from._internal_default_speed_cost());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_exceed_speed_penalty = from._internal_exceed_speed_penalty();
  uint64_t raw_exceed_speed_penalty;
  memcpy(&raw_exceed_speed_penalty, &tmp_exceed_speed_penalty, sizeof(tmp_exceed_speed_penalty));
  if (raw_exceed_speed_penalty != 0) {
    _internal_set_exceed_speed_penalty(from._internal_exceed_speed_penalty());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_low_speed_penalty = from._internal_low_speed_penalty();
  uint64_t raw_low_speed_penalty;
  memcpy(&raw_low_speed_penalty, &tmp_low_speed_penalty, sizeof(tmp_low_speed_penalty));
  if (raw_low_speed_penalty != 0) {
    _internal_set_low_speed_penalty(from._internal_low_speed_penalty());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reference_speed_penalty = from._internal_reference_speed_penalty();
  uint64_t raw_reference_speed_penalty;
  memcpy(&raw_reference_speed_penalty, &tmp_reference_speed_penalty, sizeof(tmp_reference_speed_penalty));
  if (raw_reference_speed_penalty != 0) {
    _internal_set_reference_speed_penalty(from._internal_reference_speed_penalty());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_keep_clear_low_speed_penalty = from._internal_keep_clear_low_speed_penalty();
  uint64_t raw_keep_clear_low_speed_penalty;
  memcpy(&raw_keep_clear_low_speed_penalty, &tmp_keep_clear_low_speed_penalty, sizeof(tmp_keep_clear_low_speed_penalty));
  if (raw_keep_clear_low_speed_penalty != 0) {
    _internal_set_keep_clear_low_speed_penalty(from._internal_keep_clear_low_speed_penalty());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_accel_penalty = from._internal_accel_penalty();
  uint64_t raw_accel_penalty;
  memcpy(&raw_accel_penalty, &tmp_accel_penalty, sizeof(tmp_accel_penalty));
  if (raw_accel_penalty != 0) {
    _internal_set_accel_penalty(from._internal_accel_penalty());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_decel_penalty = from._internal_decel_penalty();
  uint64_t raw_decel_penalty;
  memcpy(&raw_decel_penalty, &tmp_decel_penalty, sizeof(tmp_decel_penalty));
  if (raw_decel_penalty != 0) {
    _internal_set_decel_penalty(from._internal_decel_penalty());
  }
  if (from._internal_dense_dimension_s() != 0) {
    _internal_set_dense_dimension_s(from._internal_dense_dimension_s());
  }
  if (from._internal_is_lane_changing() != 0) {
    _internal_set_is_lane_changing(from._internal_is_lane_changing());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_positive_jerk_coeff = from._internal_positive_jerk_coeff();
  uint64_t raw_positive_jerk_coeff;
  memcpy(&raw_positive_jerk_coeff, &tmp_positive_jerk_coeff, sizeof(tmp_positive_jerk_coeff));
  if (raw_positive_jerk_coeff != 0) {
    _internal_set_positive_jerk_coeff(from._internal_positive_jerk_coeff());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_negative_jerk_coeff = from._internal_negative_jerk_coeff();
  uint64_t raw_negative_jerk_coeff;
  memcpy(&raw_negative_jerk_coeff, &tmp_negative_jerk_coeff, sizeof(tmp_negative_jerk_coeff));
  if (raw_negative_jerk_coeff != 0) {
    _internal_set_negative_jerk_coeff(from._internal_negative_jerk_coeff());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_acceleration = from._internal_max_acceleration();
  uint64_t raw_max_acceleration;
  memcpy(&raw_max_acceleration, &tmp_max_acceleration, sizeof(tmp_max_acceleration));
  if (raw_max_acceleration != 0) {
    _internal_set_max_acceleration(from._internal_max_acceleration());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_deceleration = from._internal_max_deceleration();
  uint64_t raw_max_deceleration;
  memcpy(&raw_max_deceleration, &tmp_max_deceleration, sizeof(tmp_max_deceleration));
  if (raw_max_deceleration != 0) {
    _internal_set_max_deceleration(from._internal_max_deceleration());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_safe_time_buffer = from._internal_safe_time_buffer();
  uint64_t raw_safe_time_buffer;
  memcpy(&raw_safe_time_buffer, &tmp_safe_time_buffer, sizeof(tmp_safe_time_buffer));
  if (raw_safe_time_buffer != 0) {
    _internal_set_safe_time_buffer(from._internal_safe_time_buffer());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_safe_distance = from._internal_safe_distance();
  uint64_t raw_safe_distance;
  memcpy(&raw_safe_distance, &tmp_safe_distance, sizeof(tmp_safe_distance));
  if (raw_safe_distance != 0) {
    _internal_set_safe_distance(from._internal_safe_distance());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_spatial_potential_penalty = from._internal_spatial_potential_penalty();
  uint64_t raw_spatial_potential_penalty;
  memcpy(&raw_spatial_potential_penalty, &tmp_spatial_potential_penalty, sizeof(tmp_spatial_potential_penalty));
  if (raw_spatial_potential_penalty != 0) {
    _internal_set_spatial_potential_penalty(from._internal_spatial_potential_penalty());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DpStSpeedOptimizerConfig::CopyFrom(const DpStSpeedOptimizerConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.DpStSpeedOptimizerConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DpStSpeedOptimizerConfig::IsInitialized() const {
  return true;
}

void DpStSpeedOptimizerConfig::InternalSwap(DpStSpeedOptimizerConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DpStSpeedOptimizerConfig, spatial_potential_penalty_)
      + sizeof(DpStSpeedOptimizerConfig::spatial_potential_penalty_)
      - PROTOBUF_FIELD_OFFSET(DpStSpeedOptimizerConfig, unit_t_)>(
          reinterpret_cast<char*>(&unit_t_),
          reinterpret_cast<char*>(&other->unit_t_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DpStSpeedOptimizerConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2ftask_5fconfig_2eproto_getter, &descriptor_table_autoagric_2fplanning_2ftask_5fconfig_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2ftask_5fconfig_2eproto[0]);
}

// ===================================================================

class PiecewiseJerkSpeedOptimizerConfig::_Internal {
 public:
};

PiecewiseJerkSpeedOptimizerConfig::PiecewiseJerkSpeedOptimizerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.planning.PiecewiseJerkSpeedOptimizerConfig)
}
PiecewiseJerkSpeedOptimizerConfig::PiecewiseJerkSpeedOptimizerConfig(const PiecewiseJerkSpeedOptimizerConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&acc_weight_, &from.acc_weight_,
    static_cast<size_t>(reinterpret_cast<char*>(&ref_v_weight_) -
    reinterpret_cast<char*>(&acc_weight_)) + sizeof(ref_v_weight_));
  // @@protoc_insertion_point(copy_constructor:autoagric.planning.PiecewiseJerkSpeedOptimizerConfig)
}

inline void PiecewiseJerkSpeedOptimizerConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&acc_weight_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ref_v_weight_) -
    reinterpret_cast<char*>(&acc_weight_)) + sizeof(ref_v_weight_));
}

PiecewiseJerkSpeedOptimizerConfig::~PiecewiseJerkSpeedOptimizerConfig() {
  // @@protoc_insertion_point(destructor:autoagric.planning.PiecewiseJerkSpeedOptimizerConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PiecewiseJerkSpeedOptimizerConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PiecewiseJerkSpeedOptimizerConfig::ArenaDtor(void* object) {
  PiecewiseJerkSpeedOptimizerConfig* _this = reinterpret_cast< PiecewiseJerkSpeedOptimizerConfig* >(object);
  (void)_this;
}
void PiecewiseJerkSpeedOptimizerConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PiecewiseJerkSpeedOptimizerConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PiecewiseJerkSpeedOptimizerConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.planning.PiecewiseJerkSpeedOptimizerConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&acc_weight_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ref_v_weight_) -
      reinterpret_cast<char*>(&acc_weight_)) + sizeof(ref_v_weight_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PiecewiseJerkSpeedOptimizerConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double acc_weight = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          acc_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double jerk_weight = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          jerk_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double kappa_penalty_weight = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          kappa_penalty_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double ref_s_weight = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          ref_s_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double ref_v_weight = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          ref_v_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PiecewiseJerkSpeedOptimizerConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.planning.PiecewiseJerkSpeedOptimizerConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double acc_weight = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_acc_weight = this->_internal_acc_weight();
  uint64_t raw_acc_weight;
  memcpy(&raw_acc_weight, &tmp_acc_weight, sizeof(tmp_acc_weight));
  if (raw_acc_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_acc_weight(), target);
  }

  // double jerk_weight = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_jerk_weight = this->_internal_jerk_weight();
  uint64_t raw_jerk_weight;
  memcpy(&raw_jerk_weight, &tmp_jerk_weight, sizeof(tmp_jerk_weight));
  if (raw_jerk_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_jerk_weight(), target);
  }

  // double kappa_penalty_weight = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_kappa_penalty_weight = this->_internal_kappa_penalty_weight();
  uint64_t raw_kappa_penalty_weight;
  memcpy(&raw_kappa_penalty_weight, &tmp_kappa_penalty_weight, sizeof(tmp_kappa_penalty_weight));
  if (raw_kappa_penalty_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_kappa_penalty_weight(), target);
  }

  // double ref_s_weight = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ref_s_weight = this->_internal_ref_s_weight();
  uint64_t raw_ref_s_weight;
  memcpy(&raw_ref_s_weight, &tmp_ref_s_weight, sizeof(tmp_ref_s_weight));
  if (raw_ref_s_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_ref_s_weight(), target);
  }

  // double ref_v_weight = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ref_v_weight = this->_internal_ref_v_weight();
  uint64_t raw_ref_v_weight;
  memcpy(&raw_ref_v_weight, &tmp_ref_v_weight, sizeof(tmp_ref_v_weight));
  if (raw_ref_v_weight != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_ref_v_weight(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.planning.PiecewiseJerkSpeedOptimizerConfig)
  return target;
}

size_t PiecewiseJerkSpeedOptimizerConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.planning.PiecewiseJerkSpeedOptimizerConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double acc_weight = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_acc_weight = this->_internal_acc_weight();
  uint64_t raw_acc_weight;
  memcpy(&raw_acc_weight, &tmp_acc_weight, sizeof(tmp_acc_weight));
  if (raw_acc_weight != 0) {
    total_size += 1 + 8;
  }

  // double jerk_weight = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_jerk_weight = this->_internal_jerk_weight();
  uint64_t raw_jerk_weight;
  memcpy(&raw_jerk_weight, &tmp_jerk_weight, sizeof(tmp_jerk_weight));
  if (raw_jerk_weight != 0) {
    total_size += 1 + 8;
  }

  // double kappa_penalty_weight = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_kappa_penalty_weight = this->_internal_kappa_penalty_weight();
  uint64_t raw_kappa_penalty_weight;
  memcpy(&raw_kappa_penalty_weight, &tmp_kappa_penalty_weight, sizeof(tmp_kappa_penalty_weight));
  if (raw_kappa_penalty_weight != 0) {
    total_size += 1 + 8;
  }

  // double ref_s_weight = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ref_s_weight = this->_internal_ref_s_weight();
  uint64_t raw_ref_s_weight;
  memcpy(&raw_ref_s_weight, &tmp_ref_s_weight, sizeof(tmp_ref_s_weight));
  if (raw_ref_s_weight != 0) {
    total_size += 1 + 8;
  }

  // double ref_v_weight = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ref_v_weight = this->_internal_ref_v_weight();
  uint64_t raw_ref_v_weight;
  memcpy(&raw_ref_v_weight, &tmp_ref_v_weight, sizeof(tmp_ref_v_weight));
  if (raw_ref_v_weight != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PiecewiseJerkSpeedOptimizerConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PiecewiseJerkSpeedOptimizerConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PiecewiseJerkSpeedOptimizerConfig::GetClassData() const { return &_class_data_; }

void PiecewiseJerkSpeedOptimizerConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PiecewiseJerkSpeedOptimizerConfig *>(to)->MergeFrom(
      static_cast<const PiecewiseJerkSpeedOptimizerConfig &>(from));
}


void PiecewiseJerkSpeedOptimizerConfig::MergeFrom(const PiecewiseJerkSpeedOptimizerConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.planning.PiecewiseJerkSpeedOptimizerConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_acc_weight = from._internal_acc_weight();
  uint64_t raw_acc_weight;
  memcpy(&raw_acc_weight, &tmp_acc_weight, sizeof(tmp_acc_weight));
  if (raw_acc_weight != 0) {
    _internal_set_acc_weight(from._internal_acc_weight());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_jerk_weight = from._internal_jerk_weight();
  uint64_t raw_jerk_weight;
  memcpy(&raw_jerk_weight, &tmp_jerk_weight, sizeof(tmp_jerk_weight));
  if (raw_jerk_weight != 0) {
    _internal_set_jerk_weight(from._internal_jerk_weight());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_kappa_penalty_weight = from._internal_kappa_penalty_weight();
  uint64_t raw_kappa_penalty_weight;
  memcpy(&raw_kappa_penalty_weight, &tmp_kappa_penalty_weight, sizeof(tmp_kappa_penalty_weight));
  if (raw_kappa_penalty_weight != 0) {
    _internal_set_kappa_penalty_weight(from._internal_kappa_penalty_weight());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ref_s_weight = from._internal_ref_s_weight();
  uint64_t raw_ref_s_weight;
  memcpy(&raw_ref_s_weight, &tmp_ref_s_weight, sizeof(tmp_ref_s_weight));
  if (raw_ref_s_weight != 0) {
    _internal_set_ref_s_weight(from._internal_ref_s_weight());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ref_v_weight = from._internal_ref_v_weight();
  uint64_t raw_ref_v_weight;
  memcpy(&raw_ref_v_weight, &tmp_ref_v_weight, sizeof(tmp_ref_v_weight));
  if (raw_ref_v_weight != 0) {
    _internal_set_ref_v_weight(from._internal_ref_v_weight());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PiecewiseJerkSpeedOptimizerConfig::CopyFrom(const PiecewiseJerkSpeedOptimizerConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.planning.PiecewiseJerkSpeedOptimizerConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PiecewiseJerkSpeedOptimizerConfig::IsInitialized() const {
  return true;
}

void PiecewiseJerkSpeedOptimizerConfig::InternalSwap(PiecewiseJerkSpeedOptimizerConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PiecewiseJerkSpeedOptimizerConfig, ref_v_weight_)
      + sizeof(PiecewiseJerkSpeedOptimizerConfig::ref_v_weight_)
      - PROTOBUF_FIELD_OFFSET(PiecewiseJerkSpeedOptimizerConfig, acc_weight_)>(
          reinterpret_cast<char*>(&acc_weight_),
          reinterpret_cast<char*>(&other->acc_weight_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PiecewiseJerkSpeedOptimizerConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fplanning_2ftask_5fconfig_2eproto_getter, &descriptor_table_autoagric_2fplanning_2ftask_5fconfig_2eproto_once,
      file_level_metadata_autoagric_2fplanning_2ftask_5fconfig_2eproto[1]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace planning
}  // namespace autoagric
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::autoagric::planning::DpStSpeedOptimizerConfig* Arena::CreateMaybeMessage< ::autoagric::planning::DpStSpeedOptimizerConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::DpStSpeedOptimizerConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::planning::PiecewiseJerkSpeedOptimizerConfig* Arena::CreateMaybeMessage< ::autoagric::planning::PiecewiseJerkSpeedOptimizerConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::planning::PiecewiseJerkSpeedOptimizerConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
