// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: autoagric/planning/decision.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_autoagric_2fplanning_2fdecision_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_autoagric_2fplanning_2fdecision_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "autoagric/common/geometry.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_autoagric_2fplanning_2fdecision_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_autoagric_2fplanning_2fdecision_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_autoagric_2fplanning_2fdecision_2eproto;
namespace autoagric {
namespace planning {
class ObjectAvoid;
struct ObjectAvoidDefaultTypeInternal;
extern ObjectAvoidDefaultTypeInternal _ObjectAvoid_default_instance_;
class ObjectDecision;
struct ObjectDecisionDefaultTypeInternal;
extern ObjectDecisionDefaultTypeInternal _ObjectDecision_default_instance_;
class ObjectDecisionType;
struct ObjectDecisionTypeDefaultTypeInternal;
extern ObjectDecisionTypeDefaultTypeInternal _ObjectDecisionType_default_instance_;
class ObjectDecisions;
struct ObjectDecisionsDefaultTypeInternal;
extern ObjectDecisionsDefaultTypeInternal _ObjectDecisions_default_instance_;
class ObjectDynamic;
struct ObjectDynamicDefaultTypeInternal;
extern ObjectDynamicDefaultTypeInternal _ObjectDynamic_default_instance_;
class ObjectFollow;
struct ObjectFollowDefaultTypeInternal;
extern ObjectFollowDefaultTypeInternal _ObjectFollow_default_instance_;
class ObjectIgnore;
struct ObjectIgnoreDefaultTypeInternal;
extern ObjectIgnoreDefaultTypeInternal _ObjectIgnore_default_instance_;
class ObjectMotionType;
struct ObjectMotionTypeDefaultTypeInternal;
extern ObjectMotionTypeDefaultTypeInternal _ObjectMotionType_default_instance_;
class ObjectNudge;
struct ObjectNudgeDefaultTypeInternal;
extern ObjectNudgeDefaultTypeInternal _ObjectNudge_default_instance_;
class ObjectOvertake;
struct ObjectOvertakeDefaultTypeInternal;
extern ObjectOvertakeDefaultTypeInternal _ObjectOvertake_default_instance_;
class ObjectSidePass;
struct ObjectSidePassDefaultTypeInternal;
extern ObjectSidePassDefaultTypeInternal _ObjectSidePass_default_instance_;
class ObjectStatic;
struct ObjectStaticDefaultTypeInternal;
extern ObjectStaticDefaultTypeInternal _ObjectStatic_default_instance_;
class ObjectStatus;
struct ObjectStatusDefaultTypeInternal;
extern ObjectStatusDefaultTypeInternal _ObjectStatus_default_instance_;
class ObjectStop;
struct ObjectStopDefaultTypeInternal;
extern ObjectStopDefaultTypeInternal _ObjectStop_default_instance_;
class ObjectYield;
struct ObjectYieldDefaultTypeInternal;
extern ObjectYieldDefaultTypeInternal _ObjectYield_default_instance_;
class TargetLane;
struct TargetLaneDefaultTypeInternal;
extern TargetLaneDefaultTypeInternal _TargetLane_default_instance_;
}  // namespace planning
}  // namespace autoagric
PROTOBUF_NAMESPACE_OPEN
template<> ::autoagric::planning::ObjectAvoid* Arena::CreateMaybeMessage<::autoagric::planning::ObjectAvoid>(Arena*);
template<> ::autoagric::planning::ObjectDecision* Arena::CreateMaybeMessage<::autoagric::planning::ObjectDecision>(Arena*);
template<> ::autoagric::planning::ObjectDecisionType* Arena::CreateMaybeMessage<::autoagric::planning::ObjectDecisionType>(Arena*);
template<> ::autoagric::planning::ObjectDecisions* Arena::CreateMaybeMessage<::autoagric::planning::ObjectDecisions>(Arena*);
template<> ::autoagric::planning::ObjectDynamic* Arena::CreateMaybeMessage<::autoagric::planning::ObjectDynamic>(Arena*);
template<> ::autoagric::planning::ObjectFollow* Arena::CreateMaybeMessage<::autoagric::planning::ObjectFollow>(Arena*);
template<> ::autoagric::planning::ObjectIgnore* Arena::CreateMaybeMessage<::autoagric::planning::ObjectIgnore>(Arena*);
template<> ::autoagric::planning::ObjectMotionType* Arena::CreateMaybeMessage<::autoagric::planning::ObjectMotionType>(Arena*);
template<> ::autoagric::planning::ObjectNudge* Arena::CreateMaybeMessage<::autoagric::planning::ObjectNudge>(Arena*);
template<> ::autoagric::planning::ObjectOvertake* Arena::CreateMaybeMessage<::autoagric::planning::ObjectOvertake>(Arena*);
template<> ::autoagric::planning::ObjectSidePass* Arena::CreateMaybeMessage<::autoagric::planning::ObjectSidePass>(Arena*);
template<> ::autoagric::planning::ObjectStatic* Arena::CreateMaybeMessage<::autoagric::planning::ObjectStatic>(Arena*);
template<> ::autoagric::planning::ObjectStatus* Arena::CreateMaybeMessage<::autoagric::planning::ObjectStatus>(Arena*);
template<> ::autoagric::planning::ObjectStop* Arena::CreateMaybeMessage<::autoagric::planning::ObjectStop>(Arena*);
template<> ::autoagric::planning::ObjectYield* Arena::CreateMaybeMessage<::autoagric::planning::ObjectYield>(Arena*);
template<> ::autoagric::planning::TargetLane* Arena::CreateMaybeMessage<::autoagric::planning::TargetLane>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autoagric {
namespace planning {

enum ObjectNudge_Type : int {
  ObjectNudge_Type_UNKNOWN = 0,
  ObjectNudge_Type_LEFT_NUDGE = 1,
  ObjectNudge_Type_RIGHT_NUDGE = 2,
  ObjectNudge_Type_DYNAMIC_LEFT_NUDGE = 3,
  ObjectNudge_Type_DYNAMIC_RIGHT_NUDGE = 4,
  ObjectNudge_Type_ObjectNudge_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ObjectNudge_Type_ObjectNudge_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ObjectNudge_Type_IsValid(int value);
constexpr ObjectNudge_Type ObjectNudge_Type_Type_MIN = ObjectNudge_Type_UNKNOWN;
constexpr ObjectNudge_Type ObjectNudge_Type_Type_MAX = ObjectNudge_Type_DYNAMIC_RIGHT_NUDGE;
constexpr int ObjectNudge_Type_Type_ARRAYSIZE = ObjectNudge_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjectNudge_Type_descriptor();
template<typename T>
inline const std::string& ObjectNudge_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObjectNudge_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObjectNudge_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObjectNudge_Type_descriptor(), enum_t_value);
}
inline bool ObjectNudge_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ObjectNudge_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObjectNudge_Type>(
    ObjectNudge_Type_descriptor(), name, value);
}
enum ObjectSidePass_Type : int {
  ObjectSidePass_Type_UNKNOWN = 0,
  ObjectSidePass_Type_LEFT = 1,
  ObjectSidePass_Type_RIGHT = 2,
  ObjectSidePass_Type_ObjectSidePass_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ObjectSidePass_Type_ObjectSidePass_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ObjectSidePass_Type_IsValid(int value);
constexpr ObjectSidePass_Type ObjectSidePass_Type_Type_MIN = ObjectSidePass_Type_UNKNOWN;
constexpr ObjectSidePass_Type ObjectSidePass_Type_Type_MAX = ObjectSidePass_Type_RIGHT;
constexpr int ObjectSidePass_Type_Type_ARRAYSIZE = ObjectSidePass_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjectSidePass_Type_descriptor();
template<typename T>
inline const std::string& ObjectSidePass_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObjectSidePass_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObjectSidePass_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObjectSidePass_Type_descriptor(), enum_t_value);
}
inline bool ObjectSidePass_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ObjectSidePass_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObjectSidePass_Type>(
    ObjectSidePass_Type_descriptor(), name, value);
}
enum StopReasonCode : int {
  STOP_REASON_UNKNOWN = 0,
  STOP_REASON_HEAD_VEHICLE = 1,
  STOP_REASON_DESTINATION = 2,
  STOP_REASON_PEDESTRIAN = 3,
  STOP_REASON_OBSTACLE = 4,
  STOP_REASON_PREPARKING = 5,
  STOP_REASON_SIGNAL = 100,
  STOP_REASON_STOP_SIGN = 101,
  STOP_REASON_YIELD_SIGN = 102,
  STOP_REASON_CLEAR_ZONE = 103,
  STOP_REASON_CROSSWALK = 104,
  STOP_REASON_CREEPER = 105,
  STOP_REASON_REFERENCE_END = 106,
  STOP_REASON_YELLOW_SIGNAL = 107,
  STOP_REASON_PULL_OVER = 108,
  STOP_REASON_SIDEPASS_SAFETY = 109,
  STOP_REASON_PRE_OPEN_SPACE_STOP = 200,
  STOP_REASON_LANE_CHANGE_URGENCY = 201,
  STOP_REASON_EMERGENCY = 202,
  StopReasonCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StopReasonCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StopReasonCode_IsValid(int value);
constexpr StopReasonCode StopReasonCode_MIN = STOP_REASON_UNKNOWN;
constexpr StopReasonCode StopReasonCode_MAX = STOP_REASON_EMERGENCY;
constexpr int StopReasonCode_ARRAYSIZE = StopReasonCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StopReasonCode_descriptor();
template<typename T>
inline const std::string& StopReasonCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopReasonCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopReasonCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StopReasonCode_descriptor(), enum_t_value);
}
inline bool StopReasonCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StopReasonCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StopReasonCode>(
    StopReasonCode_descriptor(), name, value);
}
// ===================================================================

class TargetLane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.TargetLane) */ {
 public:
  inline TargetLane() : TargetLane(nullptr) {}
  ~TargetLane() override;
  explicit constexpr TargetLane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetLane(const TargetLane& from);
  TargetLane(TargetLane&& from) noexcept
    : TargetLane() {
    *this = ::std::move(from);
  }

  inline TargetLane& operator=(const TargetLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetLane& operator=(TargetLane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetLane& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetLane* internal_default_instance() {
    return reinterpret_cast<const TargetLane*>(
               &_TargetLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TargetLane& a, TargetLane& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetLane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetLane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetLane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetLane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetLane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TargetLane& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetLane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.TargetLane";
  }
  protected:
  explicit TargetLane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStartSFieldNumber = 2,
    kEndSFieldNumber = 3,
    kSpeedLimitFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // double start_s = 2;
  void clear_start_s();
  double start_s() const;
  void set_start_s(double value);
  private:
  double _internal_start_s() const;
  void _internal_set_start_s(double value);
  public:

  // double end_s = 3;
  void clear_end_s();
  double end_s() const;
  void set_end_s(double value);
  private:
  double _internal_end_s() const;
  void _internal_set_end_s(double value);
  public:

  // double speed_limit = 4;
  void clear_speed_limit();
  double speed_limit() const;
  void set_speed_limit(double value);
  private:
  double _internal_speed_limit() const;
  void _internal_set_speed_limit(double value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.planning.TargetLane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  double start_s_;
  double end_s_;
  double speed_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectIgnore final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectIgnore) */ {
 public:
  inline ObjectIgnore() : ObjectIgnore(nullptr) {}
  explicit constexpr ObjectIgnore(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectIgnore(const ObjectIgnore& from);
  ObjectIgnore(ObjectIgnore&& from) noexcept
    : ObjectIgnore() {
    *this = ::std::move(from);
  }

  inline ObjectIgnore& operator=(const ObjectIgnore& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectIgnore& operator=(ObjectIgnore&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectIgnore& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectIgnore* internal_default_instance() {
    return reinterpret_cast<const ObjectIgnore*>(
               &_ObjectIgnore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ObjectIgnore& a, ObjectIgnore& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectIgnore* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectIgnore* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectIgnore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectIgnore>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ObjectIgnore& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ObjectIgnore& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectIgnore";
  }
  protected:
  explicit ObjectIgnore(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectIgnore)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectStop) */ {
 public:
  inline ObjectStop() : ObjectStop(nullptr) {}
  ~ObjectStop() override;
  explicit constexpr ObjectStop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectStop(const ObjectStop& from);
  ObjectStop(ObjectStop&& from) noexcept
    : ObjectStop() {
    *this = ::std::move(from);
  }

  inline ObjectStop& operator=(const ObjectStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectStop& operator=(ObjectStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectStop* internal_default_instance() {
    return reinterpret_cast<const ObjectStop*>(
               &_ObjectStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ObjectStop& a, ObjectStop& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectStop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectStop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectStop& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectStop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectStop";
  }
  protected:
  explicit ObjectStop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaitForObstacleFieldNumber = 5,
    kStopPointFieldNumber = 3,
    kDistanceSFieldNumber = 2,
    kStopHeadingFieldNumber = 4,
    kReasonCodeFieldNumber = 1,
  };
  // repeated string wait_for_obstacle = 5;
  int wait_for_obstacle_size() const;
  private:
  int _internal_wait_for_obstacle_size() const;
  public:
  void clear_wait_for_obstacle();
  const std::string& wait_for_obstacle(int index) const;
  std::string* mutable_wait_for_obstacle(int index);
  void set_wait_for_obstacle(int index, const std::string& value);
  void set_wait_for_obstacle(int index, std::string&& value);
  void set_wait_for_obstacle(int index, const char* value);
  void set_wait_for_obstacle(int index, const char* value, size_t size);
  std::string* add_wait_for_obstacle();
  void add_wait_for_obstacle(const std::string& value);
  void add_wait_for_obstacle(std::string&& value);
  void add_wait_for_obstacle(const char* value);
  void add_wait_for_obstacle(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wait_for_obstacle() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wait_for_obstacle();
  private:
  const std::string& _internal_wait_for_obstacle(int index) const;
  std::string* _internal_add_wait_for_obstacle();
  public:

  // .autoagric.common.PointENU stop_point = 3;
  bool has_stop_point() const;
  private:
  bool _internal_has_stop_point() const;
  public:
  void clear_stop_point();
  const ::autoagric::common::PointENU& stop_point() const;
  PROTOBUF_NODISCARD ::autoagric::common::PointENU* release_stop_point();
  ::autoagric::common::PointENU* mutable_stop_point();
  void set_allocated_stop_point(::autoagric::common::PointENU* stop_point);
  private:
  const ::autoagric::common::PointENU& _internal_stop_point() const;
  ::autoagric::common::PointENU* _internal_mutable_stop_point();
  public:
  void unsafe_arena_set_allocated_stop_point(
      ::autoagric::common::PointENU* stop_point);
  ::autoagric::common::PointENU* unsafe_arena_release_stop_point();

  // double distance_s = 2;
  void clear_distance_s();
  double distance_s() const;
  void set_distance_s(double value);
  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);
  public:

  // double stop_heading = 4;
  void clear_stop_heading();
  double stop_heading() const;
  void set_stop_heading(double value);
  private:
  double _internal_stop_heading() const;
  void _internal_set_stop_heading(double value);
  public:

  // .autoagric.planning.StopReasonCode reason_code = 1;
  void clear_reason_code();
  ::autoagric::planning::StopReasonCode reason_code() const;
  void set_reason_code(::autoagric::planning::StopReasonCode value);
  private:
  ::autoagric::planning::StopReasonCode _internal_reason_code() const;
  void _internal_set_reason_code(::autoagric::planning::StopReasonCode value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wait_for_obstacle_;
  ::autoagric::common::PointENU* stop_point_;
  double distance_s_;
  double stop_heading_;
  int reason_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectNudge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectNudge) */ {
 public:
  inline ObjectNudge() : ObjectNudge(nullptr) {}
  ~ObjectNudge() override;
  explicit constexpr ObjectNudge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectNudge(const ObjectNudge& from);
  ObjectNudge(ObjectNudge&& from) noexcept
    : ObjectNudge() {
    *this = ::std::move(from);
  }

  inline ObjectNudge& operator=(const ObjectNudge& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectNudge& operator=(ObjectNudge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectNudge& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectNudge* internal_default_instance() {
    return reinterpret_cast<const ObjectNudge*>(
               &_ObjectNudge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ObjectNudge& a, ObjectNudge& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectNudge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectNudge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectNudge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectNudge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectNudge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectNudge& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectNudge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectNudge";
  }
  protected:
  explicit ObjectNudge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ObjectNudge_Type Type;
  static constexpr Type UNKNOWN =
    ObjectNudge_Type_UNKNOWN;
  static constexpr Type LEFT_NUDGE =
    ObjectNudge_Type_LEFT_NUDGE;
  static constexpr Type RIGHT_NUDGE =
    ObjectNudge_Type_RIGHT_NUDGE;
  static constexpr Type DYNAMIC_LEFT_NUDGE =
    ObjectNudge_Type_DYNAMIC_LEFT_NUDGE;
  static constexpr Type DYNAMIC_RIGHT_NUDGE =
    ObjectNudge_Type_DYNAMIC_RIGHT_NUDGE;
  static inline bool Type_IsValid(int value) {
    return ObjectNudge_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ObjectNudge_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ObjectNudge_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ObjectNudge_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ObjectNudge_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ObjectNudge_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ObjectNudge_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDistanceLFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // double distance_l = 2;
  void clear_distance_l();
  double distance_l() const;
  void set_distance_l(double value);
  private:
  double _internal_distance_l() const;
  void _internal_set_distance_l(double value);
  public:

  // .autoagric.planning.ObjectNudge.Type type = 1;
  void clear_type();
  ::autoagric::planning::ObjectNudge_Type type() const;
  void set_type(::autoagric::planning::ObjectNudge_Type value);
  private:
  ::autoagric::planning::ObjectNudge_Type _internal_type() const;
  void _internal_set_type(::autoagric::planning::ObjectNudge_Type value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectNudge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double distance_l_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectYield final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectYield) */ {
 public:
  inline ObjectYield() : ObjectYield(nullptr) {}
  ~ObjectYield() override;
  explicit constexpr ObjectYield(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectYield(const ObjectYield& from);
  ObjectYield(ObjectYield&& from) noexcept
    : ObjectYield() {
    *this = ::std::move(from);
  }

  inline ObjectYield& operator=(const ObjectYield& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectYield& operator=(ObjectYield&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectYield& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectYield* internal_default_instance() {
    return reinterpret_cast<const ObjectYield*>(
               &_ObjectYield_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ObjectYield& a, ObjectYield& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectYield* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectYield* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectYield* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectYield>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectYield& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectYield& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectYield* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectYield";
  }
  protected:
  explicit ObjectYield(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFencePointFieldNumber = 2,
    kDistanceSFieldNumber = 1,
    kFenceHeadingFieldNumber = 3,
    kTimeBufferFieldNumber = 4,
  };
  // .autoagric.common.PointENU fence_point = 2;
  bool has_fence_point() const;
  private:
  bool _internal_has_fence_point() const;
  public:
  void clear_fence_point();
  const ::autoagric::common::PointENU& fence_point() const;
  PROTOBUF_NODISCARD ::autoagric::common::PointENU* release_fence_point();
  ::autoagric::common::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::autoagric::common::PointENU* fence_point);
  private:
  const ::autoagric::common::PointENU& _internal_fence_point() const;
  ::autoagric::common::PointENU* _internal_mutable_fence_point();
  public:
  void unsafe_arena_set_allocated_fence_point(
      ::autoagric::common::PointENU* fence_point);
  ::autoagric::common::PointENU* unsafe_arena_release_fence_point();

  // double distance_s = 1;
  void clear_distance_s();
  double distance_s() const;
  void set_distance_s(double value);
  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);
  public:

  // double fence_heading = 3;
  void clear_fence_heading();
  double fence_heading() const;
  void set_fence_heading(double value);
  private:
  double _internal_fence_heading() const;
  void _internal_set_fence_heading(double value);
  public:

  // double time_buffer = 4;
  void clear_time_buffer();
  double time_buffer() const;
  void set_time_buffer(double value);
  private:
  double _internal_time_buffer() const;
  void _internal_set_time_buffer(double value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectYield)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::autoagric::common::PointENU* fence_point_;
  double distance_s_;
  double fence_heading_;
  double time_buffer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectFollow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectFollow) */ {
 public:
  inline ObjectFollow() : ObjectFollow(nullptr) {}
  ~ObjectFollow() override;
  explicit constexpr ObjectFollow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectFollow(const ObjectFollow& from);
  ObjectFollow(ObjectFollow&& from) noexcept
    : ObjectFollow() {
    *this = ::std::move(from);
  }

  inline ObjectFollow& operator=(const ObjectFollow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectFollow& operator=(ObjectFollow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectFollow& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectFollow* internal_default_instance() {
    return reinterpret_cast<const ObjectFollow*>(
               &_ObjectFollow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ObjectFollow& a, ObjectFollow& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectFollow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectFollow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectFollow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectFollow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectFollow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectFollow& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectFollow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectFollow";
  }
  protected:
  explicit ObjectFollow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFencePointFieldNumber = 2,
    kDistanceSFieldNumber = 1,
    kFenceHeadingFieldNumber = 3,
  };
  // .autoagric.common.PointENU fence_point = 2;
  bool has_fence_point() const;
  private:
  bool _internal_has_fence_point() const;
  public:
  void clear_fence_point();
  const ::autoagric::common::PointENU& fence_point() const;
  PROTOBUF_NODISCARD ::autoagric::common::PointENU* release_fence_point();
  ::autoagric::common::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::autoagric::common::PointENU* fence_point);
  private:
  const ::autoagric::common::PointENU& _internal_fence_point() const;
  ::autoagric::common::PointENU* _internal_mutable_fence_point();
  public:
  void unsafe_arena_set_allocated_fence_point(
      ::autoagric::common::PointENU* fence_point);
  ::autoagric::common::PointENU* unsafe_arena_release_fence_point();

  // double distance_s = 1;
  void clear_distance_s();
  double distance_s() const;
  void set_distance_s(double value);
  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);
  public:

  // double fence_heading = 3;
  void clear_fence_heading();
  double fence_heading() const;
  void set_fence_heading(double value);
  private:
  double _internal_fence_heading() const;
  void _internal_set_fence_heading(double value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectFollow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::autoagric::common::PointENU* fence_point_;
  double distance_s_;
  double fence_heading_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectOvertake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectOvertake) */ {
 public:
  inline ObjectOvertake() : ObjectOvertake(nullptr) {}
  ~ObjectOvertake() override;
  explicit constexpr ObjectOvertake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectOvertake(const ObjectOvertake& from);
  ObjectOvertake(ObjectOvertake&& from) noexcept
    : ObjectOvertake() {
    *this = ::std::move(from);
  }

  inline ObjectOvertake& operator=(const ObjectOvertake& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectOvertake& operator=(ObjectOvertake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectOvertake& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectOvertake* internal_default_instance() {
    return reinterpret_cast<const ObjectOvertake*>(
               &_ObjectOvertake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ObjectOvertake& a, ObjectOvertake& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectOvertake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectOvertake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectOvertake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectOvertake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectOvertake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectOvertake& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectOvertake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectOvertake";
  }
  protected:
  explicit ObjectOvertake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFencePointFieldNumber = 2,
    kDistanceSFieldNumber = 1,
    kFenceHeadingFieldNumber = 3,
    kTimeBufferFieldNumber = 4,
  };
  // .autoagric.common.PointENU fence_point = 2;
  bool has_fence_point() const;
  private:
  bool _internal_has_fence_point() const;
  public:
  void clear_fence_point();
  const ::autoagric::common::PointENU& fence_point() const;
  PROTOBUF_NODISCARD ::autoagric::common::PointENU* release_fence_point();
  ::autoagric::common::PointENU* mutable_fence_point();
  void set_allocated_fence_point(::autoagric::common::PointENU* fence_point);
  private:
  const ::autoagric::common::PointENU& _internal_fence_point() const;
  ::autoagric::common::PointENU* _internal_mutable_fence_point();
  public:
  void unsafe_arena_set_allocated_fence_point(
      ::autoagric::common::PointENU* fence_point);
  ::autoagric::common::PointENU* unsafe_arena_release_fence_point();

  // double distance_s = 1;
  void clear_distance_s();
  double distance_s() const;
  void set_distance_s(double value);
  private:
  double _internal_distance_s() const;
  void _internal_set_distance_s(double value);
  public:

  // double fence_heading = 3;
  void clear_fence_heading();
  double fence_heading() const;
  void set_fence_heading(double value);
  private:
  double _internal_fence_heading() const;
  void _internal_set_fence_heading(double value);
  public:

  // double time_buffer = 4;
  void clear_time_buffer();
  double time_buffer() const;
  void set_time_buffer(double value);
  private:
  double _internal_time_buffer() const;
  void _internal_set_time_buffer(double value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectOvertake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::autoagric::common::PointENU* fence_point_;
  double distance_s_;
  double fence_heading_;
  double time_buffer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectSidePass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectSidePass) */ {
 public:
  inline ObjectSidePass() : ObjectSidePass(nullptr) {}
  ~ObjectSidePass() override;
  explicit constexpr ObjectSidePass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectSidePass(const ObjectSidePass& from);
  ObjectSidePass(ObjectSidePass&& from) noexcept
    : ObjectSidePass() {
    *this = ::std::move(from);
  }

  inline ObjectSidePass& operator=(const ObjectSidePass& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectSidePass& operator=(ObjectSidePass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectSidePass& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectSidePass* internal_default_instance() {
    return reinterpret_cast<const ObjectSidePass*>(
               &_ObjectSidePass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ObjectSidePass& a, ObjectSidePass& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectSidePass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectSidePass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectSidePass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectSidePass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectSidePass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectSidePass& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectSidePass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectSidePass";
  }
  protected:
  explicit ObjectSidePass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ObjectSidePass_Type Type;
  static constexpr Type UNKNOWN =
    ObjectSidePass_Type_UNKNOWN;
  static constexpr Type LEFT =
    ObjectSidePass_Type_LEFT;
  static constexpr Type RIGHT =
    ObjectSidePass_Type_RIGHT;
  static inline bool Type_IsValid(int value) {
    return ObjectSidePass_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ObjectSidePass_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ObjectSidePass_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ObjectSidePass_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ObjectSidePass_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ObjectSidePass_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ObjectSidePass_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .autoagric.planning.ObjectSidePass.Type type = 1;
  void clear_type();
  ::autoagric::planning::ObjectSidePass_Type type() const;
  void set_type(::autoagric::planning::ObjectSidePass_Type value);
  private:
  ::autoagric::planning::ObjectSidePass_Type _internal_type() const;
  void _internal_set_type(::autoagric::planning::ObjectSidePass_Type value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectSidePass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectAvoid final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectAvoid) */ {
 public:
  inline ObjectAvoid() : ObjectAvoid(nullptr) {}
  explicit constexpr ObjectAvoid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectAvoid(const ObjectAvoid& from);
  ObjectAvoid(ObjectAvoid&& from) noexcept
    : ObjectAvoid() {
    *this = ::std::move(from);
  }

  inline ObjectAvoid& operator=(const ObjectAvoid& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectAvoid& operator=(ObjectAvoid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectAvoid& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectAvoid* internal_default_instance() {
    return reinterpret_cast<const ObjectAvoid*>(
               &_ObjectAvoid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ObjectAvoid& a, ObjectAvoid& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectAvoid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectAvoid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectAvoid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectAvoid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ObjectAvoid& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ObjectAvoid& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectAvoid";
  }
  protected:
  explicit ObjectAvoid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectAvoid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectStatus) */ {
 public:
  inline ObjectStatus() : ObjectStatus(nullptr) {}
  ~ObjectStatus() override;
  explicit constexpr ObjectStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectStatus(const ObjectStatus& from);
  ObjectStatus(ObjectStatus&& from) noexcept
    : ObjectStatus() {
    *this = ::std::move(from);
  }

  inline ObjectStatus& operator=(const ObjectStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectStatus& operator=(ObjectStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectStatus* internal_default_instance() {
    return reinterpret_cast<const ObjectStatus*>(
               &_ObjectStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ObjectStatus& a, ObjectStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectStatus";
  }
  protected:
  explicit ObjectStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotionTypeFieldNumber = 1,
    kDecisionTypeFieldNumber = 2,
  };
  // .autoagric.planning.ObjectMotionType motion_type = 1;
  bool has_motion_type() const;
  private:
  bool _internal_has_motion_type() const;
  public:
  void clear_motion_type();
  const ::autoagric::planning::ObjectMotionType& motion_type() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectMotionType* release_motion_type();
  ::autoagric::planning::ObjectMotionType* mutable_motion_type();
  void set_allocated_motion_type(::autoagric::planning::ObjectMotionType* motion_type);
  private:
  const ::autoagric::planning::ObjectMotionType& _internal_motion_type() const;
  ::autoagric::planning::ObjectMotionType* _internal_mutable_motion_type();
  public:
  void unsafe_arena_set_allocated_motion_type(
      ::autoagric::planning::ObjectMotionType* motion_type);
  ::autoagric::planning::ObjectMotionType* unsafe_arena_release_motion_type();

  // .autoagric.planning.ObjectDecisionType decision_type = 2;
  bool has_decision_type() const;
  private:
  bool _internal_has_decision_type() const;
  public:
  void clear_decision_type();
  const ::autoagric::planning::ObjectDecisionType& decision_type() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectDecisionType* release_decision_type();
  ::autoagric::planning::ObjectDecisionType* mutable_decision_type();
  void set_allocated_decision_type(::autoagric::planning::ObjectDecisionType* decision_type);
  private:
  const ::autoagric::planning::ObjectDecisionType& _internal_decision_type() const;
  ::autoagric::planning::ObjectDecisionType* _internal_mutable_decision_type();
  public:
  void unsafe_arena_set_allocated_decision_type(
      ::autoagric::planning::ObjectDecisionType* decision_type);
  ::autoagric::planning::ObjectDecisionType* unsafe_arena_release_decision_type();

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::autoagric::planning::ObjectMotionType* motion_type_;
  ::autoagric::planning::ObjectDecisionType* decision_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectStatic final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectStatic) */ {
 public:
  inline ObjectStatic() : ObjectStatic(nullptr) {}
  explicit constexpr ObjectStatic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectStatic(const ObjectStatic& from);
  ObjectStatic(ObjectStatic&& from) noexcept
    : ObjectStatic() {
    *this = ::std::move(from);
  }

  inline ObjectStatic& operator=(const ObjectStatic& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectStatic& operator=(ObjectStatic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectStatic& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectStatic* internal_default_instance() {
    return reinterpret_cast<const ObjectStatic*>(
               &_ObjectStatic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ObjectStatic& a, ObjectStatic& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectStatic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectStatic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectStatic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectStatic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ObjectStatic& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ObjectStatic& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectStatic";
  }
  protected:
  explicit ObjectStatic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectStatic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDynamic final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectDynamic) */ {
 public:
  inline ObjectDynamic() : ObjectDynamic(nullptr) {}
  explicit constexpr ObjectDynamic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectDynamic(const ObjectDynamic& from);
  ObjectDynamic(ObjectDynamic&& from) noexcept
    : ObjectDynamic() {
    *this = ::std::move(from);
  }

  inline ObjectDynamic& operator=(const ObjectDynamic& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDynamic& operator=(ObjectDynamic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectDynamic& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectDynamic* internal_default_instance() {
    return reinterpret_cast<const ObjectDynamic*>(
               &_ObjectDynamic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ObjectDynamic& a, ObjectDynamic& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectDynamic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDynamic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectDynamic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectDynamic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ObjectDynamic& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ObjectDynamic& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectDynamic";
  }
  protected:
  explicit ObjectDynamic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectDynamic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectMotionType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectMotionType) */ {
 public:
  inline ObjectMotionType() : ObjectMotionType(nullptr) {}
  ~ObjectMotionType() override;
  explicit constexpr ObjectMotionType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectMotionType(const ObjectMotionType& from);
  ObjectMotionType(ObjectMotionType&& from) noexcept
    : ObjectMotionType() {
    *this = ::std::move(from);
  }

  inline ObjectMotionType& operator=(const ObjectMotionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectMotionType& operator=(ObjectMotionType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectMotionType& default_instance() {
    return *internal_default_instance();
  }
  enum MotionTagCase {
    kStatic = 1,
    kDynamic = 2,
    MOTION_TAG_NOT_SET = 0,
  };

  static inline const ObjectMotionType* internal_default_instance() {
    return reinterpret_cast<const ObjectMotionType*>(
               &_ObjectMotionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ObjectMotionType& a, ObjectMotionType& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectMotionType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectMotionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectMotionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectMotionType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectMotionType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectMotionType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectMotionType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectMotionType";
  }
  protected:
  explicit ObjectMotionType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStaticFieldNumber = 1,
    kDynamicFieldNumber = 2,
  };
  // .autoagric.planning.ObjectStatic static = 1;
  bool has_static_() const;
  private:
  bool _internal_has_static_() const;
  public:
  void clear_static_();
  const ::autoagric::planning::ObjectStatic& static_() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectStatic* release_static_();
  ::autoagric::planning::ObjectStatic* mutable_static_();
  void set_allocated_static_(::autoagric::planning::ObjectStatic* static_);
  private:
  const ::autoagric::planning::ObjectStatic& _internal_static_() const;
  ::autoagric::planning::ObjectStatic* _internal_mutable_static_();
  public:
  void unsafe_arena_set_allocated_static_(
      ::autoagric::planning::ObjectStatic* static_);
  ::autoagric::planning::ObjectStatic* unsafe_arena_release_static_();

  // .autoagric.planning.ObjectDynamic dynamic = 2;
  bool has_dynamic() const;
  private:
  bool _internal_has_dynamic() const;
  public:
  void clear_dynamic();
  const ::autoagric::planning::ObjectDynamic& dynamic() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectDynamic* release_dynamic();
  ::autoagric::planning::ObjectDynamic* mutable_dynamic();
  void set_allocated_dynamic(::autoagric::planning::ObjectDynamic* dynamic);
  private:
  const ::autoagric::planning::ObjectDynamic& _internal_dynamic() const;
  ::autoagric::planning::ObjectDynamic* _internal_mutable_dynamic();
  public:
  void unsafe_arena_set_allocated_dynamic(
      ::autoagric::planning::ObjectDynamic* dynamic);
  ::autoagric::planning::ObjectDynamic* unsafe_arena_release_dynamic();

  void clear_motion_tag();
  MotionTagCase motion_tag_case() const;
  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectMotionType)
 private:
  class _Internal;
  void set_has_static_();
  void set_has_dynamic();

  inline bool has_motion_tag() const;
  inline void clear_has_motion_tag();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MotionTagUnion {
    constexpr MotionTagUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autoagric::planning::ObjectStatic* static__;
    ::autoagric::planning::ObjectDynamic* dynamic_;
  } motion_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDecisionType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectDecisionType) */ {
 public:
  inline ObjectDecisionType() : ObjectDecisionType(nullptr) {}
  ~ObjectDecisionType() override;
  explicit constexpr ObjectDecisionType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectDecisionType(const ObjectDecisionType& from);
  ObjectDecisionType(ObjectDecisionType&& from) noexcept
    : ObjectDecisionType() {
    *this = ::std::move(from);
  }

  inline ObjectDecisionType& operator=(const ObjectDecisionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDecisionType& operator=(ObjectDecisionType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectDecisionType& default_instance() {
    return *internal_default_instance();
  }
  enum ObjectTagCase {
    kIgnore = 1,
    kStop = 2,
    kFollow = 3,
    kYield = 4,
    kOvertake = 5,
    kNudge = 6,
    kAvoid = 7,
    kSidePass = 8,
    OBJECT_TAG_NOT_SET = 0,
  };

  static inline const ObjectDecisionType* internal_default_instance() {
    return reinterpret_cast<const ObjectDecisionType*>(
               &_ObjectDecisionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ObjectDecisionType& a, ObjectDecisionType& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectDecisionType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDecisionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectDecisionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectDecisionType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectDecisionType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectDecisionType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectDecisionType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectDecisionType";
  }
  protected:
  explicit ObjectDecisionType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIgnoreFieldNumber = 1,
    kStopFieldNumber = 2,
    kFollowFieldNumber = 3,
    kYieldFieldNumber = 4,
    kOvertakeFieldNumber = 5,
    kNudgeFieldNumber = 6,
    kAvoidFieldNumber = 7,
    kSidePassFieldNumber = 8,
  };
  // .autoagric.planning.ObjectIgnore ignore = 1;
  bool has_ignore() const;
  private:
  bool _internal_has_ignore() const;
  public:
  void clear_ignore();
  const ::autoagric::planning::ObjectIgnore& ignore() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectIgnore* release_ignore();
  ::autoagric::planning::ObjectIgnore* mutable_ignore();
  void set_allocated_ignore(::autoagric::planning::ObjectIgnore* ignore);
  private:
  const ::autoagric::planning::ObjectIgnore& _internal_ignore() const;
  ::autoagric::planning::ObjectIgnore* _internal_mutable_ignore();
  public:
  void unsafe_arena_set_allocated_ignore(
      ::autoagric::planning::ObjectIgnore* ignore);
  ::autoagric::planning::ObjectIgnore* unsafe_arena_release_ignore();

  // .autoagric.planning.ObjectStop stop = 2;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;
  public:
  void clear_stop();
  const ::autoagric::planning::ObjectStop& stop() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectStop* release_stop();
  ::autoagric::planning::ObjectStop* mutable_stop();
  void set_allocated_stop(::autoagric::planning::ObjectStop* stop);
  private:
  const ::autoagric::planning::ObjectStop& _internal_stop() const;
  ::autoagric::planning::ObjectStop* _internal_mutable_stop();
  public:
  void unsafe_arena_set_allocated_stop(
      ::autoagric::planning::ObjectStop* stop);
  ::autoagric::planning::ObjectStop* unsafe_arena_release_stop();

  // .autoagric.planning.ObjectFollow follow = 3;
  bool has_follow() const;
  private:
  bool _internal_has_follow() const;
  public:
  void clear_follow();
  const ::autoagric::planning::ObjectFollow& follow() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectFollow* release_follow();
  ::autoagric::planning::ObjectFollow* mutable_follow();
  void set_allocated_follow(::autoagric::planning::ObjectFollow* follow);
  private:
  const ::autoagric::planning::ObjectFollow& _internal_follow() const;
  ::autoagric::planning::ObjectFollow* _internal_mutable_follow();
  public:
  void unsafe_arena_set_allocated_follow(
      ::autoagric::planning::ObjectFollow* follow);
  ::autoagric::planning::ObjectFollow* unsafe_arena_release_follow();

  // .autoagric.planning.ObjectYield yield = 4;
  bool has_yield() const;
  private:
  bool _internal_has_yield() const;
  public:
  void clear_yield();
  const ::autoagric::planning::ObjectYield& yield() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectYield* release_yield();
  ::autoagric::planning::ObjectYield* mutable_yield();
  void set_allocated_yield(::autoagric::planning::ObjectYield* yield);
  private:
  const ::autoagric::planning::ObjectYield& _internal_yield() const;
  ::autoagric::planning::ObjectYield* _internal_mutable_yield();
  public:
  void unsafe_arena_set_allocated_yield(
      ::autoagric::planning::ObjectYield* yield);
  ::autoagric::planning::ObjectYield* unsafe_arena_release_yield();

  // .autoagric.planning.ObjectOvertake overtake = 5;
  bool has_overtake() const;
  private:
  bool _internal_has_overtake() const;
  public:
  void clear_overtake();
  const ::autoagric::planning::ObjectOvertake& overtake() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectOvertake* release_overtake();
  ::autoagric::planning::ObjectOvertake* mutable_overtake();
  void set_allocated_overtake(::autoagric::planning::ObjectOvertake* overtake);
  private:
  const ::autoagric::planning::ObjectOvertake& _internal_overtake() const;
  ::autoagric::planning::ObjectOvertake* _internal_mutable_overtake();
  public:
  void unsafe_arena_set_allocated_overtake(
      ::autoagric::planning::ObjectOvertake* overtake);
  ::autoagric::planning::ObjectOvertake* unsafe_arena_release_overtake();

  // .autoagric.planning.ObjectNudge nudge = 6;
  bool has_nudge() const;
  private:
  bool _internal_has_nudge() const;
  public:
  void clear_nudge();
  const ::autoagric::planning::ObjectNudge& nudge() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectNudge* release_nudge();
  ::autoagric::planning::ObjectNudge* mutable_nudge();
  void set_allocated_nudge(::autoagric::planning::ObjectNudge* nudge);
  private:
  const ::autoagric::planning::ObjectNudge& _internal_nudge() const;
  ::autoagric::planning::ObjectNudge* _internal_mutable_nudge();
  public:
  void unsafe_arena_set_allocated_nudge(
      ::autoagric::planning::ObjectNudge* nudge);
  ::autoagric::planning::ObjectNudge* unsafe_arena_release_nudge();

  // .autoagric.planning.ObjectAvoid avoid = 7;
  bool has_avoid() const;
  private:
  bool _internal_has_avoid() const;
  public:
  void clear_avoid();
  const ::autoagric::planning::ObjectAvoid& avoid() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectAvoid* release_avoid();
  ::autoagric::planning::ObjectAvoid* mutable_avoid();
  void set_allocated_avoid(::autoagric::planning::ObjectAvoid* avoid);
  private:
  const ::autoagric::planning::ObjectAvoid& _internal_avoid() const;
  ::autoagric::planning::ObjectAvoid* _internal_mutable_avoid();
  public:
  void unsafe_arena_set_allocated_avoid(
      ::autoagric::planning::ObjectAvoid* avoid);
  ::autoagric::planning::ObjectAvoid* unsafe_arena_release_avoid();

  // .autoagric.planning.ObjectSidePass side_pass = 8;
  bool has_side_pass() const;
  private:
  bool _internal_has_side_pass() const;
  public:
  void clear_side_pass();
  const ::autoagric::planning::ObjectSidePass& side_pass() const;
  PROTOBUF_NODISCARD ::autoagric::planning::ObjectSidePass* release_side_pass();
  ::autoagric::planning::ObjectSidePass* mutable_side_pass();
  void set_allocated_side_pass(::autoagric::planning::ObjectSidePass* side_pass);
  private:
  const ::autoagric::planning::ObjectSidePass& _internal_side_pass() const;
  ::autoagric::planning::ObjectSidePass* _internal_mutable_side_pass();
  public:
  void unsafe_arena_set_allocated_side_pass(
      ::autoagric::planning::ObjectSidePass* side_pass);
  ::autoagric::planning::ObjectSidePass* unsafe_arena_release_side_pass();

  void clear_object_tag();
  ObjectTagCase object_tag_case() const;
  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectDecisionType)
 private:
  class _Internal;
  void set_has_ignore();
  void set_has_stop();
  void set_has_follow();
  void set_has_yield();
  void set_has_overtake();
  void set_has_nudge();
  void set_has_avoid();
  void set_has_side_pass();

  inline bool has_object_tag() const;
  inline void clear_has_object_tag();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ObjectTagUnion {
    constexpr ObjectTagUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autoagric::planning::ObjectIgnore* ignore_;
    ::autoagric::planning::ObjectStop* stop_;
    ::autoagric::planning::ObjectFollow* follow_;
    ::autoagric::planning::ObjectYield* yield_;
    ::autoagric::planning::ObjectOvertake* overtake_;
    ::autoagric::planning::ObjectNudge* nudge_;
    ::autoagric::planning::ObjectAvoid* avoid_;
    ::autoagric::planning::ObjectSidePass* side_pass_;
  } object_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDecision final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectDecision) */ {
 public:
  inline ObjectDecision() : ObjectDecision(nullptr) {}
  ~ObjectDecision() override;
  explicit constexpr ObjectDecision(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectDecision(const ObjectDecision& from);
  ObjectDecision(ObjectDecision&& from) noexcept
    : ObjectDecision() {
    *this = ::std::move(from);
  }

  inline ObjectDecision& operator=(const ObjectDecision& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDecision& operator=(ObjectDecision&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectDecision& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectDecision* internal_default_instance() {
    return reinterpret_cast<const ObjectDecision*>(
               &_ObjectDecision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ObjectDecision& a, ObjectDecision& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectDecision* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDecision* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectDecision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectDecision>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectDecision& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectDecision& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectDecision* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectDecision";
  }
  protected:
  explicit ObjectDecision(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectDecisionFieldNumber = 3,
    kIdFieldNumber = 1,
    kPerceptionIdFieldNumber = 2,
  };
  // repeated .autoagric.planning.ObjectDecisionType object_decision = 3;
  int object_decision_size() const;
  private:
  int _internal_object_decision_size() const;
  public:
  void clear_object_decision();
  ::autoagric::planning::ObjectDecisionType* mutable_object_decision(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::planning::ObjectDecisionType >*
      mutable_object_decision();
  private:
  const ::autoagric::planning::ObjectDecisionType& _internal_object_decision(int index) const;
  ::autoagric::planning::ObjectDecisionType* _internal_add_object_decision();
  public:
  const ::autoagric::planning::ObjectDecisionType& object_decision(int index) const;
  ::autoagric::planning::ObjectDecisionType* add_object_decision();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::planning::ObjectDecisionType >&
      object_decision() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // int32 perception_id = 2;
  void clear_perception_id();
  int32_t perception_id() const;
  void set_perception_id(int32_t value);
  private:
  int32_t _internal_perception_id() const;
  void _internal_set_perception_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectDecision)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::planning::ObjectDecisionType > object_decision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  int32_t perception_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// -------------------------------------------------------------------

class ObjectDecisions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.planning.ObjectDecisions) */ {
 public:
  inline ObjectDecisions() : ObjectDecisions(nullptr) {}
  ~ObjectDecisions() override;
  explicit constexpr ObjectDecisions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectDecisions(const ObjectDecisions& from);
  ObjectDecisions(ObjectDecisions&& from) noexcept
    : ObjectDecisions() {
    *this = ::std::move(from);
  }

  inline ObjectDecisions& operator=(const ObjectDecisions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectDecisions& operator=(ObjectDecisions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectDecisions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectDecisions* internal_default_instance() {
    return reinterpret_cast<const ObjectDecisions*>(
               &_ObjectDecisions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ObjectDecisions& a, ObjectDecisions& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectDecisions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectDecisions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectDecisions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectDecisions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectDecisions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectDecisions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectDecisions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.planning.ObjectDecisions";
  }
  protected:
  explicit ObjectDecisions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecisionFieldNumber = 1,
  };
  // repeated .autoagric.planning.ObjectDecision decision = 1;
  int decision_size() const;
  private:
  int _internal_decision_size() const;
  public:
  void clear_decision();
  ::autoagric::planning::ObjectDecision* mutable_decision(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::planning::ObjectDecision >*
      mutable_decision();
  private:
  const ::autoagric::planning::ObjectDecision& _internal_decision(int index) const;
  ::autoagric::planning::ObjectDecision* _internal_add_decision();
  public:
  const ::autoagric::planning::ObjectDecision& decision(int index) const;
  ::autoagric::planning::ObjectDecision* add_decision();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::planning::ObjectDecision >&
      decision() const;

  // @@protoc_insertion_point(class_scope:autoagric.planning.ObjectDecisions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::planning::ObjectDecision > decision_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fplanning_2fdecision_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TargetLane

// string id = 1;
inline void TargetLane::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TargetLane::id() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.TargetLane.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetLane::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autoagric.planning.TargetLane.id)
}
inline std::string* TargetLane::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.TargetLane.id)
  return _s;
}
inline const std::string& TargetLane::_internal_id() const {
  return id_.Get();
}
inline void TargetLane::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetLane::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetLane::release_id() {
  // @@protoc_insertion_point(field_release:autoagric.planning.TargetLane.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetLane::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.TargetLane.id)
}

// double start_s = 2;
inline void TargetLane::clear_start_s() {
  start_s_ = 0;
}
inline double TargetLane::_internal_start_s() const {
  return start_s_;
}
inline double TargetLane::start_s() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.TargetLane.start_s)
  return _internal_start_s();
}
inline void TargetLane::_internal_set_start_s(double value) {
  
  start_s_ = value;
}
inline void TargetLane::set_start_s(double value) {
  _internal_set_start_s(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.TargetLane.start_s)
}

// double end_s = 3;
inline void TargetLane::clear_end_s() {
  end_s_ = 0;
}
inline double TargetLane::_internal_end_s() const {
  return end_s_;
}
inline double TargetLane::end_s() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.TargetLane.end_s)
  return _internal_end_s();
}
inline void TargetLane::_internal_set_end_s(double value) {
  
  end_s_ = value;
}
inline void TargetLane::set_end_s(double value) {
  _internal_set_end_s(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.TargetLane.end_s)
}

// double speed_limit = 4;
inline void TargetLane::clear_speed_limit() {
  speed_limit_ = 0;
}
inline double TargetLane::_internal_speed_limit() const {
  return speed_limit_;
}
inline double TargetLane::speed_limit() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.TargetLane.speed_limit)
  return _internal_speed_limit();
}
inline void TargetLane::_internal_set_speed_limit(double value) {
  
  speed_limit_ = value;
}
inline void TargetLane::set_speed_limit(double value) {
  _internal_set_speed_limit(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.TargetLane.speed_limit)
}

// -------------------------------------------------------------------

// ObjectIgnore

// -------------------------------------------------------------------

// ObjectStop

// .autoagric.planning.StopReasonCode reason_code = 1;
inline void ObjectStop::clear_reason_code() {
  reason_code_ = 0;
}
inline ::autoagric::planning::StopReasonCode ObjectStop::_internal_reason_code() const {
  return static_cast< ::autoagric::planning::StopReasonCode >(reason_code_);
}
inline ::autoagric::planning::StopReasonCode ObjectStop::reason_code() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectStop.reason_code)
  return _internal_reason_code();
}
inline void ObjectStop::_internal_set_reason_code(::autoagric::planning::StopReasonCode value) {
  
  reason_code_ = value;
}
inline void ObjectStop::set_reason_code(::autoagric::planning::StopReasonCode value) {
  _internal_set_reason_code(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectStop.reason_code)
}

// double distance_s = 2;
inline void ObjectStop::clear_distance_s() {
  distance_s_ = 0;
}
inline double ObjectStop::_internal_distance_s() const {
  return distance_s_;
}
inline double ObjectStop::distance_s() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectStop.distance_s)
  return _internal_distance_s();
}
inline void ObjectStop::_internal_set_distance_s(double value) {
  
  distance_s_ = value;
}
inline void ObjectStop::set_distance_s(double value) {
  _internal_set_distance_s(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectStop.distance_s)
}

// .autoagric.common.PointENU stop_point = 3;
inline bool ObjectStop::_internal_has_stop_point() const {
  return this != internal_default_instance() && stop_point_ != nullptr;
}
inline bool ObjectStop::has_stop_point() const {
  return _internal_has_stop_point();
}
inline const ::autoagric::common::PointENU& ObjectStop::_internal_stop_point() const {
  const ::autoagric::common::PointENU* p = stop_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::PointENU&>(
      ::autoagric::common::_PointENU_default_instance_);
}
inline const ::autoagric::common::PointENU& ObjectStop::stop_point() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectStop.stop_point)
  return _internal_stop_point();
}
inline void ObjectStop::unsafe_arena_set_allocated_stop_point(
    ::autoagric::common::PointENU* stop_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point_);
  }
  stop_point_ = stop_point;
  if (stop_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectStop.stop_point)
}
inline ::autoagric::common::PointENU* ObjectStop::release_stop_point() {
  
  ::autoagric::common::PointENU* temp = stop_point_;
  stop_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::PointENU* ObjectStop::unsafe_arena_release_stop_point() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectStop.stop_point)
  
  ::autoagric::common::PointENU* temp = stop_point_;
  stop_point_ = nullptr;
  return temp;
}
inline ::autoagric::common::PointENU* ObjectStop::_internal_mutable_stop_point() {
  
  if (stop_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::PointENU>(GetArenaForAllocation());
    stop_point_ = p;
  }
  return stop_point_;
}
inline ::autoagric::common::PointENU* ObjectStop::mutable_stop_point() {
  ::autoagric::common::PointENU* _msg = _internal_mutable_stop_point();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectStop.stop_point)
  return _msg;
}
inline void ObjectStop::set_allocated_stop_point(::autoagric::common::PointENU* stop_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point_);
  }
  if (stop_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stop_point));
    if (message_arena != submessage_arena) {
      stop_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop_point, submessage_arena);
    }
    
  } else {
    
  }
  stop_point_ = stop_point;
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectStop.stop_point)
}

// double stop_heading = 4;
inline void ObjectStop::clear_stop_heading() {
  stop_heading_ = 0;
}
inline double ObjectStop::_internal_stop_heading() const {
  return stop_heading_;
}
inline double ObjectStop::stop_heading() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectStop.stop_heading)
  return _internal_stop_heading();
}
inline void ObjectStop::_internal_set_stop_heading(double value) {
  
  stop_heading_ = value;
}
inline void ObjectStop::set_stop_heading(double value) {
  _internal_set_stop_heading(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectStop.stop_heading)
}

// repeated string wait_for_obstacle = 5;
inline int ObjectStop::_internal_wait_for_obstacle_size() const {
  return wait_for_obstacle_.size();
}
inline int ObjectStop::wait_for_obstacle_size() const {
  return _internal_wait_for_obstacle_size();
}
inline void ObjectStop::clear_wait_for_obstacle() {
  wait_for_obstacle_.Clear();
}
inline std::string* ObjectStop::add_wait_for_obstacle() {
  std::string* _s = _internal_add_wait_for_obstacle();
  // @@protoc_insertion_point(field_add_mutable:autoagric.planning.ObjectStop.wait_for_obstacle)
  return _s;
}
inline const std::string& ObjectStop::_internal_wait_for_obstacle(int index) const {
  return wait_for_obstacle_.Get(index);
}
inline const std::string& ObjectStop::wait_for_obstacle(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectStop.wait_for_obstacle)
  return _internal_wait_for_obstacle(index);
}
inline std::string* ObjectStop::mutable_wait_for_obstacle(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectStop.wait_for_obstacle)
  return wait_for_obstacle_.Mutable(index);
}
inline void ObjectStop::set_wait_for_obstacle(int index, const std::string& value) {
  wait_for_obstacle_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::set_wait_for_obstacle(int index, std::string&& value) {
  wait_for_obstacle_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::set_wait_for_obstacle(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wait_for_obstacle_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autoagric.planning.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::set_wait_for_obstacle(int index, const char* value, size_t size) {
  wait_for_obstacle_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autoagric.planning.ObjectStop.wait_for_obstacle)
}
inline std::string* ObjectStop::_internal_add_wait_for_obstacle() {
  return wait_for_obstacle_.Add();
}
inline void ObjectStop::add_wait_for_obstacle(const std::string& value) {
  wait_for_obstacle_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autoagric.planning.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::add_wait_for_obstacle(std::string&& value) {
  wait_for_obstacle_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autoagric.planning.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::add_wait_for_obstacle(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wait_for_obstacle_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autoagric.planning.ObjectStop.wait_for_obstacle)
}
inline void ObjectStop::add_wait_for_obstacle(const char* value, size_t size) {
  wait_for_obstacle_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autoagric.planning.ObjectStop.wait_for_obstacle)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ObjectStop::wait_for_obstacle() const {
  // @@protoc_insertion_point(field_list:autoagric.planning.ObjectStop.wait_for_obstacle)
  return wait_for_obstacle_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ObjectStop::mutable_wait_for_obstacle() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.planning.ObjectStop.wait_for_obstacle)
  return &wait_for_obstacle_;
}

// -------------------------------------------------------------------

// ObjectNudge

// .autoagric.planning.ObjectNudge.Type type = 1;
inline void ObjectNudge::clear_type() {
  type_ = 0;
}
inline ::autoagric::planning::ObjectNudge_Type ObjectNudge::_internal_type() const {
  return static_cast< ::autoagric::planning::ObjectNudge_Type >(type_);
}
inline ::autoagric::planning::ObjectNudge_Type ObjectNudge::type() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectNudge.type)
  return _internal_type();
}
inline void ObjectNudge::_internal_set_type(::autoagric::planning::ObjectNudge_Type value) {
  
  type_ = value;
}
inline void ObjectNudge::set_type(::autoagric::planning::ObjectNudge_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectNudge.type)
}

// double distance_l = 2;
inline void ObjectNudge::clear_distance_l() {
  distance_l_ = 0;
}
inline double ObjectNudge::_internal_distance_l() const {
  return distance_l_;
}
inline double ObjectNudge::distance_l() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectNudge.distance_l)
  return _internal_distance_l();
}
inline void ObjectNudge::_internal_set_distance_l(double value) {
  
  distance_l_ = value;
}
inline void ObjectNudge::set_distance_l(double value) {
  _internal_set_distance_l(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectNudge.distance_l)
}

// -------------------------------------------------------------------

// ObjectYield

// double distance_s = 1;
inline void ObjectYield::clear_distance_s() {
  distance_s_ = 0;
}
inline double ObjectYield::_internal_distance_s() const {
  return distance_s_;
}
inline double ObjectYield::distance_s() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectYield.distance_s)
  return _internal_distance_s();
}
inline void ObjectYield::_internal_set_distance_s(double value) {
  
  distance_s_ = value;
}
inline void ObjectYield::set_distance_s(double value) {
  _internal_set_distance_s(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectYield.distance_s)
}

// .autoagric.common.PointENU fence_point = 2;
inline bool ObjectYield::_internal_has_fence_point() const {
  return this != internal_default_instance() && fence_point_ != nullptr;
}
inline bool ObjectYield::has_fence_point() const {
  return _internal_has_fence_point();
}
inline const ::autoagric::common::PointENU& ObjectYield::_internal_fence_point() const {
  const ::autoagric::common::PointENU* p = fence_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::PointENU&>(
      ::autoagric::common::_PointENU_default_instance_);
}
inline const ::autoagric::common::PointENU& ObjectYield::fence_point() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectYield.fence_point)
  return _internal_fence_point();
}
inline void ObjectYield::unsafe_arena_set_allocated_fence_point(
    ::autoagric::common::PointENU* fence_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  fence_point_ = fence_point;
  if (fence_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectYield.fence_point)
}
inline ::autoagric::common::PointENU* ObjectYield::release_fence_point() {
  
  ::autoagric::common::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::PointENU* ObjectYield::unsafe_arena_release_fence_point() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectYield.fence_point)
  
  ::autoagric::common::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
  return temp;
}
inline ::autoagric::common::PointENU* ObjectYield::_internal_mutable_fence_point() {
  
  if (fence_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::PointENU>(GetArenaForAllocation());
    fence_point_ = p;
  }
  return fence_point_;
}
inline ::autoagric::common::PointENU* ObjectYield::mutable_fence_point() {
  ::autoagric::common::PointENU* _msg = _internal_mutable_fence_point();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectYield.fence_point)
  return _msg;
}
inline void ObjectYield::set_allocated_fence_point(::autoagric::common::PointENU* fence_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  if (fence_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point));
    if (message_arena != submessage_arena) {
      fence_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence_point, submessage_arena);
    }
    
  } else {
    
  }
  fence_point_ = fence_point;
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectYield.fence_point)
}

// double fence_heading = 3;
inline void ObjectYield::clear_fence_heading() {
  fence_heading_ = 0;
}
inline double ObjectYield::_internal_fence_heading() const {
  return fence_heading_;
}
inline double ObjectYield::fence_heading() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectYield.fence_heading)
  return _internal_fence_heading();
}
inline void ObjectYield::_internal_set_fence_heading(double value) {
  
  fence_heading_ = value;
}
inline void ObjectYield::set_fence_heading(double value) {
  _internal_set_fence_heading(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectYield.fence_heading)
}

// double time_buffer = 4;
inline void ObjectYield::clear_time_buffer() {
  time_buffer_ = 0;
}
inline double ObjectYield::_internal_time_buffer() const {
  return time_buffer_;
}
inline double ObjectYield::time_buffer() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectYield.time_buffer)
  return _internal_time_buffer();
}
inline void ObjectYield::_internal_set_time_buffer(double value) {
  
  time_buffer_ = value;
}
inline void ObjectYield::set_time_buffer(double value) {
  _internal_set_time_buffer(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectYield.time_buffer)
}

// -------------------------------------------------------------------

// ObjectFollow

// double distance_s = 1;
inline void ObjectFollow::clear_distance_s() {
  distance_s_ = 0;
}
inline double ObjectFollow::_internal_distance_s() const {
  return distance_s_;
}
inline double ObjectFollow::distance_s() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectFollow.distance_s)
  return _internal_distance_s();
}
inline void ObjectFollow::_internal_set_distance_s(double value) {
  
  distance_s_ = value;
}
inline void ObjectFollow::set_distance_s(double value) {
  _internal_set_distance_s(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectFollow.distance_s)
}

// .autoagric.common.PointENU fence_point = 2;
inline bool ObjectFollow::_internal_has_fence_point() const {
  return this != internal_default_instance() && fence_point_ != nullptr;
}
inline bool ObjectFollow::has_fence_point() const {
  return _internal_has_fence_point();
}
inline const ::autoagric::common::PointENU& ObjectFollow::_internal_fence_point() const {
  const ::autoagric::common::PointENU* p = fence_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::PointENU&>(
      ::autoagric::common::_PointENU_default_instance_);
}
inline const ::autoagric::common::PointENU& ObjectFollow::fence_point() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectFollow.fence_point)
  return _internal_fence_point();
}
inline void ObjectFollow::unsafe_arena_set_allocated_fence_point(
    ::autoagric::common::PointENU* fence_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  fence_point_ = fence_point;
  if (fence_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectFollow.fence_point)
}
inline ::autoagric::common::PointENU* ObjectFollow::release_fence_point() {
  
  ::autoagric::common::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::PointENU* ObjectFollow::unsafe_arena_release_fence_point() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectFollow.fence_point)
  
  ::autoagric::common::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
  return temp;
}
inline ::autoagric::common::PointENU* ObjectFollow::_internal_mutable_fence_point() {
  
  if (fence_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::PointENU>(GetArenaForAllocation());
    fence_point_ = p;
  }
  return fence_point_;
}
inline ::autoagric::common::PointENU* ObjectFollow::mutable_fence_point() {
  ::autoagric::common::PointENU* _msg = _internal_mutable_fence_point();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectFollow.fence_point)
  return _msg;
}
inline void ObjectFollow::set_allocated_fence_point(::autoagric::common::PointENU* fence_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  if (fence_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point));
    if (message_arena != submessage_arena) {
      fence_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence_point, submessage_arena);
    }
    
  } else {
    
  }
  fence_point_ = fence_point;
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectFollow.fence_point)
}

// double fence_heading = 3;
inline void ObjectFollow::clear_fence_heading() {
  fence_heading_ = 0;
}
inline double ObjectFollow::_internal_fence_heading() const {
  return fence_heading_;
}
inline double ObjectFollow::fence_heading() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectFollow.fence_heading)
  return _internal_fence_heading();
}
inline void ObjectFollow::_internal_set_fence_heading(double value) {
  
  fence_heading_ = value;
}
inline void ObjectFollow::set_fence_heading(double value) {
  _internal_set_fence_heading(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectFollow.fence_heading)
}

// -------------------------------------------------------------------

// ObjectOvertake

// double distance_s = 1;
inline void ObjectOvertake::clear_distance_s() {
  distance_s_ = 0;
}
inline double ObjectOvertake::_internal_distance_s() const {
  return distance_s_;
}
inline double ObjectOvertake::distance_s() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectOvertake.distance_s)
  return _internal_distance_s();
}
inline void ObjectOvertake::_internal_set_distance_s(double value) {
  
  distance_s_ = value;
}
inline void ObjectOvertake::set_distance_s(double value) {
  _internal_set_distance_s(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectOvertake.distance_s)
}

// .autoagric.common.PointENU fence_point = 2;
inline bool ObjectOvertake::_internal_has_fence_point() const {
  return this != internal_default_instance() && fence_point_ != nullptr;
}
inline bool ObjectOvertake::has_fence_point() const {
  return _internal_has_fence_point();
}
inline const ::autoagric::common::PointENU& ObjectOvertake::_internal_fence_point() const {
  const ::autoagric::common::PointENU* p = fence_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::PointENU&>(
      ::autoagric::common::_PointENU_default_instance_);
}
inline const ::autoagric::common::PointENU& ObjectOvertake::fence_point() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectOvertake.fence_point)
  return _internal_fence_point();
}
inline void ObjectOvertake::unsafe_arena_set_allocated_fence_point(
    ::autoagric::common::PointENU* fence_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  fence_point_ = fence_point;
  if (fence_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectOvertake.fence_point)
}
inline ::autoagric::common::PointENU* ObjectOvertake::release_fence_point() {
  
  ::autoagric::common::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::PointENU* ObjectOvertake::unsafe_arena_release_fence_point() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectOvertake.fence_point)
  
  ::autoagric::common::PointENU* temp = fence_point_;
  fence_point_ = nullptr;
  return temp;
}
inline ::autoagric::common::PointENU* ObjectOvertake::_internal_mutable_fence_point() {
  
  if (fence_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::PointENU>(GetArenaForAllocation());
    fence_point_ = p;
  }
  return fence_point_;
}
inline ::autoagric::common::PointENU* ObjectOvertake::mutable_fence_point() {
  ::autoagric::common::PointENU* _msg = _internal_mutable_fence_point();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectOvertake.fence_point)
  return _msg;
}
inline void ObjectOvertake::set_allocated_fence_point(::autoagric::common::PointENU* fence_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point_);
  }
  if (fence_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fence_point));
    if (message_arena != submessage_arena) {
      fence_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fence_point, submessage_arena);
    }
    
  } else {
    
  }
  fence_point_ = fence_point;
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectOvertake.fence_point)
}

// double fence_heading = 3;
inline void ObjectOvertake::clear_fence_heading() {
  fence_heading_ = 0;
}
inline double ObjectOvertake::_internal_fence_heading() const {
  return fence_heading_;
}
inline double ObjectOvertake::fence_heading() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectOvertake.fence_heading)
  return _internal_fence_heading();
}
inline void ObjectOvertake::_internal_set_fence_heading(double value) {
  
  fence_heading_ = value;
}
inline void ObjectOvertake::set_fence_heading(double value) {
  _internal_set_fence_heading(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectOvertake.fence_heading)
}

// double time_buffer = 4;
inline void ObjectOvertake::clear_time_buffer() {
  time_buffer_ = 0;
}
inline double ObjectOvertake::_internal_time_buffer() const {
  return time_buffer_;
}
inline double ObjectOvertake::time_buffer() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectOvertake.time_buffer)
  return _internal_time_buffer();
}
inline void ObjectOvertake::_internal_set_time_buffer(double value) {
  
  time_buffer_ = value;
}
inline void ObjectOvertake::set_time_buffer(double value) {
  _internal_set_time_buffer(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectOvertake.time_buffer)
}

// -------------------------------------------------------------------

// ObjectSidePass

// .autoagric.planning.ObjectSidePass.Type type = 1;
inline void ObjectSidePass::clear_type() {
  type_ = 0;
}
inline ::autoagric::planning::ObjectSidePass_Type ObjectSidePass::_internal_type() const {
  return static_cast< ::autoagric::planning::ObjectSidePass_Type >(type_);
}
inline ::autoagric::planning::ObjectSidePass_Type ObjectSidePass::type() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectSidePass.type)
  return _internal_type();
}
inline void ObjectSidePass::_internal_set_type(::autoagric::planning::ObjectSidePass_Type value) {
  
  type_ = value;
}
inline void ObjectSidePass::set_type(::autoagric::planning::ObjectSidePass_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectSidePass.type)
}

// -------------------------------------------------------------------

// ObjectAvoid

// -------------------------------------------------------------------

// ObjectStatus

// .autoagric.planning.ObjectMotionType motion_type = 1;
inline bool ObjectStatus::_internal_has_motion_type() const {
  return this != internal_default_instance() && motion_type_ != nullptr;
}
inline bool ObjectStatus::has_motion_type() const {
  return _internal_has_motion_type();
}
inline void ObjectStatus::clear_motion_type() {
  if (GetArenaForAllocation() == nullptr && motion_type_ != nullptr) {
    delete motion_type_;
  }
  motion_type_ = nullptr;
}
inline const ::autoagric::planning::ObjectMotionType& ObjectStatus::_internal_motion_type() const {
  const ::autoagric::planning::ObjectMotionType* p = motion_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::planning::ObjectMotionType&>(
      ::autoagric::planning::_ObjectMotionType_default_instance_);
}
inline const ::autoagric::planning::ObjectMotionType& ObjectStatus::motion_type() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectStatus.motion_type)
  return _internal_motion_type();
}
inline void ObjectStatus::unsafe_arena_set_allocated_motion_type(
    ::autoagric::planning::ObjectMotionType* motion_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_type_);
  }
  motion_type_ = motion_type;
  if (motion_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectStatus.motion_type)
}
inline ::autoagric::planning::ObjectMotionType* ObjectStatus::release_motion_type() {
  
  ::autoagric::planning::ObjectMotionType* temp = motion_type_;
  motion_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::planning::ObjectMotionType* ObjectStatus::unsafe_arena_release_motion_type() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectStatus.motion_type)
  
  ::autoagric::planning::ObjectMotionType* temp = motion_type_;
  motion_type_ = nullptr;
  return temp;
}
inline ::autoagric::planning::ObjectMotionType* ObjectStatus::_internal_mutable_motion_type() {
  
  if (motion_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::planning::ObjectMotionType>(GetArenaForAllocation());
    motion_type_ = p;
  }
  return motion_type_;
}
inline ::autoagric::planning::ObjectMotionType* ObjectStatus::mutable_motion_type() {
  ::autoagric::planning::ObjectMotionType* _msg = _internal_mutable_motion_type();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectStatus.motion_type)
  return _msg;
}
inline void ObjectStatus::set_allocated_motion_type(::autoagric::planning::ObjectMotionType* motion_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete motion_type_;
  }
  if (motion_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectMotionType>::GetOwningArena(motion_type);
    if (message_arena != submessage_arena) {
      motion_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motion_type, submessage_arena);
    }
    
  } else {
    
  }
  motion_type_ = motion_type;
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectStatus.motion_type)
}

// .autoagric.planning.ObjectDecisionType decision_type = 2;
inline bool ObjectStatus::_internal_has_decision_type() const {
  return this != internal_default_instance() && decision_type_ != nullptr;
}
inline bool ObjectStatus::has_decision_type() const {
  return _internal_has_decision_type();
}
inline void ObjectStatus::clear_decision_type() {
  if (GetArenaForAllocation() == nullptr && decision_type_ != nullptr) {
    delete decision_type_;
  }
  decision_type_ = nullptr;
}
inline const ::autoagric::planning::ObjectDecisionType& ObjectStatus::_internal_decision_type() const {
  const ::autoagric::planning::ObjectDecisionType* p = decision_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::planning::ObjectDecisionType&>(
      ::autoagric::planning::_ObjectDecisionType_default_instance_);
}
inline const ::autoagric::planning::ObjectDecisionType& ObjectStatus::decision_type() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectStatus.decision_type)
  return _internal_decision_type();
}
inline void ObjectStatus::unsafe_arena_set_allocated_decision_type(
    ::autoagric::planning::ObjectDecisionType* decision_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(decision_type_);
  }
  decision_type_ = decision_type;
  if (decision_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectStatus.decision_type)
}
inline ::autoagric::planning::ObjectDecisionType* ObjectStatus::release_decision_type() {
  
  ::autoagric::planning::ObjectDecisionType* temp = decision_type_;
  decision_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::planning::ObjectDecisionType* ObjectStatus::unsafe_arena_release_decision_type() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectStatus.decision_type)
  
  ::autoagric::planning::ObjectDecisionType* temp = decision_type_;
  decision_type_ = nullptr;
  return temp;
}
inline ::autoagric::planning::ObjectDecisionType* ObjectStatus::_internal_mutable_decision_type() {
  
  if (decision_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::planning::ObjectDecisionType>(GetArenaForAllocation());
    decision_type_ = p;
  }
  return decision_type_;
}
inline ::autoagric::planning::ObjectDecisionType* ObjectStatus::mutable_decision_type() {
  ::autoagric::planning::ObjectDecisionType* _msg = _internal_mutable_decision_type();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectStatus.decision_type)
  return _msg;
}
inline void ObjectStatus::set_allocated_decision_type(::autoagric::planning::ObjectDecisionType* decision_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete decision_type_;
  }
  if (decision_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::planning::ObjectDecisionType>::GetOwningArena(decision_type);
    if (message_arena != submessage_arena) {
      decision_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decision_type, submessage_arena);
    }
    
  } else {
    
  }
  decision_type_ = decision_type;
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectStatus.decision_type)
}

// -------------------------------------------------------------------

// ObjectStatic

// -------------------------------------------------------------------

// ObjectDynamic

// -------------------------------------------------------------------

// ObjectMotionType

// .autoagric.planning.ObjectStatic static = 1;
inline bool ObjectMotionType::_internal_has_static_() const {
  return motion_tag_case() == kStatic;
}
inline bool ObjectMotionType::has_static_() const {
  return _internal_has_static_();
}
inline void ObjectMotionType::set_has_static_() {
  _oneof_case_[0] = kStatic;
}
inline void ObjectMotionType::clear_static_() {
  if (_internal_has_static_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete motion_tag_.static__;
    }
    clear_has_motion_tag();
  }
}
inline ::autoagric::planning::ObjectStatic* ObjectMotionType::release_static_() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectMotionType.static)
  if (_internal_has_static_()) {
    clear_has_motion_tag();
      ::autoagric::planning::ObjectStatic* temp = motion_tag_.static__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    motion_tag_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autoagric::planning::ObjectStatic& ObjectMotionType::_internal_static_() const {
  return _internal_has_static_()
      ? *motion_tag_.static__
      : reinterpret_cast< ::autoagric::planning::ObjectStatic&>(::autoagric::planning::_ObjectStatic_default_instance_);
}
inline const ::autoagric::planning::ObjectStatic& ObjectMotionType::static_() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectMotionType.static)
  return _internal_static_();
}
inline ::autoagric::planning::ObjectStatic* ObjectMotionType::unsafe_arena_release_static_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autoagric.planning.ObjectMotionType.static)
  if (_internal_has_static_()) {
    clear_has_motion_tag();
    ::autoagric::planning::ObjectStatic* temp = motion_tag_.static__;
    motion_tag_.static__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectMotionType::unsafe_arena_set_allocated_static_(::autoagric::planning::ObjectStatic* static_) {
  clear_motion_tag();
  if (static_) {
    set_has_static_();
    motion_tag_.static__ = static_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectMotionType.static)
}
inline ::autoagric::planning::ObjectStatic* ObjectMotionType::_internal_mutable_static_() {
  if (!_internal_has_static_()) {
    clear_motion_tag();
    set_has_static_();
    motion_tag_.static__ = CreateMaybeMessage< ::autoagric::planning::ObjectStatic >(GetArenaForAllocation());
  }
  return motion_tag_.static__;
}
inline ::autoagric::planning::ObjectStatic* ObjectMotionType::mutable_static_() {
  ::autoagric::planning::ObjectStatic* _msg = _internal_mutable_static_();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectMotionType.static)
  return _msg;
}

// .autoagric.planning.ObjectDynamic dynamic = 2;
inline bool ObjectMotionType::_internal_has_dynamic() const {
  return motion_tag_case() == kDynamic;
}
inline bool ObjectMotionType::has_dynamic() const {
  return _internal_has_dynamic();
}
inline void ObjectMotionType::set_has_dynamic() {
  _oneof_case_[0] = kDynamic;
}
inline void ObjectMotionType::clear_dynamic() {
  if (_internal_has_dynamic()) {
    if (GetArenaForAllocation() == nullptr) {
      delete motion_tag_.dynamic_;
    }
    clear_has_motion_tag();
  }
}
inline ::autoagric::planning::ObjectDynamic* ObjectMotionType::release_dynamic() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectMotionType.dynamic)
  if (_internal_has_dynamic()) {
    clear_has_motion_tag();
      ::autoagric::planning::ObjectDynamic* temp = motion_tag_.dynamic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    motion_tag_.dynamic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autoagric::planning::ObjectDynamic& ObjectMotionType::_internal_dynamic() const {
  return _internal_has_dynamic()
      ? *motion_tag_.dynamic_
      : reinterpret_cast< ::autoagric::planning::ObjectDynamic&>(::autoagric::planning::_ObjectDynamic_default_instance_);
}
inline const ::autoagric::planning::ObjectDynamic& ObjectMotionType::dynamic() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectMotionType.dynamic)
  return _internal_dynamic();
}
inline ::autoagric::planning::ObjectDynamic* ObjectMotionType::unsafe_arena_release_dynamic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autoagric.planning.ObjectMotionType.dynamic)
  if (_internal_has_dynamic()) {
    clear_has_motion_tag();
    ::autoagric::planning::ObjectDynamic* temp = motion_tag_.dynamic_;
    motion_tag_.dynamic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectMotionType::unsafe_arena_set_allocated_dynamic(::autoagric::planning::ObjectDynamic* dynamic) {
  clear_motion_tag();
  if (dynamic) {
    set_has_dynamic();
    motion_tag_.dynamic_ = dynamic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectMotionType.dynamic)
}
inline ::autoagric::planning::ObjectDynamic* ObjectMotionType::_internal_mutable_dynamic() {
  if (!_internal_has_dynamic()) {
    clear_motion_tag();
    set_has_dynamic();
    motion_tag_.dynamic_ = CreateMaybeMessage< ::autoagric::planning::ObjectDynamic >(GetArenaForAllocation());
  }
  return motion_tag_.dynamic_;
}
inline ::autoagric::planning::ObjectDynamic* ObjectMotionType::mutable_dynamic() {
  ::autoagric::planning::ObjectDynamic* _msg = _internal_mutable_dynamic();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectMotionType.dynamic)
  return _msg;
}

inline bool ObjectMotionType::has_motion_tag() const {
  return motion_tag_case() != MOTION_TAG_NOT_SET;
}
inline void ObjectMotionType::clear_has_motion_tag() {
  _oneof_case_[0] = MOTION_TAG_NOT_SET;
}
inline ObjectMotionType::MotionTagCase ObjectMotionType::motion_tag_case() const {
  return ObjectMotionType::MotionTagCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ObjectDecisionType

// .autoagric.planning.ObjectIgnore ignore = 1;
inline bool ObjectDecisionType::_internal_has_ignore() const {
  return object_tag_case() == kIgnore;
}
inline bool ObjectDecisionType::has_ignore() const {
  return _internal_has_ignore();
}
inline void ObjectDecisionType::set_has_ignore() {
  _oneof_case_[0] = kIgnore;
}
inline void ObjectDecisionType::clear_ignore() {
  if (_internal_has_ignore()) {
    if (GetArenaForAllocation() == nullptr) {
      delete object_tag_.ignore_;
    }
    clear_has_object_tag();
  }
}
inline ::autoagric::planning::ObjectIgnore* ObjectDecisionType::release_ignore() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectDecisionType.ignore)
  if (_internal_has_ignore()) {
    clear_has_object_tag();
      ::autoagric::planning::ObjectIgnore* temp = object_tag_.ignore_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.ignore_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autoagric::planning::ObjectIgnore& ObjectDecisionType::_internal_ignore() const {
  return _internal_has_ignore()
      ? *object_tag_.ignore_
      : reinterpret_cast< ::autoagric::planning::ObjectIgnore&>(::autoagric::planning::_ObjectIgnore_default_instance_);
}
inline const ::autoagric::planning::ObjectIgnore& ObjectDecisionType::ignore() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecisionType.ignore)
  return _internal_ignore();
}
inline ::autoagric::planning::ObjectIgnore* ObjectDecisionType::unsafe_arena_release_ignore() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autoagric.planning.ObjectDecisionType.ignore)
  if (_internal_has_ignore()) {
    clear_has_object_tag();
    ::autoagric::planning::ObjectIgnore* temp = object_tag_.ignore_;
    object_tag_.ignore_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_ignore(::autoagric::planning::ObjectIgnore* ignore) {
  clear_object_tag();
  if (ignore) {
    set_has_ignore();
    object_tag_.ignore_ = ignore;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectDecisionType.ignore)
}
inline ::autoagric::planning::ObjectIgnore* ObjectDecisionType::_internal_mutable_ignore() {
  if (!_internal_has_ignore()) {
    clear_object_tag();
    set_has_ignore();
    object_tag_.ignore_ = CreateMaybeMessage< ::autoagric::planning::ObjectIgnore >(GetArenaForAllocation());
  }
  return object_tag_.ignore_;
}
inline ::autoagric::planning::ObjectIgnore* ObjectDecisionType::mutable_ignore() {
  ::autoagric::planning::ObjectIgnore* _msg = _internal_mutable_ignore();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectDecisionType.ignore)
  return _msg;
}

// .autoagric.planning.ObjectStop stop = 2;
inline bool ObjectDecisionType::_internal_has_stop() const {
  return object_tag_case() == kStop;
}
inline bool ObjectDecisionType::has_stop() const {
  return _internal_has_stop();
}
inline void ObjectDecisionType::set_has_stop() {
  _oneof_case_[0] = kStop;
}
inline void ObjectDecisionType::clear_stop() {
  if (_internal_has_stop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete object_tag_.stop_;
    }
    clear_has_object_tag();
  }
}
inline ::autoagric::planning::ObjectStop* ObjectDecisionType::release_stop() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectDecisionType.stop)
  if (_internal_has_stop()) {
    clear_has_object_tag();
      ::autoagric::planning::ObjectStop* temp = object_tag_.stop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autoagric::planning::ObjectStop& ObjectDecisionType::_internal_stop() const {
  return _internal_has_stop()
      ? *object_tag_.stop_
      : reinterpret_cast< ::autoagric::planning::ObjectStop&>(::autoagric::planning::_ObjectStop_default_instance_);
}
inline const ::autoagric::planning::ObjectStop& ObjectDecisionType::stop() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecisionType.stop)
  return _internal_stop();
}
inline ::autoagric::planning::ObjectStop* ObjectDecisionType::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autoagric.planning.ObjectDecisionType.stop)
  if (_internal_has_stop()) {
    clear_has_object_tag();
    ::autoagric::planning::ObjectStop* temp = object_tag_.stop_;
    object_tag_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_stop(::autoagric::planning::ObjectStop* stop) {
  clear_object_tag();
  if (stop) {
    set_has_stop();
    object_tag_.stop_ = stop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectDecisionType.stop)
}
inline ::autoagric::planning::ObjectStop* ObjectDecisionType::_internal_mutable_stop() {
  if (!_internal_has_stop()) {
    clear_object_tag();
    set_has_stop();
    object_tag_.stop_ = CreateMaybeMessage< ::autoagric::planning::ObjectStop >(GetArenaForAllocation());
  }
  return object_tag_.stop_;
}
inline ::autoagric::planning::ObjectStop* ObjectDecisionType::mutable_stop() {
  ::autoagric::planning::ObjectStop* _msg = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectDecisionType.stop)
  return _msg;
}

// .autoagric.planning.ObjectFollow follow = 3;
inline bool ObjectDecisionType::_internal_has_follow() const {
  return object_tag_case() == kFollow;
}
inline bool ObjectDecisionType::has_follow() const {
  return _internal_has_follow();
}
inline void ObjectDecisionType::set_has_follow() {
  _oneof_case_[0] = kFollow;
}
inline void ObjectDecisionType::clear_follow() {
  if (_internal_has_follow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete object_tag_.follow_;
    }
    clear_has_object_tag();
  }
}
inline ::autoagric::planning::ObjectFollow* ObjectDecisionType::release_follow() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectDecisionType.follow)
  if (_internal_has_follow()) {
    clear_has_object_tag();
      ::autoagric::planning::ObjectFollow* temp = object_tag_.follow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.follow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autoagric::planning::ObjectFollow& ObjectDecisionType::_internal_follow() const {
  return _internal_has_follow()
      ? *object_tag_.follow_
      : reinterpret_cast< ::autoagric::planning::ObjectFollow&>(::autoagric::planning::_ObjectFollow_default_instance_);
}
inline const ::autoagric::planning::ObjectFollow& ObjectDecisionType::follow() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecisionType.follow)
  return _internal_follow();
}
inline ::autoagric::planning::ObjectFollow* ObjectDecisionType::unsafe_arena_release_follow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autoagric.planning.ObjectDecisionType.follow)
  if (_internal_has_follow()) {
    clear_has_object_tag();
    ::autoagric::planning::ObjectFollow* temp = object_tag_.follow_;
    object_tag_.follow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_follow(::autoagric::planning::ObjectFollow* follow) {
  clear_object_tag();
  if (follow) {
    set_has_follow();
    object_tag_.follow_ = follow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectDecisionType.follow)
}
inline ::autoagric::planning::ObjectFollow* ObjectDecisionType::_internal_mutable_follow() {
  if (!_internal_has_follow()) {
    clear_object_tag();
    set_has_follow();
    object_tag_.follow_ = CreateMaybeMessage< ::autoagric::planning::ObjectFollow >(GetArenaForAllocation());
  }
  return object_tag_.follow_;
}
inline ::autoagric::planning::ObjectFollow* ObjectDecisionType::mutable_follow() {
  ::autoagric::planning::ObjectFollow* _msg = _internal_mutable_follow();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectDecisionType.follow)
  return _msg;
}

// .autoagric.planning.ObjectYield yield = 4;
inline bool ObjectDecisionType::_internal_has_yield() const {
  return object_tag_case() == kYield;
}
inline bool ObjectDecisionType::has_yield() const {
  return _internal_has_yield();
}
inline void ObjectDecisionType::set_has_yield() {
  _oneof_case_[0] = kYield;
}
inline void ObjectDecisionType::clear_yield() {
  if (_internal_has_yield()) {
    if (GetArenaForAllocation() == nullptr) {
      delete object_tag_.yield_;
    }
    clear_has_object_tag();
  }
}
inline ::autoagric::planning::ObjectYield* ObjectDecisionType::release_yield() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectDecisionType.yield)
  if (_internal_has_yield()) {
    clear_has_object_tag();
      ::autoagric::planning::ObjectYield* temp = object_tag_.yield_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.yield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autoagric::planning::ObjectYield& ObjectDecisionType::_internal_yield() const {
  return _internal_has_yield()
      ? *object_tag_.yield_
      : reinterpret_cast< ::autoagric::planning::ObjectYield&>(::autoagric::planning::_ObjectYield_default_instance_);
}
inline const ::autoagric::planning::ObjectYield& ObjectDecisionType::yield() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecisionType.yield)
  return _internal_yield();
}
inline ::autoagric::planning::ObjectYield* ObjectDecisionType::unsafe_arena_release_yield() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autoagric.planning.ObjectDecisionType.yield)
  if (_internal_has_yield()) {
    clear_has_object_tag();
    ::autoagric::planning::ObjectYield* temp = object_tag_.yield_;
    object_tag_.yield_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_yield(::autoagric::planning::ObjectYield* yield) {
  clear_object_tag();
  if (yield) {
    set_has_yield();
    object_tag_.yield_ = yield;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectDecisionType.yield)
}
inline ::autoagric::planning::ObjectYield* ObjectDecisionType::_internal_mutable_yield() {
  if (!_internal_has_yield()) {
    clear_object_tag();
    set_has_yield();
    object_tag_.yield_ = CreateMaybeMessage< ::autoagric::planning::ObjectYield >(GetArenaForAllocation());
  }
  return object_tag_.yield_;
}
inline ::autoagric::planning::ObjectYield* ObjectDecisionType::mutable_yield() {
  ::autoagric::planning::ObjectYield* _msg = _internal_mutable_yield();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectDecisionType.yield)
  return _msg;
}

// .autoagric.planning.ObjectOvertake overtake = 5;
inline bool ObjectDecisionType::_internal_has_overtake() const {
  return object_tag_case() == kOvertake;
}
inline bool ObjectDecisionType::has_overtake() const {
  return _internal_has_overtake();
}
inline void ObjectDecisionType::set_has_overtake() {
  _oneof_case_[0] = kOvertake;
}
inline void ObjectDecisionType::clear_overtake() {
  if (_internal_has_overtake()) {
    if (GetArenaForAllocation() == nullptr) {
      delete object_tag_.overtake_;
    }
    clear_has_object_tag();
  }
}
inline ::autoagric::planning::ObjectOvertake* ObjectDecisionType::release_overtake() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectDecisionType.overtake)
  if (_internal_has_overtake()) {
    clear_has_object_tag();
      ::autoagric::planning::ObjectOvertake* temp = object_tag_.overtake_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.overtake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autoagric::planning::ObjectOvertake& ObjectDecisionType::_internal_overtake() const {
  return _internal_has_overtake()
      ? *object_tag_.overtake_
      : reinterpret_cast< ::autoagric::planning::ObjectOvertake&>(::autoagric::planning::_ObjectOvertake_default_instance_);
}
inline const ::autoagric::planning::ObjectOvertake& ObjectDecisionType::overtake() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecisionType.overtake)
  return _internal_overtake();
}
inline ::autoagric::planning::ObjectOvertake* ObjectDecisionType::unsafe_arena_release_overtake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autoagric.planning.ObjectDecisionType.overtake)
  if (_internal_has_overtake()) {
    clear_has_object_tag();
    ::autoagric::planning::ObjectOvertake* temp = object_tag_.overtake_;
    object_tag_.overtake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_overtake(::autoagric::planning::ObjectOvertake* overtake) {
  clear_object_tag();
  if (overtake) {
    set_has_overtake();
    object_tag_.overtake_ = overtake;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectDecisionType.overtake)
}
inline ::autoagric::planning::ObjectOvertake* ObjectDecisionType::_internal_mutable_overtake() {
  if (!_internal_has_overtake()) {
    clear_object_tag();
    set_has_overtake();
    object_tag_.overtake_ = CreateMaybeMessage< ::autoagric::planning::ObjectOvertake >(GetArenaForAllocation());
  }
  return object_tag_.overtake_;
}
inline ::autoagric::planning::ObjectOvertake* ObjectDecisionType::mutable_overtake() {
  ::autoagric::planning::ObjectOvertake* _msg = _internal_mutable_overtake();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectDecisionType.overtake)
  return _msg;
}

// .autoagric.planning.ObjectNudge nudge = 6;
inline bool ObjectDecisionType::_internal_has_nudge() const {
  return object_tag_case() == kNudge;
}
inline bool ObjectDecisionType::has_nudge() const {
  return _internal_has_nudge();
}
inline void ObjectDecisionType::set_has_nudge() {
  _oneof_case_[0] = kNudge;
}
inline void ObjectDecisionType::clear_nudge() {
  if (_internal_has_nudge()) {
    if (GetArenaForAllocation() == nullptr) {
      delete object_tag_.nudge_;
    }
    clear_has_object_tag();
  }
}
inline ::autoagric::planning::ObjectNudge* ObjectDecisionType::release_nudge() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectDecisionType.nudge)
  if (_internal_has_nudge()) {
    clear_has_object_tag();
      ::autoagric::planning::ObjectNudge* temp = object_tag_.nudge_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.nudge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autoagric::planning::ObjectNudge& ObjectDecisionType::_internal_nudge() const {
  return _internal_has_nudge()
      ? *object_tag_.nudge_
      : reinterpret_cast< ::autoagric::planning::ObjectNudge&>(::autoagric::planning::_ObjectNudge_default_instance_);
}
inline const ::autoagric::planning::ObjectNudge& ObjectDecisionType::nudge() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecisionType.nudge)
  return _internal_nudge();
}
inline ::autoagric::planning::ObjectNudge* ObjectDecisionType::unsafe_arena_release_nudge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autoagric.planning.ObjectDecisionType.nudge)
  if (_internal_has_nudge()) {
    clear_has_object_tag();
    ::autoagric::planning::ObjectNudge* temp = object_tag_.nudge_;
    object_tag_.nudge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_nudge(::autoagric::planning::ObjectNudge* nudge) {
  clear_object_tag();
  if (nudge) {
    set_has_nudge();
    object_tag_.nudge_ = nudge;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectDecisionType.nudge)
}
inline ::autoagric::planning::ObjectNudge* ObjectDecisionType::_internal_mutable_nudge() {
  if (!_internal_has_nudge()) {
    clear_object_tag();
    set_has_nudge();
    object_tag_.nudge_ = CreateMaybeMessage< ::autoagric::planning::ObjectNudge >(GetArenaForAllocation());
  }
  return object_tag_.nudge_;
}
inline ::autoagric::planning::ObjectNudge* ObjectDecisionType::mutable_nudge() {
  ::autoagric::planning::ObjectNudge* _msg = _internal_mutable_nudge();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectDecisionType.nudge)
  return _msg;
}

// .autoagric.planning.ObjectAvoid avoid = 7;
inline bool ObjectDecisionType::_internal_has_avoid() const {
  return object_tag_case() == kAvoid;
}
inline bool ObjectDecisionType::has_avoid() const {
  return _internal_has_avoid();
}
inline void ObjectDecisionType::set_has_avoid() {
  _oneof_case_[0] = kAvoid;
}
inline void ObjectDecisionType::clear_avoid() {
  if (_internal_has_avoid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete object_tag_.avoid_;
    }
    clear_has_object_tag();
  }
}
inline ::autoagric::planning::ObjectAvoid* ObjectDecisionType::release_avoid() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectDecisionType.avoid)
  if (_internal_has_avoid()) {
    clear_has_object_tag();
      ::autoagric::planning::ObjectAvoid* temp = object_tag_.avoid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.avoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autoagric::planning::ObjectAvoid& ObjectDecisionType::_internal_avoid() const {
  return _internal_has_avoid()
      ? *object_tag_.avoid_
      : reinterpret_cast< ::autoagric::planning::ObjectAvoid&>(::autoagric::planning::_ObjectAvoid_default_instance_);
}
inline const ::autoagric::planning::ObjectAvoid& ObjectDecisionType::avoid() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecisionType.avoid)
  return _internal_avoid();
}
inline ::autoagric::planning::ObjectAvoid* ObjectDecisionType::unsafe_arena_release_avoid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autoagric.planning.ObjectDecisionType.avoid)
  if (_internal_has_avoid()) {
    clear_has_object_tag();
    ::autoagric::planning::ObjectAvoid* temp = object_tag_.avoid_;
    object_tag_.avoid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_avoid(::autoagric::planning::ObjectAvoid* avoid) {
  clear_object_tag();
  if (avoid) {
    set_has_avoid();
    object_tag_.avoid_ = avoid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectDecisionType.avoid)
}
inline ::autoagric::planning::ObjectAvoid* ObjectDecisionType::_internal_mutable_avoid() {
  if (!_internal_has_avoid()) {
    clear_object_tag();
    set_has_avoid();
    object_tag_.avoid_ = CreateMaybeMessage< ::autoagric::planning::ObjectAvoid >(GetArenaForAllocation());
  }
  return object_tag_.avoid_;
}
inline ::autoagric::planning::ObjectAvoid* ObjectDecisionType::mutable_avoid() {
  ::autoagric::planning::ObjectAvoid* _msg = _internal_mutable_avoid();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectDecisionType.avoid)
  return _msg;
}

// .autoagric.planning.ObjectSidePass side_pass = 8;
inline bool ObjectDecisionType::_internal_has_side_pass() const {
  return object_tag_case() == kSidePass;
}
inline bool ObjectDecisionType::has_side_pass() const {
  return _internal_has_side_pass();
}
inline void ObjectDecisionType::set_has_side_pass() {
  _oneof_case_[0] = kSidePass;
}
inline void ObjectDecisionType::clear_side_pass() {
  if (_internal_has_side_pass()) {
    if (GetArenaForAllocation() == nullptr) {
      delete object_tag_.side_pass_;
    }
    clear_has_object_tag();
  }
}
inline ::autoagric::planning::ObjectSidePass* ObjectDecisionType::release_side_pass() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectDecisionType.side_pass)
  if (_internal_has_side_pass()) {
    clear_has_object_tag();
      ::autoagric::planning::ObjectSidePass* temp = object_tag_.side_pass_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    object_tag_.side_pass_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autoagric::planning::ObjectSidePass& ObjectDecisionType::_internal_side_pass() const {
  return _internal_has_side_pass()
      ? *object_tag_.side_pass_
      : reinterpret_cast< ::autoagric::planning::ObjectSidePass&>(::autoagric::planning::_ObjectSidePass_default_instance_);
}
inline const ::autoagric::planning::ObjectSidePass& ObjectDecisionType::side_pass() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecisionType.side_pass)
  return _internal_side_pass();
}
inline ::autoagric::planning::ObjectSidePass* ObjectDecisionType::unsafe_arena_release_side_pass() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autoagric.planning.ObjectDecisionType.side_pass)
  if (_internal_has_side_pass()) {
    clear_has_object_tag();
    ::autoagric::planning::ObjectSidePass* temp = object_tag_.side_pass_;
    object_tag_.side_pass_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectDecisionType::unsafe_arena_set_allocated_side_pass(::autoagric::planning::ObjectSidePass* side_pass) {
  clear_object_tag();
  if (side_pass) {
    set_has_side_pass();
    object_tag_.side_pass_ = side_pass;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.planning.ObjectDecisionType.side_pass)
}
inline ::autoagric::planning::ObjectSidePass* ObjectDecisionType::_internal_mutable_side_pass() {
  if (!_internal_has_side_pass()) {
    clear_object_tag();
    set_has_side_pass();
    object_tag_.side_pass_ = CreateMaybeMessage< ::autoagric::planning::ObjectSidePass >(GetArenaForAllocation());
  }
  return object_tag_.side_pass_;
}
inline ::autoagric::planning::ObjectSidePass* ObjectDecisionType::mutable_side_pass() {
  ::autoagric::planning::ObjectSidePass* _msg = _internal_mutable_side_pass();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectDecisionType.side_pass)
  return _msg;
}

inline bool ObjectDecisionType::has_object_tag() const {
  return object_tag_case() != OBJECT_TAG_NOT_SET;
}
inline void ObjectDecisionType::clear_has_object_tag() {
  _oneof_case_[0] = OBJECT_TAG_NOT_SET;
}
inline ObjectDecisionType::ObjectTagCase ObjectDecisionType::object_tag_case() const {
  return ObjectDecisionType::ObjectTagCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ObjectDecision

// string id = 1;
inline void ObjectDecision::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ObjectDecision::id() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecision.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectDecision::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectDecision.id)
}
inline std::string* ObjectDecision::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectDecision.id)
  return _s;
}
inline const std::string& ObjectDecision::_internal_id() const {
  return id_.Get();
}
inline void ObjectDecision::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ObjectDecision::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ObjectDecision::release_id() {
  // @@protoc_insertion_point(field_release:autoagric.planning.ObjectDecision.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ObjectDecision::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autoagric.planning.ObjectDecision.id)
}

// int32 perception_id = 2;
inline void ObjectDecision::clear_perception_id() {
  perception_id_ = 0;
}
inline int32_t ObjectDecision::_internal_perception_id() const {
  return perception_id_;
}
inline int32_t ObjectDecision::perception_id() const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecision.perception_id)
  return _internal_perception_id();
}
inline void ObjectDecision::_internal_set_perception_id(int32_t value) {
  
  perception_id_ = value;
}
inline void ObjectDecision::set_perception_id(int32_t value) {
  _internal_set_perception_id(value);
  // @@protoc_insertion_point(field_set:autoagric.planning.ObjectDecision.perception_id)
}

// repeated .autoagric.planning.ObjectDecisionType object_decision = 3;
inline int ObjectDecision::_internal_object_decision_size() const {
  return object_decision_.size();
}
inline int ObjectDecision::object_decision_size() const {
  return _internal_object_decision_size();
}
inline void ObjectDecision::clear_object_decision() {
  object_decision_.Clear();
}
inline ::autoagric::planning::ObjectDecisionType* ObjectDecision::mutable_object_decision(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectDecision.object_decision)
  return object_decision_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::planning::ObjectDecisionType >*
ObjectDecision::mutable_object_decision() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.planning.ObjectDecision.object_decision)
  return &object_decision_;
}
inline const ::autoagric::planning::ObjectDecisionType& ObjectDecision::_internal_object_decision(int index) const {
  return object_decision_.Get(index);
}
inline const ::autoagric::planning::ObjectDecisionType& ObjectDecision::object_decision(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecision.object_decision)
  return _internal_object_decision(index);
}
inline ::autoagric::planning::ObjectDecisionType* ObjectDecision::_internal_add_object_decision() {
  return object_decision_.Add();
}
inline ::autoagric::planning::ObjectDecisionType* ObjectDecision::add_object_decision() {
  ::autoagric::planning::ObjectDecisionType* _add = _internal_add_object_decision();
  // @@protoc_insertion_point(field_add:autoagric.planning.ObjectDecision.object_decision)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::planning::ObjectDecisionType >&
ObjectDecision::object_decision() const {
  // @@protoc_insertion_point(field_list:autoagric.planning.ObjectDecision.object_decision)
  return object_decision_;
}

// -------------------------------------------------------------------

// ObjectDecisions

// repeated .autoagric.planning.ObjectDecision decision = 1;
inline int ObjectDecisions::_internal_decision_size() const {
  return decision_.size();
}
inline int ObjectDecisions::decision_size() const {
  return _internal_decision_size();
}
inline void ObjectDecisions::clear_decision() {
  decision_.Clear();
}
inline ::autoagric::planning::ObjectDecision* ObjectDecisions::mutable_decision(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.planning.ObjectDecisions.decision)
  return decision_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::planning::ObjectDecision >*
ObjectDecisions::mutable_decision() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.planning.ObjectDecisions.decision)
  return &decision_;
}
inline const ::autoagric::planning::ObjectDecision& ObjectDecisions::_internal_decision(int index) const {
  return decision_.Get(index);
}
inline const ::autoagric::planning::ObjectDecision& ObjectDecisions::decision(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.planning.ObjectDecisions.decision)
  return _internal_decision(index);
}
inline ::autoagric::planning::ObjectDecision* ObjectDecisions::_internal_add_decision() {
  return decision_.Add();
}
inline ::autoagric::planning::ObjectDecision* ObjectDecisions::add_decision() {
  ::autoagric::planning::ObjectDecision* _add = _internal_add_decision();
  // @@protoc_insertion_point(field_add:autoagric.planning.ObjectDecisions.decision)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::planning::ObjectDecision >&
ObjectDecisions::decision() const {
  // @@protoc_insertion_point(field_list:autoagric.planning.ObjectDecisions.decision)
  return decision_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace autoagric

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autoagric::planning::ObjectNudge_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autoagric::planning::ObjectNudge_Type>() {
  return ::autoagric::planning::ObjectNudge_Type_descriptor();
}
template <> struct is_proto_enum< ::autoagric::planning::ObjectSidePass_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autoagric::planning::ObjectSidePass_Type>() {
  return ::autoagric::planning::ObjectSidePass_Type_descriptor();
}
template <> struct is_proto_enum< ::autoagric::planning::StopReasonCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autoagric::planning::StopReasonCode>() {
  return ::autoagric::planning::StopReasonCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_autoagric_2fplanning_2fdecision_2eproto
