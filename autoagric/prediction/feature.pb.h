// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: autoagric/prediction/feature.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_autoagric_2fprediction_2ffeature_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_autoagric_2fprediction_2ffeature_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "autoagric/common/pnc_point.pb.h"
#include "autoagric/common/geometry.pb.h"
#include "autoagric/prediction/prediction_point.pb.h"
#include "autoagric/perception/perception_obstacle.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_autoagric_2fprediction_2ffeature_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_autoagric_2fprediction_2ffeature_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_autoagric_2fprediction_2ffeature_2eproto;
namespace autoagric {
namespace prediction {
class Feature;
struct FeatureDefaultTypeInternal;
extern FeatureDefaultTypeInternal _Feature_default_instance_;
class JunctionExit;
struct JunctionExitDefaultTypeInternal;
extern JunctionExitDefaultTypeInternal _JunctionExit_default_instance_;
class JunctionFeature;
struct JunctionFeatureDefaultTypeInternal;
extern JunctionFeatureDefaultTypeInternal _JunctionFeature_default_instance_;
class ObstacleInteractiveTag;
struct ObstacleInteractiveTagDefaultTypeInternal;
extern ObstacleInteractiveTagDefaultTypeInternal _ObstacleInteractiveTag_default_instance_;
class ObstaclePriority;
struct ObstaclePriorityDefaultTypeInternal;
extern ObstaclePriorityDefaultTypeInternal _ObstaclePriority_default_instance_;
class Trajectory;
struct TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
}  // namespace prediction
}  // namespace autoagric
PROTOBUF_NAMESPACE_OPEN
template<> ::autoagric::prediction::Feature* Arena::CreateMaybeMessage<::autoagric::prediction::Feature>(Arena*);
template<> ::autoagric::prediction::JunctionExit* Arena::CreateMaybeMessage<::autoagric::prediction::JunctionExit>(Arena*);
template<> ::autoagric::prediction::JunctionFeature* Arena::CreateMaybeMessage<::autoagric::prediction::JunctionFeature>(Arena*);
template<> ::autoagric::prediction::ObstacleInteractiveTag* Arena::CreateMaybeMessage<::autoagric::prediction::ObstacleInteractiveTag>(Arena*);
template<> ::autoagric::prediction::ObstaclePriority* Arena::CreateMaybeMessage<::autoagric::prediction::ObstaclePriority>(Arena*);
template<> ::autoagric::prediction::Trajectory* Arena::CreateMaybeMessage<::autoagric::prediction::Trajectory>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autoagric {
namespace prediction {

enum ObstaclePriority_Priority : int {
  ObstaclePriority_Priority_UNKNOWN = 0,
  ObstaclePriority_Priority_CAUTION = 1,
  ObstaclePriority_Priority_NORMAL = 2,
  ObstaclePriority_Priority_IGNORE = 3,
  ObstaclePriority_Priority_ObstaclePriority_Priority_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ObstaclePriority_Priority_ObstaclePriority_Priority_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ObstaclePriority_Priority_IsValid(int value);
constexpr ObstaclePriority_Priority ObstaclePriority_Priority_Priority_MIN = ObstaclePriority_Priority_UNKNOWN;
constexpr ObstaclePriority_Priority ObstaclePriority_Priority_Priority_MAX = ObstaclePriority_Priority_IGNORE;
constexpr int ObstaclePriority_Priority_Priority_ARRAYSIZE = ObstaclePriority_Priority_Priority_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObstaclePriority_Priority_descriptor();
template<typename T>
inline const std::string& ObstaclePriority_Priority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObstaclePriority_Priority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObstaclePriority_Priority_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObstaclePriority_Priority_descriptor(), enum_t_value);
}
inline bool ObstaclePriority_Priority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ObstaclePriority_Priority* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObstaclePriority_Priority>(
    ObstaclePriority_Priority_descriptor(), name, value);
}
enum ObstacleInteractiveTag_InteractiveTag : int {
  ObstacleInteractiveTag_InteractiveTag_UNKNOWN = 0,
  ObstacleInteractiveTag_InteractiveTag_INTERACTION = 1,
  ObstacleInteractiveTag_InteractiveTag_NONINTERACTION = 2,
  ObstacleInteractiveTag_InteractiveTag_ObstacleInteractiveTag_InteractiveTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ObstacleInteractiveTag_InteractiveTag_ObstacleInteractiveTag_InteractiveTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ObstacleInteractiveTag_InteractiveTag_IsValid(int value);
constexpr ObstacleInteractiveTag_InteractiveTag ObstacleInteractiveTag_InteractiveTag_InteractiveTag_MIN = ObstacleInteractiveTag_InteractiveTag_UNKNOWN;
constexpr ObstacleInteractiveTag_InteractiveTag ObstacleInteractiveTag_InteractiveTag_InteractiveTag_MAX = ObstacleInteractiveTag_InteractiveTag_NONINTERACTION;
constexpr int ObstacleInteractiveTag_InteractiveTag_InteractiveTag_ARRAYSIZE = ObstacleInteractiveTag_InteractiveTag_InteractiveTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObstacleInteractiveTag_InteractiveTag_descriptor();
template<typename T>
inline const std::string& ObstacleInteractiveTag_InteractiveTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObstacleInteractiveTag_InteractiveTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObstacleInteractiveTag_InteractiveTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObstacleInteractiveTag_InteractiveTag_descriptor(), enum_t_value);
}
inline bool ObstacleInteractiveTag_InteractiveTag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ObstacleInteractiveTag_InteractiveTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObstacleInteractiveTag_InteractiveTag>(
    ObstacleInteractiveTag_InteractiveTag_descriptor(), name, value);
}
// ===================================================================

class JunctionExit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.prediction.JunctionExit) */ {
 public:
  inline JunctionExit() : JunctionExit(nullptr) {}
  ~JunctionExit() override;
  explicit constexpr JunctionExit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JunctionExit(const JunctionExit& from);
  JunctionExit(JunctionExit&& from) noexcept
    : JunctionExit() {
    *this = ::std::move(from);
  }

  inline JunctionExit& operator=(const JunctionExit& from) {
    CopyFrom(from);
    return *this;
  }
  inline JunctionExit& operator=(JunctionExit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JunctionExit& default_instance() {
    return *internal_default_instance();
  }
  static inline const JunctionExit* internal_default_instance() {
    return reinterpret_cast<const JunctionExit*>(
               &_JunctionExit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(JunctionExit& a, JunctionExit& b) {
    a.Swap(&b);
  }
  inline void Swap(JunctionExit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JunctionExit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JunctionExit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JunctionExit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JunctionExit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JunctionExit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JunctionExit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.prediction.JunctionExit";
  }
  protected:
  explicit JunctionExit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExitLaneIdFieldNumber = 1,
    kExitPositionFieldNumber = 2,
    kExitHeadingFieldNumber = 3,
    kExitWidthFieldNumber = 4,
  };
  // string exit_lane_id = 1;
  void clear_exit_lane_id();
  const std::string& exit_lane_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exit_lane_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exit_lane_id();
  PROTOBUF_NODISCARD std::string* release_exit_lane_id();
  void set_allocated_exit_lane_id(std::string* exit_lane_id);
  private:
  const std::string& _internal_exit_lane_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exit_lane_id(const std::string& value);
  std::string* _internal_mutable_exit_lane_id();
  public:

  // .autoagric.common.Point3D exit_position = 2;
  bool has_exit_position() const;
  private:
  bool _internal_has_exit_position() const;
  public:
  void clear_exit_position();
  const ::autoagric::common::Point3D& exit_position() const;
  PROTOBUF_NODISCARD ::autoagric::common::Point3D* release_exit_position();
  ::autoagric::common::Point3D* mutable_exit_position();
  void set_allocated_exit_position(::autoagric::common::Point3D* exit_position);
  private:
  const ::autoagric::common::Point3D& _internal_exit_position() const;
  ::autoagric::common::Point3D* _internal_mutable_exit_position();
  public:
  void unsafe_arena_set_allocated_exit_position(
      ::autoagric::common::Point3D* exit_position);
  ::autoagric::common::Point3D* unsafe_arena_release_exit_position();

  // double exit_heading = 3;
  void clear_exit_heading();
  double exit_heading() const;
  void set_exit_heading(double value);
  private:
  double _internal_exit_heading() const;
  void _internal_set_exit_heading(double value);
  public:

  // double exit_width = 4;
  void clear_exit_width();
  double exit_width() const;
  void set_exit_width(double value);
  private:
  double _internal_exit_width() const;
  void _internal_set_exit_width(double value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.prediction.JunctionExit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exit_lane_id_;
  ::autoagric::common::Point3D* exit_position_;
  double exit_heading_;
  double exit_width_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fprediction_2ffeature_2eproto;
};
// -------------------------------------------------------------------

class JunctionFeature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.prediction.JunctionFeature) */ {
 public:
  inline JunctionFeature() : JunctionFeature(nullptr) {}
  ~JunctionFeature() override;
  explicit constexpr JunctionFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JunctionFeature(const JunctionFeature& from);
  JunctionFeature(JunctionFeature&& from) noexcept
    : JunctionFeature() {
    *this = ::std::move(from);
  }

  inline JunctionFeature& operator=(const JunctionFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline JunctionFeature& operator=(JunctionFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JunctionFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const JunctionFeature* internal_default_instance() {
    return reinterpret_cast<const JunctionFeature*>(
               &_JunctionFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(JunctionFeature& a, JunctionFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(JunctionFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JunctionFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JunctionFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JunctionFeature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JunctionFeature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JunctionFeature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JunctionFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.prediction.JunctionFeature";
  }
  protected:
  explicit JunctionFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJunctionExitFieldNumber = 4,
    kJunctionMlpFeatureFieldNumber = 5,
    kJunctionMlpLabelFieldNumber = 6,
    kJunctionMlpProbabilityFieldNumber = 7,
    kStartLaneIdFieldNumber = 8,
    kJunctionIdFieldNumber = 1,
    kJunctionRangeFieldNumber = 2,
  };
  // repeated .autoagric.prediction.JunctionExit junction_exit = 4;
  int junction_exit_size() const;
  private:
  int _internal_junction_exit_size() const;
  public:
  void clear_junction_exit();
  ::autoagric::prediction::JunctionExit* mutable_junction_exit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::JunctionExit >*
      mutable_junction_exit();
  private:
  const ::autoagric::prediction::JunctionExit& _internal_junction_exit(int index) const;
  ::autoagric::prediction::JunctionExit* _internal_add_junction_exit();
  public:
  const ::autoagric::prediction::JunctionExit& junction_exit(int index) const;
  ::autoagric::prediction::JunctionExit* add_junction_exit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::JunctionExit >&
      junction_exit() const;

  // repeated double junction_mlp_feature = 5;
  int junction_mlp_feature_size() const;
  private:
  int _internal_junction_mlp_feature_size() const;
  public:
  void clear_junction_mlp_feature();
  private:
  double _internal_junction_mlp_feature(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_junction_mlp_feature() const;
  void _internal_add_junction_mlp_feature(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_junction_mlp_feature();
  public:
  double junction_mlp_feature(int index) const;
  void set_junction_mlp_feature(int index, double value);
  void add_junction_mlp_feature(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      junction_mlp_feature() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_junction_mlp_feature();

  // repeated int32 junction_mlp_label = 6;
  int junction_mlp_label_size() const;
  private:
  int _internal_junction_mlp_label_size() const;
  public:
  void clear_junction_mlp_label();
  private:
  int32_t _internal_junction_mlp_label(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_junction_mlp_label() const;
  void _internal_add_junction_mlp_label(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_junction_mlp_label();
  public:
  int32_t junction_mlp_label(int index) const;
  void set_junction_mlp_label(int index, int32_t value);
  void add_junction_mlp_label(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      junction_mlp_label() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_junction_mlp_label();

  // repeated double junction_mlp_probability = 7;
  int junction_mlp_probability_size() const;
  private:
  int _internal_junction_mlp_probability_size() const;
  public:
  void clear_junction_mlp_probability();
  private:
  double _internal_junction_mlp_probability(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_junction_mlp_probability() const;
  void _internal_add_junction_mlp_probability(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_junction_mlp_probability();
  public:
  double junction_mlp_probability(int index) const;
  void set_junction_mlp_probability(int index, double value);
  void add_junction_mlp_probability(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      junction_mlp_probability() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_junction_mlp_probability();

  // repeated string start_lane_id = 8;
  int start_lane_id_size() const;
  private:
  int _internal_start_lane_id_size() const;
  public:
  void clear_start_lane_id();
  const std::string& start_lane_id(int index) const;
  std::string* mutable_start_lane_id(int index);
  void set_start_lane_id(int index, const std::string& value);
  void set_start_lane_id(int index, std::string&& value);
  void set_start_lane_id(int index, const char* value);
  void set_start_lane_id(int index, const char* value, size_t size);
  std::string* add_start_lane_id();
  void add_start_lane_id(const std::string& value);
  void add_start_lane_id(std::string&& value);
  void add_start_lane_id(const char* value);
  void add_start_lane_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& start_lane_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_start_lane_id();
  private:
  const std::string& _internal_start_lane_id(int index) const;
  std::string* _internal_add_start_lane_id();
  public:

  // string junction_id = 1;
  void clear_junction_id();
  const std::string& junction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_junction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_junction_id();
  PROTOBUF_NODISCARD std::string* release_junction_id();
  void set_allocated_junction_id(std::string* junction_id);
  private:
  const std::string& _internal_junction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_junction_id(const std::string& value);
  std::string* _internal_mutable_junction_id();
  public:

  // double junction_range = 2;
  void clear_junction_range();
  double junction_range() const;
  void set_junction_range(double value);
  private:
  double _internal_junction_range() const;
  void _internal_set_junction_range(double value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.prediction.JunctionFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::JunctionExit > junction_exit_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > junction_mlp_feature_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > junction_mlp_label_;
  mutable std::atomic<int> _junction_mlp_label_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > junction_mlp_probability_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> start_lane_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr junction_id_;
  double junction_range_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fprediction_2ffeature_2eproto;
};
// -------------------------------------------------------------------

class ObstaclePriority final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.prediction.ObstaclePriority) */ {
 public:
  inline ObstaclePriority() : ObstaclePriority(nullptr) {}
  ~ObstaclePriority() override;
  explicit constexpr ObstaclePriority(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstaclePriority(const ObstaclePriority& from);
  ObstaclePriority(ObstaclePriority&& from) noexcept
    : ObstaclePriority() {
    *this = ::std::move(from);
  }

  inline ObstaclePriority& operator=(const ObstaclePriority& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstaclePriority& operator=(ObstaclePriority&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstaclePriority& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstaclePriority* internal_default_instance() {
    return reinterpret_cast<const ObstaclePriority*>(
               &_ObstaclePriority_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ObstaclePriority& a, ObstaclePriority& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstaclePriority* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstaclePriority* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstaclePriority* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstaclePriority>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstaclePriority& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstaclePriority& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstaclePriority* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.prediction.ObstaclePriority";
  }
  protected:
  explicit ObstaclePriority(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ObstaclePriority_Priority Priority;
  static constexpr Priority UNKNOWN =
    ObstaclePriority_Priority_UNKNOWN;
  static constexpr Priority CAUTION =
    ObstaclePriority_Priority_CAUTION;
  static constexpr Priority NORMAL =
    ObstaclePriority_Priority_NORMAL;
  static constexpr Priority IGNORE =
    ObstaclePriority_Priority_IGNORE;
  static inline bool Priority_IsValid(int value) {
    return ObstaclePriority_Priority_IsValid(value);
  }
  static constexpr Priority Priority_MIN =
    ObstaclePriority_Priority_Priority_MIN;
  static constexpr Priority Priority_MAX =
    ObstaclePriority_Priority_Priority_MAX;
  static constexpr int Priority_ARRAYSIZE =
    ObstaclePriority_Priority_Priority_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Priority_descriptor() {
    return ObstaclePriority_Priority_descriptor();
  }
  template<typename T>
  static inline const std::string& Priority_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Priority>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Priority_Name.");
    return ObstaclePriority_Priority_Name(enum_t_value);
  }
  static inline bool Priority_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Priority* value) {
    return ObstaclePriority_Priority_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPriorityFieldNumber = 25,
  };
  // .autoagric.prediction.ObstaclePriority.Priority priority = 25;
  void clear_priority();
  ::autoagric::prediction::ObstaclePriority_Priority priority() const;
  void set_priority(::autoagric::prediction::ObstaclePriority_Priority value);
  private:
  ::autoagric::prediction::ObstaclePriority_Priority _internal_priority() const;
  void _internal_set_priority(::autoagric::prediction::ObstaclePriority_Priority value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.prediction.ObstaclePriority)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int priority_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fprediction_2ffeature_2eproto;
};
// -------------------------------------------------------------------

class ObstacleInteractiveTag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.prediction.ObstacleInteractiveTag) */ {
 public:
  inline ObstacleInteractiveTag() : ObstacleInteractiveTag(nullptr) {}
  ~ObstacleInteractiveTag() override;
  explicit constexpr ObstacleInteractiveTag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleInteractiveTag(const ObstacleInteractiveTag& from);
  ObstacleInteractiveTag(ObstacleInteractiveTag&& from) noexcept
    : ObstacleInteractiveTag() {
    *this = ::std::move(from);
  }

  inline ObstacleInteractiveTag& operator=(const ObstacleInteractiveTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleInteractiveTag& operator=(ObstacleInteractiveTag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleInteractiveTag& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleInteractiveTag* internal_default_instance() {
    return reinterpret_cast<const ObstacleInteractiveTag*>(
               &_ObstacleInteractiveTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ObstacleInteractiveTag& a, ObstacleInteractiveTag& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleInteractiveTag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleInteractiveTag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleInteractiveTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleInteractiveTag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleInteractiveTag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleInteractiveTag& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleInteractiveTag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.prediction.ObstacleInteractiveTag";
  }
  protected:
  explicit ObstacleInteractiveTag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ObstacleInteractiveTag_InteractiveTag InteractiveTag;
  static constexpr InteractiveTag UNKNOWN =
    ObstacleInteractiveTag_InteractiveTag_UNKNOWN;
  static constexpr InteractiveTag INTERACTION =
    ObstacleInteractiveTag_InteractiveTag_INTERACTION;
  static constexpr InteractiveTag NONINTERACTION =
    ObstacleInteractiveTag_InteractiveTag_NONINTERACTION;
  static inline bool InteractiveTag_IsValid(int value) {
    return ObstacleInteractiveTag_InteractiveTag_IsValid(value);
  }
  static constexpr InteractiveTag InteractiveTag_MIN =
    ObstacleInteractiveTag_InteractiveTag_InteractiveTag_MIN;
  static constexpr InteractiveTag InteractiveTag_MAX =
    ObstacleInteractiveTag_InteractiveTag_InteractiveTag_MAX;
  static constexpr int InteractiveTag_ARRAYSIZE =
    ObstacleInteractiveTag_InteractiveTag_InteractiveTag_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InteractiveTag_descriptor() {
    return ObstacleInteractiveTag_InteractiveTag_descriptor();
  }
  template<typename T>
  static inline const std::string& InteractiveTag_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InteractiveTag>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InteractiveTag_Name.");
    return ObstacleInteractiveTag_InteractiveTag_Name(enum_t_value);
  }
  static inline bool InteractiveTag_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InteractiveTag* value) {
    return ObstacleInteractiveTag_InteractiveTag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInteractiveTagFieldNumber = 37,
  };
  // .autoagric.prediction.ObstacleInteractiveTag.InteractiveTag interactive_tag = 37;
  void clear_interactive_tag();
  ::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag interactive_tag() const;
  void set_interactive_tag(::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag value);
  private:
  ::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag _internal_interactive_tag() const;
  void _internal_set_interactive_tag(::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.prediction.ObstacleInteractiveTag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int interactive_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fprediction_2ffeature_2eproto;
};
// -------------------------------------------------------------------

class Trajectory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.prediction.Trajectory) */ {
 public:
  inline Trajectory() : Trajectory(nullptr) {}
  ~Trajectory() override;
  explicit constexpr Trajectory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trajectory(const Trajectory& from);
  Trajectory(Trajectory&& from) noexcept
    : Trajectory() {
    *this = ::std::move(from);
  }

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trajectory& operator=(Trajectory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trajectory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trajectory* internal_default_instance() {
    return reinterpret_cast<const Trajectory*>(
               &_Trajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Trajectory& a, Trajectory& b) {
    a.Swap(&b);
  }
  inline void Swap(Trajectory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trajectory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trajectory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trajectory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Trajectory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Trajectory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trajectory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.prediction.Trajectory";
  }
  protected:
  explicit Trajectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryPointFieldNumber = 2,
    kProbabilityFieldNumber = 1,
  };
  // repeated .autoagric.common.TrajectoryPoint trajectory_point = 2;
  int trajectory_point_size() const;
  private:
  int _internal_trajectory_point_size() const;
  public:
  void clear_trajectory_point();
  ::autoagric::common::TrajectoryPoint* mutable_trajectory_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >*
      mutable_trajectory_point();
  private:
  const ::autoagric::common::TrajectoryPoint& _internal_trajectory_point(int index) const;
  ::autoagric::common::TrajectoryPoint* _internal_add_trajectory_point();
  public:
  const ::autoagric::common::TrajectoryPoint& trajectory_point(int index) const;
  ::autoagric::common::TrajectoryPoint* add_trajectory_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >&
      trajectory_point() const;

  // double probability = 1;
  void clear_probability();
  double probability() const;
  void set_probability(double value);
  private:
  double _internal_probability() const;
  void _internal_set_probability(double value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.prediction.Trajectory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint > trajectory_point_;
  double probability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fprediction_2ffeature_2eproto;
};
// -------------------------------------------------------------------

class Feature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:autoagric.prediction.Feature) */ {
 public:
  inline Feature() : Feature(nullptr) {}
  ~Feature() override;
  explicit constexpr Feature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Feature(const Feature& from);
  Feature(Feature&& from) noexcept
    : Feature() {
    *this = ::std::move(from);
  }

  inline Feature& operator=(const Feature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Feature& operator=(Feature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Feature& default_instance() {
    return *internal_default_instance();
  }
  static inline const Feature* internal_default_instance() {
    return reinterpret_cast<const Feature*>(
               &_Feature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Feature& a, Feature& b) {
    a.Swap(&b);
  }
  inline void Swap(Feature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Feature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Feature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Feature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Feature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Feature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Feature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autoagric.prediction.Feature";
  }
  protected:
  explicit Feature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonPointFieldNumber = 30,
    kFutureTrajectoryPointsFieldNumber = 31,
    kShortTermPredictedTrajectoryPointsFieldNumber = 32,
    kPredictedTrajectoryFieldNumber = 33,
    kAdcTrajectoryPointFieldNumber = 34,
    kSurroundingLaneIdFieldNumber = 35,
    kWithinLaneIdFieldNumber = 36,
    kPositionFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kAccelerationFieldNumber = 4,
    kTPositionFieldNumber = 16,
    kTVelocityFieldNumber = 17,
    kTAccelerationFieldNumber = 20,
    kPriorityFieldNumber = 25,
    kJunctionFeatureFieldNumber = 26,
    kFrontPositionFieldNumber = 27,
    kRawVelocityFieldNumber = 28,
    kInteractiveTagFieldNumber = 37,
    kAdcLocalizationFieldNumber = 39,
    kVelocityHeadingFieldNumber = 5,
    kSpeedFieldNumber = 6,
    kAccFieldNumber = 7,
    kThetaFieldNumber = 8,
    kLengthFieldNumber = 9,
    kWidthFieldNumber = 10,
    kHeightFieldNumber = 11,
    kTrackingTimeFieldNumber = 12,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 23,
    kTimestampFieldNumber = 13,
    kTVelocityHeadingFieldNumber = 18,
    kTSpeedFieldNumber = 19,
    kTAccFieldNumber = 21,
    kLabelUpdateTimeDeltaFieldNumber = 24,
    kAdcTimestampFieldNumber = 38,
    kIsStillFieldNumber = 22,
    kIsNearJunctionFieldNumber = 29,
  };
  // repeated .autoagric.common.Point3D polygon_point = 30;
  int polygon_point_size() const;
  private:
  int _internal_polygon_point_size() const;
  public:
  void clear_polygon_point();
  ::autoagric::common::Point3D* mutable_polygon_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::Point3D >*
      mutable_polygon_point();
  private:
  const ::autoagric::common::Point3D& _internal_polygon_point(int index) const;
  ::autoagric::common::Point3D* _internal_add_polygon_point();
  public:
  const ::autoagric::common::Point3D& polygon_point(int index) const;
  ::autoagric::common::Point3D* add_polygon_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::Point3D >&
      polygon_point() const;

  // repeated .autoagric.prediction.PredictionTrajectoryPoint future_trajectory_points = 31;
  int future_trajectory_points_size() const;
  private:
  int _internal_future_trajectory_points_size() const;
  public:
  void clear_future_trajectory_points();
  ::autoagric::prediction::PredictionTrajectoryPoint* mutable_future_trajectory_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::PredictionTrajectoryPoint >*
      mutable_future_trajectory_points();
  private:
  const ::autoagric::prediction::PredictionTrajectoryPoint& _internal_future_trajectory_points(int index) const;
  ::autoagric::prediction::PredictionTrajectoryPoint* _internal_add_future_trajectory_points();
  public:
  const ::autoagric::prediction::PredictionTrajectoryPoint& future_trajectory_points(int index) const;
  ::autoagric::prediction::PredictionTrajectoryPoint* add_future_trajectory_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::PredictionTrajectoryPoint >&
      future_trajectory_points() const;

  // repeated .autoagric.common.TrajectoryPoint short_term_predicted_trajectory_points = 32;
  int short_term_predicted_trajectory_points_size() const;
  private:
  int _internal_short_term_predicted_trajectory_points_size() const;
  public:
  void clear_short_term_predicted_trajectory_points();
  ::autoagric::common::TrajectoryPoint* mutable_short_term_predicted_trajectory_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >*
      mutable_short_term_predicted_trajectory_points();
  private:
  const ::autoagric::common::TrajectoryPoint& _internal_short_term_predicted_trajectory_points(int index) const;
  ::autoagric::common::TrajectoryPoint* _internal_add_short_term_predicted_trajectory_points();
  public:
  const ::autoagric::common::TrajectoryPoint& short_term_predicted_trajectory_points(int index) const;
  ::autoagric::common::TrajectoryPoint* add_short_term_predicted_trajectory_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >&
      short_term_predicted_trajectory_points() const;

  // repeated .autoagric.prediction.Trajectory predicted_trajectory = 33;
  int predicted_trajectory_size() const;
  private:
  int _internal_predicted_trajectory_size() const;
  public:
  void clear_predicted_trajectory();
  ::autoagric::prediction::Trajectory* mutable_predicted_trajectory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::Trajectory >*
      mutable_predicted_trajectory();
  private:
  const ::autoagric::prediction::Trajectory& _internal_predicted_trajectory(int index) const;
  ::autoagric::prediction::Trajectory* _internal_add_predicted_trajectory();
  public:
  const ::autoagric::prediction::Trajectory& predicted_trajectory(int index) const;
  ::autoagric::prediction::Trajectory* add_predicted_trajectory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::Trajectory >&
      predicted_trajectory() const;

  // repeated .autoagric.common.TrajectoryPoint adc_trajectory_point = 34;
  int adc_trajectory_point_size() const;
  private:
  int _internal_adc_trajectory_point_size() const;
  public:
  void clear_adc_trajectory_point();
  ::autoagric::common::TrajectoryPoint* mutable_adc_trajectory_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >*
      mutable_adc_trajectory_point();
  private:
  const ::autoagric::common::TrajectoryPoint& _internal_adc_trajectory_point(int index) const;
  ::autoagric::common::TrajectoryPoint* _internal_add_adc_trajectory_point();
  public:
  const ::autoagric::common::TrajectoryPoint& adc_trajectory_point(int index) const;
  ::autoagric::common::TrajectoryPoint* add_adc_trajectory_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >&
      adc_trajectory_point() const;

  // repeated string surrounding_lane_id = 35;
  int surrounding_lane_id_size() const;
  private:
  int _internal_surrounding_lane_id_size() const;
  public:
  void clear_surrounding_lane_id();
  const std::string& surrounding_lane_id(int index) const;
  std::string* mutable_surrounding_lane_id(int index);
  void set_surrounding_lane_id(int index, const std::string& value);
  void set_surrounding_lane_id(int index, std::string&& value);
  void set_surrounding_lane_id(int index, const char* value);
  void set_surrounding_lane_id(int index, const char* value, size_t size);
  std::string* add_surrounding_lane_id();
  void add_surrounding_lane_id(const std::string& value);
  void add_surrounding_lane_id(std::string&& value);
  void add_surrounding_lane_id(const char* value);
  void add_surrounding_lane_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& surrounding_lane_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_surrounding_lane_id();
  private:
  const std::string& _internal_surrounding_lane_id(int index) const;
  std::string* _internal_add_surrounding_lane_id();
  public:

  // repeated string within_lane_id = 36;
  int within_lane_id_size() const;
  private:
  int _internal_within_lane_id_size() const;
  public:
  void clear_within_lane_id();
  const std::string& within_lane_id(int index) const;
  std::string* mutable_within_lane_id(int index);
  void set_within_lane_id(int index, const std::string& value);
  void set_within_lane_id(int index, std::string&& value);
  void set_within_lane_id(int index, const char* value);
  void set_within_lane_id(int index, const char* value, size_t size);
  std::string* add_within_lane_id();
  void add_within_lane_id(const std::string& value);
  void add_within_lane_id(std::string&& value);
  void add_within_lane_id(const char* value);
  void add_within_lane_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& within_lane_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_within_lane_id();
  private:
  const std::string& _internal_within_lane_id(int index) const;
  std::string* _internal_add_within_lane_id();
  public:

  // .autoagric.common.Point3D position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::autoagric::common::Point3D& position() const;
  PROTOBUF_NODISCARD ::autoagric::common::Point3D* release_position();
  ::autoagric::common::Point3D* mutable_position();
  void set_allocated_position(::autoagric::common::Point3D* position);
  private:
  const ::autoagric::common::Point3D& _internal_position() const;
  ::autoagric::common::Point3D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::autoagric::common::Point3D* position);
  ::autoagric::common::Point3D* unsafe_arena_release_position();

  // .autoagric.common.Point3D velocity = 3;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::autoagric::common::Point3D& velocity() const;
  PROTOBUF_NODISCARD ::autoagric::common::Point3D* release_velocity();
  ::autoagric::common::Point3D* mutable_velocity();
  void set_allocated_velocity(::autoagric::common::Point3D* velocity);
  private:
  const ::autoagric::common::Point3D& _internal_velocity() const;
  ::autoagric::common::Point3D* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::autoagric::common::Point3D* velocity);
  ::autoagric::common::Point3D* unsafe_arena_release_velocity();

  // .autoagric.common.Point3D acceleration = 4;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const ::autoagric::common::Point3D& acceleration() const;
  PROTOBUF_NODISCARD ::autoagric::common::Point3D* release_acceleration();
  ::autoagric::common::Point3D* mutable_acceleration();
  void set_allocated_acceleration(::autoagric::common::Point3D* acceleration);
  private:
  const ::autoagric::common::Point3D& _internal_acceleration() const;
  ::autoagric::common::Point3D* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      ::autoagric::common::Point3D* acceleration);
  ::autoagric::common::Point3D* unsafe_arena_release_acceleration();

  // .autoagric.common.Point3D t_position = 16;
  bool has_t_position() const;
  private:
  bool _internal_has_t_position() const;
  public:
  void clear_t_position();
  const ::autoagric::common::Point3D& t_position() const;
  PROTOBUF_NODISCARD ::autoagric::common::Point3D* release_t_position();
  ::autoagric::common::Point3D* mutable_t_position();
  void set_allocated_t_position(::autoagric::common::Point3D* t_position);
  private:
  const ::autoagric::common::Point3D& _internal_t_position() const;
  ::autoagric::common::Point3D* _internal_mutable_t_position();
  public:
  void unsafe_arena_set_allocated_t_position(
      ::autoagric::common::Point3D* t_position);
  ::autoagric::common::Point3D* unsafe_arena_release_t_position();

  // .autoagric.common.Point3D t_velocity = 17;
  bool has_t_velocity() const;
  private:
  bool _internal_has_t_velocity() const;
  public:
  void clear_t_velocity();
  const ::autoagric::common::Point3D& t_velocity() const;
  PROTOBUF_NODISCARD ::autoagric::common::Point3D* release_t_velocity();
  ::autoagric::common::Point3D* mutable_t_velocity();
  void set_allocated_t_velocity(::autoagric::common::Point3D* t_velocity);
  private:
  const ::autoagric::common::Point3D& _internal_t_velocity() const;
  ::autoagric::common::Point3D* _internal_mutable_t_velocity();
  public:
  void unsafe_arena_set_allocated_t_velocity(
      ::autoagric::common::Point3D* t_velocity);
  ::autoagric::common::Point3D* unsafe_arena_release_t_velocity();

  // .autoagric.common.Point3D t_acceleration = 20;
  bool has_t_acceleration() const;
  private:
  bool _internal_has_t_acceleration() const;
  public:
  void clear_t_acceleration();
  const ::autoagric::common::Point3D& t_acceleration() const;
  PROTOBUF_NODISCARD ::autoagric::common::Point3D* release_t_acceleration();
  ::autoagric::common::Point3D* mutable_t_acceleration();
  void set_allocated_t_acceleration(::autoagric::common::Point3D* t_acceleration);
  private:
  const ::autoagric::common::Point3D& _internal_t_acceleration() const;
  ::autoagric::common::Point3D* _internal_mutable_t_acceleration();
  public:
  void unsafe_arena_set_allocated_t_acceleration(
      ::autoagric::common::Point3D* t_acceleration);
  ::autoagric::common::Point3D* unsafe_arena_release_t_acceleration();

  // .autoagric.prediction.ObstaclePriority priority = 25;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  const ::autoagric::prediction::ObstaclePriority& priority() const;
  PROTOBUF_NODISCARD ::autoagric::prediction::ObstaclePriority* release_priority();
  ::autoagric::prediction::ObstaclePriority* mutable_priority();
  void set_allocated_priority(::autoagric::prediction::ObstaclePriority* priority);
  private:
  const ::autoagric::prediction::ObstaclePriority& _internal_priority() const;
  ::autoagric::prediction::ObstaclePriority* _internal_mutable_priority();
  public:
  void unsafe_arena_set_allocated_priority(
      ::autoagric::prediction::ObstaclePriority* priority);
  ::autoagric::prediction::ObstaclePriority* unsafe_arena_release_priority();

  // .autoagric.prediction.JunctionFeature junction_feature = 26;
  bool has_junction_feature() const;
  private:
  bool _internal_has_junction_feature() const;
  public:
  void clear_junction_feature();
  const ::autoagric::prediction::JunctionFeature& junction_feature() const;
  PROTOBUF_NODISCARD ::autoagric::prediction::JunctionFeature* release_junction_feature();
  ::autoagric::prediction::JunctionFeature* mutable_junction_feature();
  void set_allocated_junction_feature(::autoagric::prediction::JunctionFeature* junction_feature);
  private:
  const ::autoagric::prediction::JunctionFeature& _internal_junction_feature() const;
  ::autoagric::prediction::JunctionFeature* _internal_mutable_junction_feature();
  public:
  void unsafe_arena_set_allocated_junction_feature(
      ::autoagric::prediction::JunctionFeature* junction_feature);
  ::autoagric::prediction::JunctionFeature* unsafe_arena_release_junction_feature();

  // .autoagric.common.Point3D front_position = 27;
  bool has_front_position() const;
  private:
  bool _internal_has_front_position() const;
  public:
  void clear_front_position();
  const ::autoagric::common::Point3D& front_position() const;
  PROTOBUF_NODISCARD ::autoagric::common::Point3D* release_front_position();
  ::autoagric::common::Point3D* mutable_front_position();
  void set_allocated_front_position(::autoagric::common::Point3D* front_position);
  private:
  const ::autoagric::common::Point3D& _internal_front_position() const;
  ::autoagric::common::Point3D* _internal_mutable_front_position();
  public:
  void unsafe_arena_set_allocated_front_position(
      ::autoagric::common::Point3D* front_position);
  ::autoagric::common::Point3D* unsafe_arena_release_front_position();

  // .autoagric.common.Point3D raw_velocity = 28;
  bool has_raw_velocity() const;
  private:
  bool _internal_has_raw_velocity() const;
  public:
  void clear_raw_velocity();
  const ::autoagric::common::Point3D& raw_velocity() const;
  PROTOBUF_NODISCARD ::autoagric::common::Point3D* release_raw_velocity();
  ::autoagric::common::Point3D* mutable_raw_velocity();
  void set_allocated_raw_velocity(::autoagric::common::Point3D* raw_velocity);
  private:
  const ::autoagric::common::Point3D& _internal_raw_velocity() const;
  ::autoagric::common::Point3D* _internal_mutable_raw_velocity();
  public:
  void unsafe_arena_set_allocated_raw_velocity(
      ::autoagric::common::Point3D* raw_velocity);
  ::autoagric::common::Point3D* unsafe_arena_release_raw_velocity();

  // .autoagric.prediction.ObstacleInteractiveTag interactive_tag = 37;
  bool has_interactive_tag() const;
  private:
  bool _internal_has_interactive_tag() const;
  public:
  void clear_interactive_tag();
  const ::autoagric::prediction::ObstacleInteractiveTag& interactive_tag() const;
  PROTOBUF_NODISCARD ::autoagric::prediction::ObstacleInteractiveTag* release_interactive_tag();
  ::autoagric::prediction::ObstacleInteractiveTag* mutable_interactive_tag();
  void set_allocated_interactive_tag(::autoagric::prediction::ObstacleInteractiveTag* interactive_tag);
  private:
  const ::autoagric::prediction::ObstacleInteractiveTag& _internal_interactive_tag() const;
  ::autoagric::prediction::ObstacleInteractiveTag* _internal_mutable_interactive_tag();
  public:
  void unsafe_arena_set_allocated_interactive_tag(
      ::autoagric::prediction::ObstacleInteractiveTag* interactive_tag);
  ::autoagric::prediction::ObstacleInteractiveTag* unsafe_arena_release_interactive_tag();

  // .autoagric.perception.PerceptionObstacle adc_localization = 39;
  bool has_adc_localization() const;
  private:
  bool _internal_has_adc_localization() const;
  public:
  void clear_adc_localization();
  const ::autoagric::perception::PerceptionObstacle& adc_localization() const;
  PROTOBUF_NODISCARD ::autoagric::perception::PerceptionObstacle* release_adc_localization();
  ::autoagric::perception::PerceptionObstacle* mutable_adc_localization();
  void set_allocated_adc_localization(::autoagric::perception::PerceptionObstacle* adc_localization);
  private:
  const ::autoagric::perception::PerceptionObstacle& _internal_adc_localization() const;
  ::autoagric::perception::PerceptionObstacle* _internal_mutable_adc_localization();
  public:
  void unsafe_arena_set_allocated_adc_localization(
      ::autoagric::perception::PerceptionObstacle* adc_localization);
  ::autoagric::perception::PerceptionObstacle* unsafe_arena_release_adc_localization();

  // double velocity_heading = 5;
  void clear_velocity_heading();
  double velocity_heading() const;
  void set_velocity_heading(double value);
  private:
  double _internal_velocity_heading() const;
  void _internal_set_velocity_heading(double value);
  public:

  // double speed = 6;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // double acc = 7;
  void clear_acc();
  double acc() const;
  void set_acc(double value);
  private:
  double _internal_acc() const;
  void _internal_set_acc(double value);
  public:

  // double theta = 8;
  void clear_theta();
  double theta() const;
  void set_theta(double value);
  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);
  public:

  // double length = 9;
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // double width = 10;
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // double height = 11;
  void clear_height();
  double height() const;
  void set_height(double value);
  private:
  double _internal_height() const;
  void _internal_set_height(double value);
  public:

  // double tracking_time = 12;
  void clear_tracking_time();
  double tracking_time() const;
  void set_tracking_time(double value);
  private:
  double _internal_tracking_time() const;
  void _internal_set_tracking_time(double value);
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // .autoagric.perception.PerceptionObstacle.Type type = 23;
  void clear_type();
  ::autoagric::perception::PerceptionObstacle_Type type() const;
  void set_type(::autoagric::perception::PerceptionObstacle_Type value);
  private:
  ::autoagric::perception::PerceptionObstacle_Type _internal_type() const;
  void _internal_set_type(::autoagric::perception::PerceptionObstacle_Type value);
  public:

  // double timestamp = 13;
  void clear_timestamp();
  double timestamp() const;
  void set_timestamp(double value);
  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);
  public:

  // double t_velocity_heading = 18;
  void clear_t_velocity_heading();
  double t_velocity_heading() const;
  void set_t_velocity_heading(double value);
  private:
  double _internal_t_velocity_heading() const;
  void _internal_set_t_velocity_heading(double value);
  public:

  // double t_speed = 19;
  void clear_t_speed();
  double t_speed() const;
  void set_t_speed(double value);
  private:
  double _internal_t_speed() const;
  void _internal_set_t_speed(double value);
  public:

  // double t_acc = 21;
  void clear_t_acc();
  double t_acc() const;
  void set_t_acc(double value);
  private:
  double _internal_t_acc() const;
  void _internal_set_t_acc(double value);
  public:

  // double label_update_time_delta = 24;
  void clear_label_update_time_delta();
  double label_update_time_delta() const;
  void set_label_update_time_delta(double value);
  private:
  double _internal_label_update_time_delta() const;
  void _internal_set_label_update_time_delta(double value);
  public:

  // double adc_timestamp = 38;
  void clear_adc_timestamp();
  double adc_timestamp() const;
  void set_adc_timestamp(double value);
  private:
  double _internal_adc_timestamp() const;
  void _internal_set_adc_timestamp(double value);
  public:

  // bool is_still = 22;
  void clear_is_still();
  bool is_still() const;
  void set_is_still(bool value);
  private:
  bool _internal_is_still() const;
  void _internal_set_is_still(bool value);
  public:

  // bool is_near_junction = 29;
  void clear_is_near_junction();
  bool is_near_junction() const;
  void set_is_near_junction(bool value);
  private:
  bool _internal_is_near_junction() const;
  void _internal_set_is_near_junction(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autoagric.prediction.Feature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::Point3D > polygon_point_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::PredictionTrajectoryPoint > future_trajectory_points_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint > short_term_predicted_trajectory_points_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::Trajectory > predicted_trajectory_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint > adc_trajectory_point_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> surrounding_lane_id_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> within_lane_id_;
  ::autoagric::common::Point3D* position_;
  ::autoagric::common::Point3D* velocity_;
  ::autoagric::common::Point3D* acceleration_;
  ::autoagric::common::Point3D* t_position_;
  ::autoagric::common::Point3D* t_velocity_;
  ::autoagric::common::Point3D* t_acceleration_;
  ::autoagric::prediction::ObstaclePriority* priority_;
  ::autoagric::prediction::JunctionFeature* junction_feature_;
  ::autoagric::common::Point3D* front_position_;
  ::autoagric::common::Point3D* raw_velocity_;
  ::autoagric::prediction::ObstacleInteractiveTag* interactive_tag_;
  ::autoagric::perception::PerceptionObstacle* adc_localization_;
  double velocity_heading_;
  double speed_;
  double acc_;
  double theta_;
  double length_;
  double width_;
  double height_;
  double tracking_time_;
  int32_t id_;
  int type_;
  double timestamp_;
  double t_velocity_heading_;
  double t_speed_;
  double t_acc_;
  double label_update_time_delta_;
  double adc_timestamp_;
  bool is_still_;
  bool is_near_junction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_autoagric_2fprediction_2ffeature_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// JunctionExit

// string exit_lane_id = 1;
inline void JunctionExit::clear_exit_lane_id() {
  exit_lane_id_.ClearToEmpty();
}
inline const std::string& JunctionExit::exit_lane_id() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.JunctionExit.exit_lane_id)
  return _internal_exit_lane_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JunctionExit::set_exit_lane_id(ArgT0&& arg0, ArgT... args) {
 
 exit_lane_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autoagric.prediction.JunctionExit.exit_lane_id)
}
inline std::string* JunctionExit::mutable_exit_lane_id() {
  std::string* _s = _internal_mutable_exit_lane_id();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.JunctionExit.exit_lane_id)
  return _s;
}
inline const std::string& JunctionExit::_internal_exit_lane_id() const {
  return exit_lane_id_.Get();
}
inline void JunctionExit::_internal_set_exit_lane_id(const std::string& value) {
  
  exit_lane_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JunctionExit::_internal_mutable_exit_lane_id() {
  
  return exit_lane_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JunctionExit::release_exit_lane_id() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.JunctionExit.exit_lane_id)
  return exit_lane_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JunctionExit::set_allocated_exit_lane_id(std::string* exit_lane_id) {
  if (exit_lane_id != nullptr) {
    
  } else {
    
  }
  exit_lane_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exit_lane_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (exit_lane_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    exit_lane_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.JunctionExit.exit_lane_id)
}

// .autoagric.common.Point3D exit_position = 2;
inline bool JunctionExit::_internal_has_exit_position() const {
  return this != internal_default_instance() && exit_position_ != nullptr;
}
inline bool JunctionExit::has_exit_position() const {
  return _internal_has_exit_position();
}
inline const ::autoagric::common::Point3D& JunctionExit::_internal_exit_position() const {
  const ::autoagric::common::Point3D* p = exit_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::Point3D&>(
      ::autoagric::common::_Point3D_default_instance_);
}
inline const ::autoagric::common::Point3D& JunctionExit::exit_position() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.JunctionExit.exit_position)
  return _internal_exit_position();
}
inline void JunctionExit::unsafe_arena_set_allocated_exit_position(
    ::autoagric::common::Point3D* exit_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exit_position_);
  }
  exit_position_ = exit_position;
  if (exit_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.JunctionExit.exit_position)
}
inline ::autoagric::common::Point3D* JunctionExit::release_exit_position() {
  
  ::autoagric::common::Point3D* temp = exit_position_;
  exit_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::Point3D* JunctionExit::unsafe_arena_release_exit_position() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.JunctionExit.exit_position)
  
  ::autoagric::common::Point3D* temp = exit_position_;
  exit_position_ = nullptr;
  return temp;
}
inline ::autoagric::common::Point3D* JunctionExit::_internal_mutable_exit_position() {
  
  if (exit_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::Point3D>(GetArenaForAllocation());
    exit_position_ = p;
  }
  return exit_position_;
}
inline ::autoagric::common::Point3D* JunctionExit::mutable_exit_position() {
  ::autoagric::common::Point3D* _msg = _internal_mutable_exit_position();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.JunctionExit.exit_position)
  return _msg;
}
inline void JunctionExit::set_allocated_exit_position(::autoagric::common::Point3D* exit_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(exit_position_);
  }
  if (exit_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exit_position));
    if (message_arena != submessage_arena) {
      exit_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exit_position, submessage_arena);
    }
    
  } else {
    
  }
  exit_position_ = exit_position;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.JunctionExit.exit_position)
}

// double exit_heading = 3;
inline void JunctionExit::clear_exit_heading() {
  exit_heading_ = 0;
}
inline double JunctionExit::_internal_exit_heading() const {
  return exit_heading_;
}
inline double JunctionExit::exit_heading() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.JunctionExit.exit_heading)
  return _internal_exit_heading();
}
inline void JunctionExit::_internal_set_exit_heading(double value) {
  
  exit_heading_ = value;
}
inline void JunctionExit::set_exit_heading(double value) {
  _internal_set_exit_heading(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.JunctionExit.exit_heading)
}

// double exit_width = 4;
inline void JunctionExit::clear_exit_width() {
  exit_width_ = 0;
}
inline double JunctionExit::_internal_exit_width() const {
  return exit_width_;
}
inline double JunctionExit::exit_width() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.JunctionExit.exit_width)
  return _internal_exit_width();
}
inline void JunctionExit::_internal_set_exit_width(double value) {
  
  exit_width_ = value;
}
inline void JunctionExit::set_exit_width(double value) {
  _internal_set_exit_width(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.JunctionExit.exit_width)
}

// -------------------------------------------------------------------

// JunctionFeature

// string junction_id = 1;
inline void JunctionFeature::clear_junction_id() {
  junction_id_.ClearToEmpty();
}
inline const std::string& JunctionFeature::junction_id() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.JunctionFeature.junction_id)
  return _internal_junction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JunctionFeature::set_junction_id(ArgT0&& arg0, ArgT... args) {
 
 junction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autoagric.prediction.JunctionFeature.junction_id)
}
inline std::string* JunctionFeature::mutable_junction_id() {
  std::string* _s = _internal_mutable_junction_id();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.JunctionFeature.junction_id)
  return _s;
}
inline const std::string& JunctionFeature::_internal_junction_id() const {
  return junction_id_.Get();
}
inline void JunctionFeature::_internal_set_junction_id(const std::string& value) {
  
  junction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JunctionFeature::_internal_mutable_junction_id() {
  
  return junction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JunctionFeature::release_junction_id() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.JunctionFeature.junction_id)
  return junction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JunctionFeature::set_allocated_junction_id(std::string* junction_id) {
  if (junction_id != nullptr) {
    
  } else {
    
  }
  junction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), junction_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (junction_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    junction_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.JunctionFeature.junction_id)
}

// double junction_range = 2;
inline void JunctionFeature::clear_junction_range() {
  junction_range_ = 0;
}
inline double JunctionFeature::_internal_junction_range() const {
  return junction_range_;
}
inline double JunctionFeature::junction_range() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.JunctionFeature.junction_range)
  return _internal_junction_range();
}
inline void JunctionFeature::_internal_set_junction_range(double value) {
  
  junction_range_ = value;
}
inline void JunctionFeature::set_junction_range(double value) {
  _internal_set_junction_range(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.JunctionFeature.junction_range)
}

// repeated .autoagric.prediction.JunctionExit junction_exit = 4;
inline int JunctionFeature::_internal_junction_exit_size() const {
  return junction_exit_.size();
}
inline int JunctionFeature::junction_exit_size() const {
  return _internal_junction_exit_size();
}
inline void JunctionFeature::clear_junction_exit() {
  junction_exit_.Clear();
}
inline ::autoagric::prediction::JunctionExit* JunctionFeature::mutable_junction_exit(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.JunctionFeature.junction_exit)
  return junction_exit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::JunctionExit >*
JunctionFeature::mutable_junction_exit() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.JunctionFeature.junction_exit)
  return &junction_exit_;
}
inline const ::autoagric::prediction::JunctionExit& JunctionFeature::_internal_junction_exit(int index) const {
  return junction_exit_.Get(index);
}
inline const ::autoagric::prediction::JunctionExit& JunctionFeature::junction_exit(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.JunctionFeature.junction_exit)
  return _internal_junction_exit(index);
}
inline ::autoagric::prediction::JunctionExit* JunctionFeature::_internal_add_junction_exit() {
  return junction_exit_.Add();
}
inline ::autoagric::prediction::JunctionExit* JunctionFeature::add_junction_exit() {
  ::autoagric::prediction::JunctionExit* _add = _internal_add_junction_exit();
  // @@protoc_insertion_point(field_add:autoagric.prediction.JunctionFeature.junction_exit)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::JunctionExit >&
JunctionFeature::junction_exit() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.JunctionFeature.junction_exit)
  return junction_exit_;
}

// repeated double junction_mlp_feature = 5;
inline int JunctionFeature::_internal_junction_mlp_feature_size() const {
  return junction_mlp_feature_.size();
}
inline int JunctionFeature::junction_mlp_feature_size() const {
  return _internal_junction_mlp_feature_size();
}
inline void JunctionFeature::clear_junction_mlp_feature() {
  junction_mlp_feature_.Clear();
}
inline double JunctionFeature::_internal_junction_mlp_feature(int index) const {
  return junction_mlp_feature_.Get(index);
}
inline double JunctionFeature::junction_mlp_feature(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.JunctionFeature.junction_mlp_feature)
  return _internal_junction_mlp_feature(index);
}
inline void JunctionFeature::set_junction_mlp_feature(int index, double value) {
  junction_mlp_feature_.Set(index, value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.JunctionFeature.junction_mlp_feature)
}
inline void JunctionFeature::_internal_add_junction_mlp_feature(double value) {
  junction_mlp_feature_.Add(value);
}
inline void JunctionFeature::add_junction_mlp_feature(double value) {
  _internal_add_junction_mlp_feature(value);
  // @@protoc_insertion_point(field_add:autoagric.prediction.JunctionFeature.junction_mlp_feature)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
JunctionFeature::_internal_junction_mlp_feature() const {
  return junction_mlp_feature_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
JunctionFeature::junction_mlp_feature() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.JunctionFeature.junction_mlp_feature)
  return _internal_junction_mlp_feature();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
JunctionFeature::_internal_mutable_junction_mlp_feature() {
  return &junction_mlp_feature_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
JunctionFeature::mutable_junction_mlp_feature() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.JunctionFeature.junction_mlp_feature)
  return _internal_mutable_junction_mlp_feature();
}

// repeated int32 junction_mlp_label = 6;
inline int JunctionFeature::_internal_junction_mlp_label_size() const {
  return junction_mlp_label_.size();
}
inline int JunctionFeature::junction_mlp_label_size() const {
  return _internal_junction_mlp_label_size();
}
inline void JunctionFeature::clear_junction_mlp_label() {
  junction_mlp_label_.Clear();
}
inline int32_t JunctionFeature::_internal_junction_mlp_label(int index) const {
  return junction_mlp_label_.Get(index);
}
inline int32_t JunctionFeature::junction_mlp_label(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.JunctionFeature.junction_mlp_label)
  return _internal_junction_mlp_label(index);
}
inline void JunctionFeature::set_junction_mlp_label(int index, int32_t value) {
  junction_mlp_label_.Set(index, value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.JunctionFeature.junction_mlp_label)
}
inline void JunctionFeature::_internal_add_junction_mlp_label(int32_t value) {
  junction_mlp_label_.Add(value);
}
inline void JunctionFeature::add_junction_mlp_label(int32_t value) {
  _internal_add_junction_mlp_label(value);
  // @@protoc_insertion_point(field_add:autoagric.prediction.JunctionFeature.junction_mlp_label)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
JunctionFeature::_internal_junction_mlp_label() const {
  return junction_mlp_label_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
JunctionFeature::junction_mlp_label() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.JunctionFeature.junction_mlp_label)
  return _internal_junction_mlp_label();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
JunctionFeature::_internal_mutable_junction_mlp_label() {
  return &junction_mlp_label_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
JunctionFeature::mutable_junction_mlp_label() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.JunctionFeature.junction_mlp_label)
  return _internal_mutable_junction_mlp_label();
}

// repeated double junction_mlp_probability = 7;
inline int JunctionFeature::_internal_junction_mlp_probability_size() const {
  return junction_mlp_probability_.size();
}
inline int JunctionFeature::junction_mlp_probability_size() const {
  return _internal_junction_mlp_probability_size();
}
inline void JunctionFeature::clear_junction_mlp_probability() {
  junction_mlp_probability_.Clear();
}
inline double JunctionFeature::_internal_junction_mlp_probability(int index) const {
  return junction_mlp_probability_.Get(index);
}
inline double JunctionFeature::junction_mlp_probability(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.JunctionFeature.junction_mlp_probability)
  return _internal_junction_mlp_probability(index);
}
inline void JunctionFeature::set_junction_mlp_probability(int index, double value) {
  junction_mlp_probability_.Set(index, value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.JunctionFeature.junction_mlp_probability)
}
inline void JunctionFeature::_internal_add_junction_mlp_probability(double value) {
  junction_mlp_probability_.Add(value);
}
inline void JunctionFeature::add_junction_mlp_probability(double value) {
  _internal_add_junction_mlp_probability(value);
  // @@protoc_insertion_point(field_add:autoagric.prediction.JunctionFeature.junction_mlp_probability)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
JunctionFeature::_internal_junction_mlp_probability() const {
  return junction_mlp_probability_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
JunctionFeature::junction_mlp_probability() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.JunctionFeature.junction_mlp_probability)
  return _internal_junction_mlp_probability();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
JunctionFeature::_internal_mutable_junction_mlp_probability() {
  return &junction_mlp_probability_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
JunctionFeature::mutable_junction_mlp_probability() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.JunctionFeature.junction_mlp_probability)
  return _internal_mutable_junction_mlp_probability();
}

// repeated string start_lane_id = 8;
inline int JunctionFeature::_internal_start_lane_id_size() const {
  return start_lane_id_.size();
}
inline int JunctionFeature::start_lane_id_size() const {
  return _internal_start_lane_id_size();
}
inline void JunctionFeature::clear_start_lane_id() {
  start_lane_id_.Clear();
}
inline std::string* JunctionFeature::add_start_lane_id() {
  std::string* _s = _internal_add_start_lane_id();
  // @@protoc_insertion_point(field_add_mutable:autoagric.prediction.JunctionFeature.start_lane_id)
  return _s;
}
inline const std::string& JunctionFeature::_internal_start_lane_id(int index) const {
  return start_lane_id_.Get(index);
}
inline const std::string& JunctionFeature::start_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.JunctionFeature.start_lane_id)
  return _internal_start_lane_id(index);
}
inline std::string* JunctionFeature::mutable_start_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.JunctionFeature.start_lane_id)
  return start_lane_id_.Mutable(index);
}
inline void JunctionFeature::set_start_lane_id(int index, const std::string& value) {
  start_lane_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.JunctionFeature.start_lane_id)
}
inline void JunctionFeature::set_start_lane_id(int index, std::string&& value) {
  start_lane_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autoagric.prediction.JunctionFeature.start_lane_id)
}
inline void JunctionFeature::set_start_lane_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  start_lane_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autoagric.prediction.JunctionFeature.start_lane_id)
}
inline void JunctionFeature::set_start_lane_id(int index, const char* value, size_t size) {
  start_lane_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autoagric.prediction.JunctionFeature.start_lane_id)
}
inline std::string* JunctionFeature::_internal_add_start_lane_id() {
  return start_lane_id_.Add();
}
inline void JunctionFeature::add_start_lane_id(const std::string& value) {
  start_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autoagric.prediction.JunctionFeature.start_lane_id)
}
inline void JunctionFeature::add_start_lane_id(std::string&& value) {
  start_lane_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autoagric.prediction.JunctionFeature.start_lane_id)
}
inline void JunctionFeature::add_start_lane_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  start_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autoagric.prediction.JunctionFeature.start_lane_id)
}
inline void JunctionFeature::add_start_lane_id(const char* value, size_t size) {
  start_lane_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autoagric.prediction.JunctionFeature.start_lane_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JunctionFeature::start_lane_id() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.JunctionFeature.start_lane_id)
  return start_lane_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JunctionFeature::mutable_start_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.JunctionFeature.start_lane_id)
  return &start_lane_id_;
}

// -------------------------------------------------------------------

// ObstaclePriority

// .autoagric.prediction.ObstaclePriority.Priority priority = 25;
inline void ObstaclePriority::clear_priority() {
  priority_ = 0;
}
inline ::autoagric::prediction::ObstaclePriority_Priority ObstaclePriority::_internal_priority() const {
  return static_cast< ::autoagric::prediction::ObstaclePriority_Priority >(priority_);
}
inline ::autoagric::prediction::ObstaclePriority_Priority ObstaclePriority::priority() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.ObstaclePriority.priority)
  return _internal_priority();
}
inline void ObstaclePriority::_internal_set_priority(::autoagric::prediction::ObstaclePriority_Priority value) {
  
  priority_ = value;
}
inline void ObstaclePriority::set_priority(::autoagric::prediction::ObstaclePriority_Priority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.ObstaclePriority.priority)
}

// -------------------------------------------------------------------

// ObstacleInteractiveTag

// .autoagric.prediction.ObstacleInteractiveTag.InteractiveTag interactive_tag = 37;
inline void ObstacleInteractiveTag::clear_interactive_tag() {
  interactive_tag_ = 0;
}
inline ::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag ObstacleInteractiveTag::_internal_interactive_tag() const {
  return static_cast< ::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag >(interactive_tag_);
}
inline ::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag ObstacleInteractiveTag::interactive_tag() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.ObstacleInteractiveTag.interactive_tag)
  return _internal_interactive_tag();
}
inline void ObstacleInteractiveTag::_internal_set_interactive_tag(::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag value) {
  
  interactive_tag_ = value;
}
inline void ObstacleInteractiveTag::set_interactive_tag(::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag value) {
  _internal_set_interactive_tag(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.ObstacleInteractiveTag.interactive_tag)
}

// -------------------------------------------------------------------

// Trajectory

// double probability = 1;
inline void Trajectory::clear_probability() {
  probability_ = 0;
}
inline double Trajectory::_internal_probability() const {
  return probability_;
}
inline double Trajectory::probability() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Trajectory.probability)
  return _internal_probability();
}
inline void Trajectory::_internal_set_probability(double value) {
  
  probability_ = value;
}
inline void Trajectory::set_probability(double value) {
  _internal_set_probability(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Trajectory.probability)
}

// repeated .autoagric.common.TrajectoryPoint trajectory_point = 2;
inline int Trajectory::_internal_trajectory_point_size() const {
  return trajectory_point_.size();
}
inline int Trajectory::trajectory_point_size() const {
  return _internal_trajectory_point_size();
}
inline ::autoagric::common::TrajectoryPoint* Trajectory::mutable_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Trajectory.trajectory_point)
  return trajectory_point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >*
Trajectory::mutable_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.Trajectory.trajectory_point)
  return &trajectory_point_;
}
inline const ::autoagric::common::TrajectoryPoint& Trajectory::_internal_trajectory_point(int index) const {
  return trajectory_point_.Get(index);
}
inline const ::autoagric::common::TrajectoryPoint& Trajectory::trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Trajectory.trajectory_point)
  return _internal_trajectory_point(index);
}
inline ::autoagric::common::TrajectoryPoint* Trajectory::_internal_add_trajectory_point() {
  return trajectory_point_.Add();
}
inline ::autoagric::common::TrajectoryPoint* Trajectory::add_trajectory_point() {
  ::autoagric::common::TrajectoryPoint* _add = _internal_add_trajectory_point();
  // @@protoc_insertion_point(field_add:autoagric.prediction.Trajectory.trajectory_point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >&
Trajectory::trajectory_point() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.Trajectory.trajectory_point)
  return trajectory_point_;
}

// -------------------------------------------------------------------

// Feature

// int32 id = 1;
inline void Feature::clear_id() {
  id_ = 0;
}
inline int32_t Feature::_internal_id() const {
  return id_;
}
inline int32_t Feature::id() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.id)
  return _internal_id();
}
inline void Feature::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void Feature::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.id)
}

// repeated .autoagric.common.Point3D polygon_point = 30;
inline int Feature::_internal_polygon_point_size() const {
  return polygon_point_.size();
}
inline int Feature::polygon_point_size() const {
  return _internal_polygon_point_size();
}
inline ::autoagric::common::Point3D* Feature::mutable_polygon_point(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.polygon_point)
  return polygon_point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::Point3D >*
Feature::mutable_polygon_point() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.Feature.polygon_point)
  return &polygon_point_;
}
inline const ::autoagric::common::Point3D& Feature::_internal_polygon_point(int index) const {
  return polygon_point_.Get(index);
}
inline const ::autoagric::common::Point3D& Feature::polygon_point(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.polygon_point)
  return _internal_polygon_point(index);
}
inline ::autoagric::common::Point3D* Feature::_internal_add_polygon_point() {
  return polygon_point_.Add();
}
inline ::autoagric::common::Point3D* Feature::add_polygon_point() {
  ::autoagric::common::Point3D* _add = _internal_add_polygon_point();
  // @@protoc_insertion_point(field_add:autoagric.prediction.Feature.polygon_point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::Point3D >&
Feature::polygon_point() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.Feature.polygon_point)
  return polygon_point_;
}

// .autoagric.common.Point3D position = 2;
inline bool Feature::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool Feature::has_position() const {
  return _internal_has_position();
}
inline const ::autoagric::common::Point3D& Feature::_internal_position() const {
  const ::autoagric::common::Point3D* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::Point3D&>(
      ::autoagric::common::_Point3D_default_instance_);
}
inline const ::autoagric::common::Point3D& Feature::position() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.position)
  return _internal_position();
}
inline void Feature::unsafe_arena_set_allocated_position(
    ::autoagric::common::Point3D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.position)
}
inline ::autoagric::common::Point3D* Feature::release_position() {
  
  ::autoagric::common::Point3D* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::Point3D* Feature::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.position)
  
  ::autoagric::common::Point3D* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::autoagric::common::Point3D* Feature::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::Point3D>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::autoagric::common::Point3D* Feature::mutable_position() {
  ::autoagric::common::Point3D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.position)
  return _msg;
}
inline void Feature::set_allocated_position(::autoagric::common::Point3D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.position)
}

// .autoagric.common.Point3D front_position = 27;
inline bool Feature::_internal_has_front_position() const {
  return this != internal_default_instance() && front_position_ != nullptr;
}
inline bool Feature::has_front_position() const {
  return _internal_has_front_position();
}
inline const ::autoagric::common::Point3D& Feature::_internal_front_position() const {
  const ::autoagric::common::Point3D* p = front_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::Point3D&>(
      ::autoagric::common::_Point3D_default_instance_);
}
inline const ::autoagric::common::Point3D& Feature::front_position() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.front_position)
  return _internal_front_position();
}
inline void Feature::unsafe_arena_set_allocated_front_position(
    ::autoagric::common::Point3D* front_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(front_position_);
  }
  front_position_ = front_position;
  if (front_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.front_position)
}
inline ::autoagric::common::Point3D* Feature::release_front_position() {
  
  ::autoagric::common::Point3D* temp = front_position_;
  front_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::Point3D* Feature::unsafe_arena_release_front_position() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.front_position)
  
  ::autoagric::common::Point3D* temp = front_position_;
  front_position_ = nullptr;
  return temp;
}
inline ::autoagric::common::Point3D* Feature::_internal_mutable_front_position() {
  
  if (front_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::Point3D>(GetArenaForAllocation());
    front_position_ = p;
  }
  return front_position_;
}
inline ::autoagric::common::Point3D* Feature::mutable_front_position() {
  ::autoagric::common::Point3D* _msg = _internal_mutable_front_position();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.front_position)
  return _msg;
}
inline void Feature::set_allocated_front_position(::autoagric::common::Point3D* front_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(front_position_);
  }
  if (front_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(front_position));
    if (message_arena != submessage_arena) {
      front_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, front_position, submessage_arena);
    }
    
  } else {
    
  }
  front_position_ = front_position;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.front_position)
}

// .autoagric.common.Point3D velocity = 3;
inline bool Feature::_internal_has_velocity() const {
  return this != internal_default_instance() && velocity_ != nullptr;
}
inline bool Feature::has_velocity() const {
  return _internal_has_velocity();
}
inline const ::autoagric::common::Point3D& Feature::_internal_velocity() const {
  const ::autoagric::common::Point3D* p = velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::Point3D&>(
      ::autoagric::common::_Point3D_default_instance_);
}
inline const ::autoagric::common::Point3D& Feature::velocity() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.velocity)
  return _internal_velocity();
}
inline void Feature::unsafe_arena_set_allocated_velocity(
    ::autoagric::common::Point3D* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.velocity)
}
inline ::autoagric::common::Point3D* Feature::release_velocity() {
  
  ::autoagric::common::Point3D* temp = velocity_;
  velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::Point3D* Feature::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.velocity)
  
  ::autoagric::common::Point3D* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::autoagric::common::Point3D* Feature::_internal_mutable_velocity() {
  
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::Point3D>(GetArenaForAllocation());
    velocity_ = p;
  }
  return velocity_;
}
inline ::autoagric::common::Point3D* Feature::mutable_velocity() {
  ::autoagric::common::Point3D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.velocity)
  return _msg;
}
inline void Feature::set_allocated_velocity(::autoagric::common::Point3D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity));
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.velocity)
}

// .autoagric.common.Point3D raw_velocity = 28;
inline bool Feature::_internal_has_raw_velocity() const {
  return this != internal_default_instance() && raw_velocity_ != nullptr;
}
inline bool Feature::has_raw_velocity() const {
  return _internal_has_raw_velocity();
}
inline const ::autoagric::common::Point3D& Feature::_internal_raw_velocity() const {
  const ::autoagric::common::Point3D* p = raw_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::Point3D&>(
      ::autoagric::common::_Point3D_default_instance_);
}
inline const ::autoagric::common::Point3D& Feature::raw_velocity() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.raw_velocity)
  return _internal_raw_velocity();
}
inline void Feature::unsafe_arena_set_allocated_raw_velocity(
    ::autoagric::common::Point3D* raw_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_velocity_);
  }
  raw_velocity_ = raw_velocity;
  if (raw_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.raw_velocity)
}
inline ::autoagric::common::Point3D* Feature::release_raw_velocity() {
  
  ::autoagric::common::Point3D* temp = raw_velocity_;
  raw_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::Point3D* Feature::unsafe_arena_release_raw_velocity() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.raw_velocity)
  
  ::autoagric::common::Point3D* temp = raw_velocity_;
  raw_velocity_ = nullptr;
  return temp;
}
inline ::autoagric::common::Point3D* Feature::_internal_mutable_raw_velocity() {
  
  if (raw_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::Point3D>(GetArenaForAllocation());
    raw_velocity_ = p;
  }
  return raw_velocity_;
}
inline ::autoagric::common::Point3D* Feature::mutable_raw_velocity() {
  ::autoagric::common::Point3D* _msg = _internal_mutable_raw_velocity();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.raw_velocity)
  return _msg;
}
inline void Feature::set_allocated_raw_velocity(::autoagric::common::Point3D* raw_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_velocity_);
  }
  if (raw_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_velocity));
    if (message_arena != submessage_arena) {
      raw_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_velocity, submessage_arena);
    }
    
  } else {
    
  }
  raw_velocity_ = raw_velocity;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.raw_velocity)
}

// .autoagric.common.Point3D acceleration = 4;
inline bool Feature::_internal_has_acceleration() const {
  return this != internal_default_instance() && acceleration_ != nullptr;
}
inline bool Feature::has_acceleration() const {
  return _internal_has_acceleration();
}
inline const ::autoagric::common::Point3D& Feature::_internal_acceleration() const {
  const ::autoagric::common::Point3D* p = acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::Point3D&>(
      ::autoagric::common::_Point3D_default_instance_);
}
inline const ::autoagric::common::Point3D& Feature::acceleration() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.acceleration)
  return _internal_acceleration();
}
inline void Feature::unsafe_arena_set_allocated_acceleration(
    ::autoagric::common::Point3D* acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration_);
  }
  acceleration_ = acceleration;
  if (acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.acceleration)
}
inline ::autoagric::common::Point3D* Feature::release_acceleration() {
  
  ::autoagric::common::Point3D* temp = acceleration_;
  acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::Point3D* Feature::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.acceleration)
  
  ::autoagric::common::Point3D* temp = acceleration_;
  acceleration_ = nullptr;
  return temp;
}
inline ::autoagric::common::Point3D* Feature::_internal_mutable_acceleration() {
  
  if (acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::Point3D>(GetArenaForAllocation());
    acceleration_ = p;
  }
  return acceleration_;
}
inline ::autoagric::common::Point3D* Feature::mutable_acceleration() {
  ::autoagric::common::Point3D* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.acceleration)
  return _msg;
}
inline void Feature::set_allocated_acceleration(::autoagric::common::Point3D* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration_);
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration));
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.acceleration)
}

// double velocity_heading = 5;
inline void Feature::clear_velocity_heading() {
  velocity_heading_ = 0;
}
inline double Feature::_internal_velocity_heading() const {
  return velocity_heading_;
}
inline double Feature::velocity_heading() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.velocity_heading)
  return _internal_velocity_heading();
}
inline void Feature::_internal_set_velocity_heading(double value) {
  
  velocity_heading_ = value;
}
inline void Feature::set_velocity_heading(double value) {
  _internal_set_velocity_heading(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.velocity_heading)
}

// double speed = 6;
inline void Feature::clear_speed() {
  speed_ = 0;
}
inline double Feature::_internal_speed() const {
  return speed_;
}
inline double Feature::speed() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.speed)
  return _internal_speed();
}
inline void Feature::_internal_set_speed(double value) {
  
  speed_ = value;
}
inline void Feature::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.speed)
}

// double acc = 7;
inline void Feature::clear_acc() {
  acc_ = 0;
}
inline double Feature::_internal_acc() const {
  return acc_;
}
inline double Feature::acc() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.acc)
  return _internal_acc();
}
inline void Feature::_internal_set_acc(double value) {
  
  acc_ = value;
}
inline void Feature::set_acc(double value) {
  _internal_set_acc(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.acc)
}

// double theta = 8;
inline void Feature::clear_theta() {
  theta_ = 0;
}
inline double Feature::_internal_theta() const {
  return theta_;
}
inline double Feature::theta() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.theta)
  return _internal_theta();
}
inline void Feature::_internal_set_theta(double value) {
  
  theta_ = value;
}
inline void Feature::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.theta)
}

// double length = 9;
inline void Feature::clear_length() {
  length_ = 0;
}
inline double Feature::_internal_length() const {
  return length_;
}
inline double Feature::length() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.length)
  return _internal_length();
}
inline void Feature::_internal_set_length(double value) {
  
  length_ = value;
}
inline void Feature::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.length)
}

// double width = 10;
inline void Feature::clear_width() {
  width_ = 0;
}
inline double Feature::_internal_width() const {
  return width_;
}
inline double Feature::width() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.width)
  return _internal_width();
}
inline void Feature::_internal_set_width(double value) {
  
  width_ = value;
}
inline void Feature::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.width)
}

// double height = 11;
inline void Feature::clear_height() {
  height_ = 0;
}
inline double Feature::_internal_height() const {
  return height_;
}
inline double Feature::height() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.height)
  return _internal_height();
}
inline void Feature::_internal_set_height(double value) {
  
  height_ = value;
}
inline void Feature::set_height(double value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.height)
}

// double tracking_time = 12;
inline void Feature::clear_tracking_time() {
  tracking_time_ = 0;
}
inline double Feature::_internal_tracking_time() const {
  return tracking_time_;
}
inline double Feature::tracking_time() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.tracking_time)
  return _internal_tracking_time();
}
inline void Feature::_internal_set_tracking_time(double value) {
  
  tracking_time_ = value;
}
inline void Feature::set_tracking_time(double value) {
  _internal_set_tracking_time(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.tracking_time)
}

// double timestamp = 13;
inline void Feature::clear_timestamp() {
  timestamp_ = 0;
}
inline double Feature::_internal_timestamp() const {
  return timestamp_;
}
inline double Feature::timestamp() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.timestamp)
  return _internal_timestamp();
}
inline void Feature::_internal_set_timestamp(double value) {
  
  timestamp_ = value;
}
inline void Feature::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.timestamp)
}

// .autoagric.prediction.JunctionFeature junction_feature = 26;
inline bool Feature::_internal_has_junction_feature() const {
  return this != internal_default_instance() && junction_feature_ != nullptr;
}
inline bool Feature::has_junction_feature() const {
  return _internal_has_junction_feature();
}
inline void Feature::clear_junction_feature() {
  if (GetArenaForAllocation() == nullptr && junction_feature_ != nullptr) {
    delete junction_feature_;
  }
  junction_feature_ = nullptr;
}
inline const ::autoagric::prediction::JunctionFeature& Feature::_internal_junction_feature() const {
  const ::autoagric::prediction::JunctionFeature* p = junction_feature_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::prediction::JunctionFeature&>(
      ::autoagric::prediction::_JunctionFeature_default_instance_);
}
inline const ::autoagric::prediction::JunctionFeature& Feature::junction_feature() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.junction_feature)
  return _internal_junction_feature();
}
inline void Feature::unsafe_arena_set_allocated_junction_feature(
    ::autoagric::prediction::JunctionFeature* junction_feature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(junction_feature_);
  }
  junction_feature_ = junction_feature;
  if (junction_feature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.junction_feature)
}
inline ::autoagric::prediction::JunctionFeature* Feature::release_junction_feature() {
  
  ::autoagric::prediction::JunctionFeature* temp = junction_feature_;
  junction_feature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::prediction::JunctionFeature* Feature::unsafe_arena_release_junction_feature() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.junction_feature)
  
  ::autoagric::prediction::JunctionFeature* temp = junction_feature_;
  junction_feature_ = nullptr;
  return temp;
}
inline ::autoagric::prediction::JunctionFeature* Feature::_internal_mutable_junction_feature() {
  
  if (junction_feature_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::prediction::JunctionFeature>(GetArenaForAllocation());
    junction_feature_ = p;
  }
  return junction_feature_;
}
inline ::autoagric::prediction::JunctionFeature* Feature::mutable_junction_feature() {
  ::autoagric::prediction::JunctionFeature* _msg = _internal_mutable_junction_feature();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.junction_feature)
  return _msg;
}
inline void Feature::set_allocated_junction_feature(::autoagric::prediction::JunctionFeature* junction_feature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete junction_feature_;
  }
  if (junction_feature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::prediction::JunctionFeature>::GetOwningArena(junction_feature);
    if (message_arena != submessage_arena) {
      junction_feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, junction_feature, submessage_arena);
    }
    
  } else {
    
  }
  junction_feature_ = junction_feature;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.junction_feature)
}

// .autoagric.common.Point3D t_position = 16;
inline bool Feature::_internal_has_t_position() const {
  return this != internal_default_instance() && t_position_ != nullptr;
}
inline bool Feature::has_t_position() const {
  return _internal_has_t_position();
}
inline const ::autoagric::common::Point3D& Feature::_internal_t_position() const {
  const ::autoagric::common::Point3D* p = t_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::Point3D&>(
      ::autoagric::common::_Point3D_default_instance_);
}
inline const ::autoagric::common::Point3D& Feature::t_position() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.t_position)
  return _internal_t_position();
}
inline void Feature::unsafe_arena_set_allocated_t_position(
    ::autoagric::common::Point3D* t_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_position_);
  }
  t_position_ = t_position;
  if (t_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.t_position)
}
inline ::autoagric::common::Point3D* Feature::release_t_position() {
  
  ::autoagric::common::Point3D* temp = t_position_;
  t_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::Point3D* Feature::unsafe_arena_release_t_position() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.t_position)
  
  ::autoagric::common::Point3D* temp = t_position_;
  t_position_ = nullptr;
  return temp;
}
inline ::autoagric::common::Point3D* Feature::_internal_mutable_t_position() {
  
  if (t_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::Point3D>(GetArenaForAllocation());
    t_position_ = p;
  }
  return t_position_;
}
inline ::autoagric::common::Point3D* Feature::mutable_t_position() {
  ::autoagric::common::Point3D* _msg = _internal_mutable_t_position();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.t_position)
  return _msg;
}
inline void Feature::set_allocated_t_position(::autoagric::common::Point3D* t_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_position_);
  }
  if (t_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_position));
    if (message_arena != submessage_arena) {
      t_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t_position, submessage_arena);
    }
    
  } else {
    
  }
  t_position_ = t_position;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.t_position)
}

// .autoagric.common.Point3D t_velocity = 17;
inline bool Feature::_internal_has_t_velocity() const {
  return this != internal_default_instance() && t_velocity_ != nullptr;
}
inline bool Feature::has_t_velocity() const {
  return _internal_has_t_velocity();
}
inline const ::autoagric::common::Point3D& Feature::_internal_t_velocity() const {
  const ::autoagric::common::Point3D* p = t_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::Point3D&>(
      ::autoagric::common::_Point3D_default_instance_);
}
inline const ::autoagric::common::Point3D& Feature::t_velocity() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.t_velocity)
  return _internal_t_velocity();
}
inline void Feature::unsafe_arena_set_allocated_t_velocity(
    ::autoagric::common::Point3D* t_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_velocity_);
  }
  t_velocity_ = t_velocity;
  if (t_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.t_velocity)
}
inline ::autoagric::common::Point3D* Feature::release_t_velocity() {
  
  ::autoagric::common::Point3D* temp = t_velocity_;
  t_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::Point3D* Feature::unsafe_arena_release_t_velocity() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.t_velocity)
  
  ::autoagric::common::Point3D* temp = t_velocity_;
  t_velocity_ = nullptr;
  return temp;
}
inline ::autoagric::common::Point3D* Feature::_internal_mutable_t_velocity() {
  
  if (t_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::Point3D>(GetArenaForAllocation());
    t_velocity_ = p;
  }
  return t_velocity_;
}
inline ::autoagric::common::Point3D* Feature::mutable_t_velocity() {
  ::autoagric::common::Point3D* _msg = _internal_mutable_t_velocity();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.t_velocity)
  return _msg;
}
inline void Feature::set_allocated_t_velocity(::autoagric::common::Point3D* t_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_velocity_);
  }
  if (t_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_velocity));
    if (message_arena != submessage_arena) {
      t_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t_velocity, submessage_arena);
    }
    
  } else {
    
  }
  t_velocity_ = t_velocity;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.t_velocity)
}

// double t_velocity_heading = 18;
inline void Feature::clear_t_velocity_heading() {
  t_velocity_heading_ = 0;
}
inline double Feature::_internal_t_velocity_heading() const {
  return t_velocity_heading_;
}
inline double Feature::t_velocity_heading() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.t_velocity_heading)
  return _internal_t_velocity_heading();
}
inline void Feature::_internal_set_t_velocity_heading(double value) {
  
  t_velocity_heading_ = value;
}
inline void Feature::set_t_velocity_heading(double value) {
  _internal_set_t_velocity_heading(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.t_velocity_heading)
}

// double t_speed = 19;
inline void Feature::clear_t_speed() {
  t_speed_ = 0;
}
inline double Feature::_internal_t_speed() const {
  return t_speed_;
}
inline double Feature::t_speed() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.t_speed)
  return _internal_t_speed();
}
inline void Feature::_internal_set_t_speed(double value) {
  
  t_speed_ = value;
}
inline void Feature::set_t_speed(double value) {
  _internal_set_t_speed(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.t_speed)
}

// .autoagric.common.Point3D t_acceleration = 20;
inline bool Feature::_internal_has_t_acceleration() const {
  return this != internal_default_instance() && t_acceleration_ != nullptr;
}
inline bool Feature::has_t_acceleration() const {
  return _internal_has_t_acceleration();
}
inline const ::autoagric::common::Point3D& Feature::_internal_t_acceleration() const {
  const ::autoagric::common::Point3D* p = t_acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::common::Point3D&>(
      ::autoagric::common::_Point3D_default_instance_);
}
inline const ::autoagric::common::Point3D& Feature::t_acceleration() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.t_acceleration)
  return _internal_t_acceleration();
}
inline void Feature::unsafe_arena_set_allocated_t_acceleration(
    ::autoagric::common::Point3D* t_acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_acceleration_);
  }
  t_acceleration_ = t_acceleration;
  if (t_acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.t_acceleration)
}
inline ::autoagric::common::Point3D* Feature::release_t_acceleration() {
  
  ::autoagric::common::Point3D* temp = t_acceleration_;
  t_acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::common::Point3D* Feature::unsafe_arena_release_t_acceleration() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.t_acceleration)
  
  ::autoagric::common::Point3D* temp = t_acceleration_;
  t_acceleration_ = nullptr;
  return temp;
}
inline ::autoagric::common::Point3D* Feature::_internal_mutable_t_acceleration() {
  
  if (t_acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::common::Point3D>(GetArenaForAllocation());
    t_acceleration_ = p;
  }
  return t_acceleration_;
}
inline ::autoagric::common::Point3D* Feature::mutable_t_acceleration() {
  ::autoagric::common::Point3D* _msg = _internal_mutable_t_acceleration();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.t_acceleration)
  return _msg;
}
inline void Feature::set_allocated_t_acceleration(::autoagric::common::Point3D* t_acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_acceleration_);
  }
  if (t_acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_acceleration));
    if (message_arena != submessage_arena) {
      t_acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t_acceleration, submessage_arena);
    }
    
  } else {
    
  }
  t_acceleration_ = t_acceleration;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.t_acceleration)
}

// double t_acc = 21;
inline void Feature::clear_t_acc() {
  t_acc_ = 0;
}
inline double Feature::_internal_t_acc() const {
  return t_acc_;
}
inline double Feature::t_acc() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.t_acc)
  return _internal_t_acc();
}
inline void Feature::_internal_set_t_acc(double value) {
  
  t_acc_ = value;
}
inline void Feature::set_t_acc(double value) {
  _internal_set_t_acc(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.t_acc)
}

// bool is_still = 22;
inline void Feature::clear_is_still() {
  is_still_ = false;
}
inline bool Feature::_internal_is_still() const {
  return is_still_;
}
inline bool Feature::is_still() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.is_still)
  return _internal_is_still();
}
inline void Feature::_internal_set_is_still(bool value) {
  
  is_still_ = value;
}
inline void Feature::set_is_still(bool value) {
  _internal_set_is_still(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.is_still)
}

// .autoagric.perception.PerceptionObstacle.Type type = 23;
inline void Feature::clear_type() {
  type_ = 0;
}
inline ::autoagric::perception::PerceptionObstacle_Type Feature::_internal_type() const {
  return static_cast< ::autoagric::perception::PerceptionObstacle_Type >(type_);
}
inline ::autoagric::perception::PerceptionObstacle_Type Feature::type() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.type)
  return _internal_type();
}
inline void Feature::_internal_set_type(::autoagric::perception::PerceptionObstacle_Type value) {
  
  type_ = value;
}
inline void Feature::set_type(::autoagric::perception::PerceptionObstacle_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.type)
}

// double label_update_time_delta = 24;
inline void Feature::clear_label_update_time_delta() {
  label_update_time_delta_ = 0;
}
inline double Feature::_internal_label_update_time_delta() const {
  return label_update_time_delta_;
}
inline double Feature::label_update_time_delta() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.label_update_time_delta)
  return _internal_label_update_time_delta();
}
inline void Feature::_internal_set_label_update_time_delta(double value) {
  
  label_update_time_delta_ = value;
}
inline void Feature::set_label_update_time_delta(double value) {
  _internal_set_label_update_time_delta(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.label_update_time_delta)
}

// .autoagric.prediction.ObstaclePriority priority = 25;
inline bool Feature::_internal_has_priority() const {
  return this != internal_default_instance() && priority_ != nullptr;
}
inline bool Feature::has_priority() const {
  return _internal_has_priority();
}
inline void Feature::clear_priority() {
  if (GetArenaForAllocation() == nullptr && priority_ != nullptr) {
    delete priority_;
  }
  priority_ = nullptr;
}
inline const ::autoagric::prediction::ObstaclePriority& Feature::_internal_priority() const {
  const ::autoagric::prediction::ObstaclePriority* p = priority_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::prediction::ObstaclePriority&>(
      ::autoagric::prediction::_ObstaclePriority_default_instance_);
}
inline const ::autoagric::prediction::ObstaclePriority& Feature::priority() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.priority)
  return _internal_priority();
}
inline void Feature::unsafe_arena_set_allocated_priority(
    ::autoagric::prediction::ObstaclePriority* priority) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(priority_);
  }
  priority_ = priority;
  if (priority) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.priority)
}
inline ::autoagric::prediction::ObstaclePriority* Feature::release_priority() {
  
  ::autoagric::prediction::ObstaclePriority* temp = priority_;
  priority_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::prediction::ObstaclePriority* Feature::unsafe_arena_release_priority() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.priority)
  
  ::autoagric::prediction::ObstaclePriority* temp = priority_;
  priority_ = nullptr;
  return temp;
}
inline ::autoagric::prediction::ObstaclePriority* Feature::_internal_mutable_priority() {
  
  if (priority_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::prediction::ObstaclePriority>(GetArenaForAllocation());
    priority_ = p;
  }
  return priority_;
}
inline ::autoagric::prediction::ObstaclePriority* Feature::mutable_priority() {
  ::autoagric::prediction::ObstaclePriority* _msg = _internal_mutable_priority();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.priority)
  return _msg;
}
inline void Feature::set_allocated_priority(::autoagric::prediction::ObstaclePriority* priority) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete priority_;
  }
  if (priority) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::prediction::ObstaclePriority>::GetOwningArena(priority);
    if (message_arena != submessage_arena) {
      priority = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, priority, submessage_arena);
    }
    
  } else {
    
  }
  priority_ = priority;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.priority)
}

// .autoagric.prediction.ObstacleInteractiveTag interactive_tag = 37;
inline bool Feature::_internal_has_interactive_tag() const {
  return this != internal_default_instance() && interactive_tag_ != nullptr;
}
inline bool Feature::has_interactive_tag() const {
  return _internal_has_interactive_tag();
}
inline void Feature::clear_interactive_tag() {
  if (GetArenaForAllocation() == nullptr && interactive_tag_ != nullptr) {
    delete interactive_tag_;
  }
  interactive_tag_ = nullptr;
}
inline const ::autoagric::prediction::ObstacleInteractiveTag& Feature::_internal_interactive_tag() const {
  const ::autoagric::prediction::ObstacleInteractiveTag* p = interactive_tag_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::prediction::ObstacleInteractiveTag&>(
      ::autoagric::prediction::_ObstacleInteractiveTag_default_instance_);
}
inline const ::autoagric::prediction::ObstacleInteractiveTag& Feature::interactive_tag() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.interactive_tag)
  return _internal_interactive_tag();
}
inline void Feature::unsafe_arena_set_allocated_interactive_tag(
    ::autoagric::prediction::ObstacleInteractiveTag* interactive_tag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interactive_tag_);
  }
  interactive_tag_ = interactive_tag;
  if (interactive_tag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.interactive_tag)
}
inline ::autoagric::prediction::ObstacleInteractiveTag* Feature::release_interactive_tag() {
  
  ::autoagric::prediction::ObstacleInteractiveTag* temp = interactive_tag_;
  interactive_tag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::prediction::ObstacleInteractiveTag* Feature::unsafe_arena_release_interactive_tag() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.interactive_tag)
  
  ::autoagric::prediction::ObstacleInteractiveTag* temp = interactive_tag_;
  interactive_tag_ = nullptr;
  return temp;
}
inline ::autoagric::prediction::ObstacleInteractiveTag* Feature::_internal_mutable_interactive_tag() {
  
  if (interactive_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::prediction::ObstacleInteractiveTag>(GetArenaForAllocation());
    interactive_tag_ = p;
  }
  return interactive_tag_;
}
inline ::autoagric::prediction::ObstacleInteractiveTag* Feature::mutable_interactive_tag() {
  ::autoagric::prediction::ObstacleInteractiveTag* _msg = _internal_mutable_interactive_tag();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.interactive_tag)
  return _msg;
}
inline void Feature::set_allocated_interactive_tag(::autoagric::prediction::ObstacleInteractiveTag* interactive_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete interactive_tag_;
  }
  if (interactive_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::autoagric::prediction::ObstacleInteractiveTag>::GetOwningArena(interactive_tag);
    if (message_arena != submessage_arena) {
      interactive_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interactive_tag, submessage_arena);
    }
    
  } else {
    
  }
  interactive_tag_ = interactive_tag;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.interactive_tag)
}

// bool is_near_junction = 29;
inline void Feature::clear_is_near_junction() {
  is_near_junction_ = false;
}
inline bool Feature::_internal_is_near_junction() const {
  return is_near_junction_;
}
inline bool Feature::is_near_junction() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.is_near_junction)
  return _internal_is_near_junction();
}
inline void Feature::_internal_set_is_near_junction(bool value) {
  
  is_near_junction_ = value;
}
inline void Feature::set_is_near_junction(bool value) {
  _internal_set_is_near_junction(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.is_near_junction)
}

// repeated .autoagric.prediction.PredictionTrajectoryPoint future_trajectory_points = 31;
inline int Feature::_internal_future_trajectory_points_size() const {
  return future_trajectory_points_.size();
}
inline int Feature::future_trajectory_points_size() const {
  return _internal_future_trajectory_points_size();
}
inline ::autoagric::prediction::PredictionTrajectoryPoint* Feature::mutable_future_trajectory_points(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.future_trajectory_points)
  return future_trajectory_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::PredictionTrajectoryPoint >*
Feature::mutable_future_trajectory_points() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.Feature.future_trajectory_points)
  return &future_trajectory_points_;
}
inline const ::autoagric::prediction::PredictionTrajectoryPoint& Feature::_internal_future_trajectory_points(int index) const {
  return future_trajectory_points_.Get(index);
}
inline const ::autoagric::prediction::PredictionTrajectoryPoint& Feature::future_trajectory_points(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.future_trajectory_points)
  return _internal_future_trajectory_points(index);
}
inline ::autoagric::prediction::PredictionTrajectoryPoint* Feature::_internal_add_future_trajectory_points() {
  return future_trajectory_points_.Add();
}
inline ::autoagric::prediction::PredictionTrajectoryPoint* Feature::add_future_trajectory_points() {
  ::autoagric::prediction::PredictionTrajectoryPoint* _add = _internal_add_future_trajectory_points();
  // @@protoc_insertion_point(field_add:autoagric.prediction.Feature.future_trajectory_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::PredictionTrajectoryPoint >&
Feature::future_trajectory_points() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.Feature.future_trajectory_points)
  return future_trajectory_points_;
}

// repeated .autoagric.common.TrajectoryPoint short_term_predicted_trajectory_points = 32;
inline int Feature::_internal_short_term_predicted_trajectory_points_size() const {
  return short_term_predicted_trajectory_points_.size();
}
inline int Feature::short_term_predicted_trajectory_points_size() const {
  return _internal_short_term_predicted_trajectory_points_size();
}
inline ::autoagric::common::TrajectoryPoint* Feature::mutable_short_term_predicted_trajectory_points(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.short_term_predicted_trajectory_points)
  return short_term_predicted_trajectory_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >*
Feature::mutable_short_term_predicted_trajectory_points() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.Feature.short_term_predicted_trajectory_points)
  return &short_term_predicted_trajectory_points_;
}
inline const ::autoagric::common::TrajectoryPoint& Feature::_internal_short_term_predicted_trajectory_points(int index) const {
  return short_term_predicted_trajectory_points_.Get(index);
}
inline const ::autoagric::common::TrajectoryPoint& Feature::short_term_predicted_trajectory_points(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.short_term_predicted_trajectory_points)
  return _internal_short_term_predicted_trajectory_points(index);
}
inline ::autoagric::common::TrajectoryPoint* Feature::_internal_add_short_term_predicted_trajectory_points() {
  return short_term_predicted_trajectory_points_.Add();
}
inline ::autoagric::common::TrajectoryPoint* Feature::add_short_term_predicted_trajectory_points() {
  ::autoagric::common::TrajectoryPoint* _add = _internal_add_short_term_predicted_trajectory_points();
  // @@protoc_insertion_point(field_add:autoagric.prediction.Feature.short_term_predicted_trajectory_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >&
Feature::short_term_predicted_trajectory_points() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.Feature.short_term_predicted_trajectory_points)
  return short_term_predicted_trajectory_points_;
}

// repeated .autoagric.prediction.Trajectory predicted_trajectory = 33;
inline int Feature::_internal_predicted_trajectory_size() const {
  return predicted_trajectory_.size();
}
inline int Feature::predicted_trajectory_size() const {
  return _internal_predicted_trajectory_size();
}
inline void Feature::clear_predicted_trajectory() {
  predicted_trajectory_.Clear();
}
inline ::autoagric::prediction::Trajectory* Feature::mutable_predicted_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.predicted_trajectory)
  return predicted_trajectory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::Trajectory >*
Feature::mutable_predicted_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.Feature.predicted_trajectory)
  return &predicted_trajectory_;
}
inline const ::autoagric::prediction::Trajectory& Feature::_internal_predicted_trajectory(int index) const {
  return predicted_trajectory_.Get(index);
}
inline const ::autoagric::prediction::Trajectory& Feature::predicted_trajectory(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.predicted_trajectory)
  return _internal_predicted_trajectory(index);
}
inline ::autoagric::prediction::Trajectory* Feature::_internal_add_predicted_trajectory() {
  return predicted_trajectory_.Add();
}
inline ::autoagric::prediction::Trajectory* Feature::add_predicted_trajectory() {
  ::autoagric::prediction::Trajectory* _add = _internal_add_predicted_trajectory();
  // @@protoc_insertion_point(field_add:autoagric.prediction.Feature.predicted_trajectory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::prediction::Trajectory >&
Feature::predicted_trajectory() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.Feature.predicted_trajectory)
  return predicted_trajectory_;
}

// repeated .autoagric.common.TrajectoryPoint adc_trajectory_point = 34;
inline int Feature::_internal_adc_trajectory_point_size() const {
  return adc_trajectory_point_.size();
}
inline int Feature::adc_trajectory_point_size() const {
  return _internal_adc_trajectory_point_size();
}
inline ::autoagric::common::TrajectoryPoint* Feature::mutable_adc_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.adc_trajectory_point)
  return adc_trajectory_point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >*
Feature::mutable_adc_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.Feature.adc_trajectory_point)
  return &adc_trajectory_point_;
}
inline const ::autoagric::common::TrajectoryPoint& Feature::_internal_adc_trajectory_point(int index) const {
  return adc_trajectory_point_.Get(index);
}
inline const ::autoagric::common::TrajectoryPoint& Feature::adc_trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.adc_trajectory_point)
  return _internal_adc_trajectory_point(index);
}
inline ::autoagric::common::TrajectoryPoint* Feature::_internal_add_adc_trajectory_point() {
  return adc_trajectory_point_.Add();
}
inline ::autoagric::common::TrajectoryPoint* Feature::add_adc_trajectory_point() {
  ::autoagric::common::TrajectoryPoint* _add = _internal_add_adc_trajectory_point();
  // @@protoc_insertion_point(field_add:autoagric.prediction.Feature.adc_trajectory_point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autoagric::common::TrajectoryPoint >&
Feature::adc_trajectory_point() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.Feature.adc_trajectory_point)
  return adc_trajectory_point_;
}

// double adc_timestamp = 38;
inline void Feature::clear_adc_timestamp() {
  adc_timestamp_ = 0;
}
inline double Feature::_internal_adc_timestamp() const {
  return adc_timestamp_;
}
inline double Feature::adc_timestamp() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.adc_timestamp)
  return _internal_adc_timestamp();
}
inline void Feature::_internal_set_adc_timestamp(double value) {
  
  adc_timestamp_ = value;
}
inline void Feature::set_adc_timestamp(double value) {
  _internal_set_adc_timestamp(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.adc_timestamp)
}

// .autoagric.perception.PerceptionObstacle adc_localization = 39;
inline bool Feature::_internal_has_adc_localization() const {
  return this != internal_default_instance() && adc_localization_ != nullptr;
}
inline bool Feature::has_adc_localization() const {
  return _internal_has_adc_localization();
}
inline const ::autoagric::perception::PerceptionObstacle& Feature::_internal_adc_localization() const {
  const ::autoagric::perception::PerceptionObstacle* p = adc_localization_;
  return p != nullptr ? *p : reinterpret_cast<const ::autoagric::perception::PerceptionObstacle&>(
      ::autoagric::perception::_PerceptionObstacle_default_instance_);
}
inline const ::autoagric::perception::PerceptionObstacle& Feature::adc_localization() const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.adc_localization)
  return _internal_adc_localization();
}
inline void Feature::unsafe_arena_set_allocated_adc_localization(
    ::autoagric::perception::PerceptionObstacle* adc_localization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adc_localization_);
  }
  adc_localization_ = adc_localization;
  if (adc_localization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autoagric.prediction.Feature.adc_localization)
}
inline ::autoagric::perception::PerceptionObstacle* Feature::release_adc_localization() {
  
  ::autoagric::perception::PerceptionObstacle* temp = adc_localization_;
  adc_localization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autoagric::perception::PerceptionObstacle* Feature::unsafe_arena_release_adc_localization() {
  // @@protoc_insertion_point(field_release:autoagric.prediction.Feature.adc_localization)
  
  ::autoagric::perception::PerceptionObstacle* temp = adc_localization_;
  adc_localization_ = nullptr;
  return temp;
}
inline ::autoagric::perception::PerceptionObstacle* Feature::_internal_mutable_adc_localization() {
  
  if (adc_localization_ == nullptr) {
    auto* p = CreateMaybeMessage<::autoagric::perception::PerceptionObstacle>(GetArenaForAllocation());
    adc_localization_ = p;
  }
  return adc_localization_;
}
inline ::autoagric::perception::PerceptionObstacle* Feature::mutable_adc_localization() {
  ::autoagric::perception::PerceptionObstacle* _msg = _internal_mutable_adc_localization();
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.adc_localization)
  return _msg;
}
inline void Feature::set_allocated_adc_localization(::autoagric::perception::PerceptionObstacle* adc_localization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(adc_localization_);
  }
  if (adc_localization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adc_localization));
    if (message_arena != submessage_arena) {
      adc_localization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adc_localization, submessage_arena);
    }
    
  } else {
    
  }
  adc_localization_ = adc_localization;
  // @@protoc_insertion_point(field_set_allocated:autoagric.prediction.Feature.adc_localization)
}

// repeated string surrounding_lane_id = 35;
inline int Feature::_internal_surrounding_lane_id_size() const {
  return surrounding_lane_id_.size();
}
inline int Feature::surrounding_lane_id_size() const {
  return _internal_surrounding_lane_id_size();
}
inline void Feature::clear_surrounding_lane_id() {
  surrounding_lane_id_.Clear();
}
inline std::string* Feature::add_surrounding_lane_id() {
  std::string* _s = _internal_add_surrounding_lane_id();
  // @@protoc_insertion_point(field_add_mutable:autoagric.prediction.Feature.surrounding_lane_id)
  return _s;
}
inline const std::string& Feature::_internal_surrounding_lane_id(int index) const {
  return surrounding_lane_id_.Get(index);
}
inline const std::string& Feature::surrounding_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.surrounding_lane_id)
  return _internal_surrounding_lane_id(index);
}
inline std::string* Feature::mutable_surrounding_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.surrounding_lane_id)
  return surrounding_lane_id_.Mutable(index);
}
inline void Feature::set_surrounding_lane_id(int index, const std::string& value) {
  surrounding_lane_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.surrounding_lane_id)
}
inline void Feature::set_surrounding_lane_id(int index, std::string&& value) {
  surrounding_lane_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.surrounding_lane_id)
}
inline void Feature::set_surrounding_lane_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  surrounding_lane_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autoagric.prediction.Feature.surrounding_lane_id)
}
inline void Feature::set_surrounding_lane_id(int index, const char* value, size_t size) {
  surrounding_lane_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autoagric.prediction.Feature.surrounding_lane_id)
}
inline std::string* Feature::_internal_add_surrounding_lane_id() {
  return surrounding_lane_id_.Add();
}
inline void Feature::add_surrounding_lane_id(const std::string& value) {
  surrounding_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autoagric.prediction.Feature.surrounding_lane_id)
}
inline void Feature::add_surrounding_lane_id(std::string&& value) {
  surrounding_lane_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autoagric.prediction.Feature.surrounding_lane_id)
}
inline void Feature::add_surrounding_lane_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  surrounding_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autoagric.prediction.Feature.surrounding_lane_id)
}
inline void Feature::add_surrounding_lane_id(const char* value, size_t size) {
  surrounding_lane_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autoagric.prediction.Feature.surrounding_lane_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Feature::surrounding_lane_id() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.Feature.surrounding_lane_id)
  return surrounding_lane_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Feature::mutable_surrounding_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.Feature.surrounding_lane_id)
  return &surrounding_lane_id_;
}

// repeated string within_lane_id = 36;
inline int Feature::_internal_within_lane_id_size() const {
  return within_lane_id_.size();
}
inline int Feature::within_lane_id_size() const {
  return _internal_within_lane_id_size();
}
inline void Feature::clear_within_lane_id() {
  within_lane_id_.Clear();
}
inline std::string* Feature::add_within_lane_id() {
  std::string* _s = _internal_add_within_lane_id();
  // @@protoc_insertion_point(field_add_mutable:autoagric.prediction.Feature.within_lane_id)
  return _s;
}
inline const std::string& Feature::_internal_within_lane_id(int index) const {
  return within_lane_id_.Get(index);
}
inline const std::string& Feature::within_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:autoagric.prediction.Feature.within_lane_id)
  return _internal_within_lane_id(index);
}
inline std::string* Feature::mutable_within_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:autoagric.prediction.Feature.within_lane_id)
  return within_lane_id_.Mutable(index);
}
inline void Feature::set_within_lane_id(int index, const std::string& value) {
  within_lane_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.within_lane_id)
}
inline void Feature::set_within_lane_id(int index, std::string&& value) {
  within_lane_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autoagric.prediction.Feature.within_lane_id)
}
inline void Feature::set_within_lane_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  within_lane_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autoagric.prediction.Feature.within_lane_id)
}
inline void Feature::set_within_lane_id(int index, const char* value, size_t size) {
  within_lane_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autoagric.prediction.Feature.within_lane_id)
}
inline std::string* Feature::_internal_add_within_lane_id() {
  return within_lane_id_.Add();
}
inline void Feature::add_within_lane_id(const std::string& value) {
  within_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autoagric.prediction.Feature.within_lane_id)
}
inline void Feature::add_within_lane_id(std::string&& value) {
  within_lane_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autoagric.prediction.Feature.within_lane_id)
}
inline void Feature::add_within_lane_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  within_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autoagric.prediction.Feature.within_lane_id)
}
inline void Feature::add_within_lane_id(const char* value, size_t size) {
  within_lane_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autoagric.prediction.Feature.within_lane_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Feature::within_lane_id() const {
  // @@protoc_insertion_point(field_list:autoagric.prediction.Feature.within_lane_id)
  return within_lane_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Feature::mutable_within_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:autoagric.prediction.Feature.within_lane_id)
  return &within_lane_id_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace prediction
}  // namespace autoagric

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autoagric::prediction::ObstaclePriority_Priority> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autoagric::prediction::ObstaclePriority_Priority>() {
  return ::autoagric::prediction::ObstaclePriority_Priority_descriptor();
}
template <> struct is_proto_enum< ::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag>() {
  return ::autoagric::prediction::ObstacleInteractiveTag_InteractiveTag_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_autoagric_2fprediction_2ffeature_2eproto
