// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: autoagric/perception/perception_obstacle.proto

#include "autoagric/perception/perception_obstacle.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace autoagric {
namespace perception {
constexpr BBox2D::BBox2D(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : xmin_(0)
  , ymin_(0)
  , xmax_(0)
  , ymax_(0){}
struct BBox2DDefaultTypeInternal {
  constexpr BBox2DDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BBox2DDefaultTypeInternal() {}
  union {
    BBox2D _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BBox2DDefaultTypeInternal _BBox2D_default_instance_;
constexpr LightStatus::LightStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : brake_visible_(0)
  , brake_switch_on_(0)
  , left_turn_visible_(0)
  , left_turn_switch_on_(0)
  , right_turn_visible_(0)
  , right_turn_switch_on_(0){}
struct LightStatusDefaultTypeInternal {
  constexpr LightStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LightStatusDefaultTypeInternal() {}
  union {
    LightStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LightStatusDefaultTypeInternal _LightStatus_default_instance_;
constexpr V2XInformation::V2XInformation(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : v2x_type_()
  , _v2x_type_cached_byte_size_(0){}
struct V2XInformationDefaultTypeInternal {
  constexpr V2XInformationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~V2XInformationDefaultTypeInternal() {}
  union {
    V2XInformation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT V2XInformationDefaultTypeInternal _V2XInformation_default_instance_;
constexpr SensorMeasurement::SensorMeasurement(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sensor_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , position_(nullptr)
  , velocity_(nullptr)
  , box_(nullptr)
  , theta_(0)
  , length_(0)
  , id_(0)
  , type_(0)

  , width_(0)
  , height_(0)
  , timestamp_(0)
  , sub_type_(0)
{}
struct SensorMeasurementDefaultTypeInternal {
  constexpr SensorMeasurementDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SensorMeasurementDefaultTypeInternal() {}
  union {
    SensorMeasurement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SensorMeasurementDefaultTypeInternal _SensorMeasurement_default_instance_;
constexpr Trajectory::Trajectory(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : trajectory_point_()
  , probability_(0){}
struct TrajectoryDefaultTypeInternal {
  constexpr TrajectoryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TrajectoryDefaultTypeInternal() {}
  union {
    Trajectory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
constexpr DebugMessage::DebugMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : trajectory_(){}
struct DebugMessageDefaultTypeInternal {
  constexpr DebugMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DebugMessageDefaultTypeInternal() {}
  union {
    DebugMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DebugMessageDefaultTypeInternal _DebugMessage_default_instance_;
constexpr PerceptionObstacle::PerceptionObstacle(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : polygon_point_()
  , point_cloud_()
  , drops_()
  , measurements_()
  , position_covariance_()
  , velocity_covariance_()
  , acceleration_covariance_()
  , position_(nullptr)
  , velocity_(nullptr)
  , acceleration_(nullptr)
  , anchor_point_(nullptr)
  , bbox2d_(nullptr)
  , light_status_(nullptr)
  , msg_(nullptr)
  , v2x_info_(nullptr)
  , theta_(0)
  , length_(0)
  , id_(0)
  , type_(0)

  , width_(0)
  , height_(0)
  , tracking_time_(0)
  , timestamp_(0)
  , confidence_(0)
  , confidence_type_(0)

  , sub_type_(0)

  , height_above_ground_(0)
  , source_(0)
{}
struct PerceptionObstacleDefaultTypeInternal {
  constexpr PerceptionObstacleDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PerceptionObstacleDefaultTypeInternal() {}
  union {
    PerceptionObstacle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PerceptionObstacleDefaultTypeInternal _PerceptionObstacle_default_instance_;
constexpr CIPVInfo::CIPVInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : potential_cipv_id_()
  , _potential_cipv_id_cached_byte_size_(0)
  , cipv_id_(0){}
struct CIPVInfoDefaultTypeInternal {
  constexpr CIPVInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CIPVInfoDefaultTypeInternal() {}
  union {
    CIPVInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CIPVInfoDefaultTypeInternal _CIPVInfo_default_instance_;
constexpr PerceptionObstacles::PerceptionObstacles(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : perception_obstacle_()
  , header_(nullptr)
  , cipv_info_(nullptr)
  , error_code_(0)
{}
struct PerceptionObstaclesDefaultTypeInternal {
  constexpr PerceptionObstaclesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PerceptionObstaclesDefaultTypeInternal() {}
  union {
    PerceptionObstacles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PerceptionObstaclesDefaultTypeInternal _PerceptionObstacles_default_instance_;
}  // namespace perception
}  // namespace autoagric
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_autoagric_2fperception_2fperception_5fobstacle_2eproto[9];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_autoagric_2fperception_2fperception_5fobstacle_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_autoagric_2fperception_2fperception_5fobstacle_2eproto = nullptr;

const uint32_t TableStruct_autoagric_2fperception_2fperception_5fobstacle_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::BBox2D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::BBox2D, xmin_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::BBox2D, ymin_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::BBox2D, xmax_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::BBox2D, ymax_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::LightStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::LightStatus, brake_visible_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::LightStatus, brake_switch_on_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::LightStatus, left_turn_visible_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::LightStatus, left_turn_switch_on_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::LightStatus, right_turn_visible_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::LightStatus, right_turn_switch_on_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::V2XInformation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::V2XInformation, v2x_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, sensor_id_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, id_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, position_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, theta_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, length_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, width_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, height_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, velocity_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, type_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, sub_type_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, timestamp_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::SensorMeasurement, box_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::Trajectory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::Trajectory, probability_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::Trajectory, trajectory_point_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::DebugMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::DebugMessage, trajectory_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, id_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, position_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, theta_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, velocity_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, length_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, width_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, height_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, polygon_point_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, tracking_time_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, type_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, timestamp_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, point_cloud_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, confidence_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, confidence_type_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, drops_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, acceleration_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, anchor_point_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, bbox2d_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, sub_type_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, measurements_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, height_above_ground_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, position_covariance_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, velocity_covariance_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, acceleration_covariance_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, light_status_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, msg_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, source_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacle, v2x_info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::CIPVInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::CIPVInfo, cipv_id_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::CIPVInfo, potential_cipv_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacles, perception_obstacle_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacles, header_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacles, error_code_),
  PROTOBUF_FIELD_OFFSET(::autoagric::perception::PerceptionObstacles, cipv_info_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::autoagric::perception::BBox2D)},
  { 10, -1, -1, sizeof(::autoagric::perception::LightStatus)},
  { 22, -1, -1, sizeof(::autoagric::perception::V2XInformation)},
  { 29, -1, -1, sizeof(::autoagric::perception::SensorMeasurement)},
  { 47, -1, -1, sizeof(::autoagric::perception::Trajectory)},
  { 55, -1, -1, sizeof(::autoagric::perception::DebugMessage)},
  { 62, -1, -1, sizeof(::autoagric::perception::PerceptionObstacle)},
  { 96, -1, -1, sizeof(::autoagric::perception::CIPVInfo)},
  { 104, -1, -1, sizeof(::autoagric::perception::PerceptionObstacles)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::perception::_BBox2D_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::perception::_LightStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::perception::_V2XInformation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::perception::_SensorMeasurement_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::perception::_Trajectory_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::perception::_DebugMessage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::perception::_PerceptionObstacle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::perception::_CIPVInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::autoagric::perception::_PerceptionObstacles_default_instance_),
};

const char descriptor_table_protodef_autoagric_2fperception_2fperception_5fobstacle_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n.autoagric/perception/perception_obstac"
  "le.proto\022\024autoagric.perception\032!autoagri"
  "c/common/error_code.proto\032\037autoagric/com"
  "mon/geometry.proto\032\035autoagric/common/hea"
  "der.proto\032 autoagric/common/pnc_point.pr"
  "oto\"@\n\006BBox2D\022\014\n\004xmin\030\001 \001(\001\022\014\n\004ymin\030\002 \001("
  "\001\022\014\n\004xmax\030\003 \001(\001\022\014\n\004ymax\030\004 \001(\001\"\257\001\n\013LightS"
  "tatus\022\025\n\rbrake_visible\030\001 \001(\001\022\027\n\017brake_sw"
  "itch_on\030\002 \001(\001\022\031\n\021left_turn_visible\030\003 \001(\001"
  "\022\033\n\023left_turn_switch_on\030\004 \001(\001\022\032\n\022right_t"
  "urn_visible\030\005 \001(\001\022\034\n\024right_turn_switch_o"
  "n\030\006 \001(\001\"\206\001\n\016V2XInformation\022>\n\010v2x_type\030\001"
  " \003(\0162,.autoagric.perception.V2XInformati"
  "on.V2XType\"4\n\007V2XType\022\010\n\004NONE\020\000\022\017\n\013ZOMBI"
  "ES_CAR\020\001\022\016\n\nBLIND_ZONE\020\002\"\211\003\n\021SensorMeasu"
  "rement\022\021\n\tsensor_id\030\001 \001(\t\022\n\n\002id\030\002 \001(\005\022+\n"
  "\010position\030\003 \001(\0132\031.autoagric.common.Point"
  "3D\022\r\n\005theta\030\004 \001(\001\022\016\n\006length\030\005 \001(\001\022\r\n\005wid"
  "th\030\006 \001(\001\022\016\n\006height\030\007 \001(\001\022+\n\010velocity\030\010 \001"
  "(\0132\031.autoagric.common.Point3D\022;\n\004type\030\t "
  "\001(\0162-.autoagric.perception.PerceptionObs"
  "tacle.Type\022B\n\010sub_type\030\n \001(\01620.autoagric"
  ".perception.PerceptionObstacle.SubType\022\021"
  "\n\ttimestamp\030\013 \001(\001\022)\n\003box\030\014 \001(\0132\034.autoagr"
  "ic.perception.BBox2D\"^\n\nTrajectory\022\023\n\013pr"
  "obability\030\001 \001(\001\022;\n\020trajectory_point\030\002 \003("
  "\0132!.autoagric.common.TrajectoryPoint\"D\n\014"
  "DebugMessage\0224\n\ntrajectory\030\001 \003(\0132 .autoa"
  "gric.perception.Trajectory\"\247\014\n\022Perceptio"
  "nObstacle\022\n\n\002id\030\001 \001(\005\022+\n\010position\030\002 \001(\0132"
  "\031.autoagric.common.Point3D\022\r\n\005theta\030\003 \001("
  "\001\022+\n\010velocity\030\004 \001(\0132\031.autoagric.common.P"
  "oint3D\022\016\n\006length\030\005 \001(\001\022\r\n\005width\030\006 \001(\001\022\016\n"
  "\006height\030\007 \001(\001\0220\n\rpolygon_point\030\010 \003(\0132\031.a"
  "utoagric.common.Point3D\022\025\n\rtracking_time"
  "\030\t \001(\001\022;\n\004type\030\n \001(\0162-.autoagric.percept"
  "ion.PerceptionObstacle.Type\022\021\n\ttimestamp"
  "\030\013 \001(\001\022\023\n\013point_cloud\030\014 \003(\001\022\022\n\nconfidenc"
  "e\030\r \001(\001\022P\n\017confidence_type\030\016 \001(\01627.autoa"
  "gric.perception.PerceptionObstacle.Confi"
  "denceType\022(\n\005drops\030\017 \003(\0132\031.autoagric.com"
  "mon.Point3D\022/\n\014acceleration\030\020 \001(\0132\031.auto"
  "agric.common.Point3D\022/\n\014anchor_point\030\021 \001"
  "(\0132\031.autoagric.common.Point3D\022,\n\006bbox2d\030"
  "\022 \001(\0132\034.autoagric.perception.BBox2D\022B\n\010s"
  "ub_type\030\023 \001(\01620.autoagric.perception.Per"
  "ceptionObstacle.SubType\022=\n\014measurements\030"
  "\024 \003(\0132\'.autoagric.perception.SensorMeasu"
  "rement\022\033\n\023height_above_ground\030\025 \001(\001\022\033\n\023p"
  "osition_covariance\030\026 \003(\001\022\033\n\023velocity_cov"
  "ariance\030\027 \003(\001\022\037\n\027acceleration_covariance"
  "\030\030 \003(\001\0227\n\014light_status\030\031 \001(\0132!.autoagric"
  ".perception.LightStatus\022/\n\003msg\030\032 \001(\0132\".a"
  "utoagric.perception.DebugMessage\022\?\n\006sour"
  "ce\030\033 \001(\0162/.autoagric.perception.Percepti"
  "onObstacle.Source\0226\n\010v2x_info\030\034 \001(\0132$.au"
  "toagric.perception.V2XInformation\"i\n\004Typ"
  "e\022\013\n\007UNKNOWN\020\000\022\023\n\017UNKNOWN_MOVABLE\020\001\022\025\n\021U"
  "NKNOWN_UNMOVABLE\020\002\022\016\n\nPEDESTRIAN\020\003\022\013\n\007BI"
  "CYCLE\020\004\022\013\n\007VEHICLE\020\005\"R\n\016ConfidenceType\022\026"
  "\n\022CONFIDENCE_UNKNOWN\020\000\022\022\n\016CONFIDENCE_CNN"
  "\020\001\022\024\n\020CONFIDENCE_RADAR\020\002\"\334\001\n\007SubType\022\016\n\n"
  "ST_UNKNOWN\020\000\022\026\n\022ST_UNKNOWN_MOVABLE\020\001\022\030\n\024"
  "ST_UNKNOWN_UNMOVABLE\020\002\022\n\n\006ST_CAR\020\003\022\n\n\006ST"
  "_VAN\020\004\022\014\n\010ST_TRUCK\020\005\022\n\n\006ST_BUS\020\006\022\016\n\nST_C"
  "YCLIST\020\007\022\023\n\017ST_MOTORCYCLIST\020\010\022\021\n\rST_TRIC"
  "YCLIST\020\t\022\021\n\rST_PEDESTRIAN\020\n\022\022\n\016ST_TRAFFI"
  "CCONE\020\013\"#\n\006Source\022\020\n\014HOST_VEHICLE\020\000\022\007\n\003V"
  "2X\020\001\"6\n\010CIPVInfo\022\017\n\007cipv_id\030\001 \001(\005\022\031\n\021pot"
  "ential_cipv_id\030\002 \003(\005\"\352\001\n\023PerceptionObsta"
  "cles\022E\n\023perception_obstacle\030\001 \003(\0132(.auto"
  "agric.perception.PerceptionObstacle\022(\n\006h"
  "eader\030\002 \001(\0132\030.autoagric.common.Header\022/\n"
  "\nerror_code\030\003 \001(\0162\033.autoagric.common.Err"
  "orCode\0221\n\tcipv_info\030\005 \001(\0132\036.autoagric.pe"
  "rception.CIPVInfob\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_deps[4] = {
  &::descriptor_table_autoagric_2fcommon_2ferror_5fcode_2eproto,
  &::descriptor_table_autoagric_2fcommon_2fgeometry_2eproto,
  &::descriptor_table_autoagric_2fcommon_2fheader_2eproto,
  &::descriptor_table_autoagric_2fcommon_2fpnc_5fpoint_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto = {
  false, false, 3025, descriptor_table_protodef_autoagric_2fperception_2fperception_5fobstacle_2eproto, "autoagric/perception/perception_obstacle.proto", 
  &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_once, descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_deps, 4, 9,
  schemas, file_default_instances, TableStruct_autoagric_2fperception_2fperception_5fobstacle_2eproto::offsets,
  file_level_metadata_autoagric_2fperception_2fperception_5fobstacle_2eproto, file_level_enum_descriptors_autoagric_2fperception_2fperception_5fobstacle_2eproto, file_level_service_descriptors_autoagric_2fperception_2fperception_5fobstacle_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_getter() {
  return &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_autoagric_2fperception_2fperception_5fobstacle_2eproto(&descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto);
namespace autoagric {
namespace perception {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* V2XInformation_V2XType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto);
  return file_level_enum_descriptors_autoagric_2fperception_2fperception_5fobstacle_2eproto[0];
}
bool V2XInformation_V2XType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr V2XInformation_V2XType V2XInformation::NONE;
constexpr V2XInformation_V2XType V2XInformation::ZOMBIES_CAR;
constexpr V2XInformation_V2XType V2XInformation::BLIND_ZONE;
constexpr V2XInformation_V2XType V2XInformation::V2XType_MIN;
constexpr V2XInformation_V2XType V2XInformation::V2XType_MAX;
constexpr int V2XInformation::V2XType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerceptionObstacle_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto);
  return file_level_enum_descriptors_autoagric_2fperception_2fperception_5fobstacle_2eproto[1];
}
bool PerceptionObstacle_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PerceptionObstacle_Type PerceptionObstacle::UNKNOWN;
constexpr PerceptionObstacle_Type PerceptionObstacle::UNKNOWN_MOVABLE;
constexpr PerceptionObstacle_Type PerceptionObstacle::UNKNOWN_UNMOVABLE;
constexpr PerceptionObstacle_Type PerceptionObstacle::PEDESTRIAN;
constexpr PerceptionObstacle_Type PerceptionObstacle::BICYCLE;
constexpr PerceptionObstacle_Type PerceptionObstacle::VEHICLE;
constexpr PerceptionObstacle_Type PerceptionObstacle::Type_MIN;
constexpr PerceptionObstacle_Type PerceptionObstacle::Type_MAX;
constexpr int PerceptionObstacle::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerceptionObstacle_ConfidenceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto);
  return file_level_enum_descriptors_autoagric_2fperception_2fperception_5fobstacle_2eproto[2];
}
bool PerceptionObstacle_ConfidenceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PerceptionObstacle_ConfidenceType PerceptionObstacle::CONFIDENCE_UNKNOWN;
constexpr PerceptionObstacle_ConfidenceType PerceptionObstacle::CONFIDENCE_CNN;
constexpr PerceptionObstacle_ConfidenceType PerceptionObstacle::CONFIDENCE_RADAR;
constexpr PerceptionObstacle_ConfidenceType PerceptionObstacle::ConfidenceType_MIN;
constexpr PerceptionObstacle_ConfidenceType PerceptionObstacle::ConfidenceType_MAX;
constexpr int PerceptionObstacle::ConfidenceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerceptionObstacle_SubType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto);
  return file_level_enum_descriptors_autoagric_2fperception_2fperception_5fobstacle_2eproto[3];
}
bool PerceptionObstacle_SubType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_UNKNOWN;
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_UNKNOWN_MOVABLE;
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_UNKNOWN_UNMOVABLE;
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_CAR;
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_VAN;
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_TRUCK;
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_BUS;
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_CYCLIST;
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_MOTORCYCLIST;
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_TRICYCLIST;
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_PEDESTRIAN;
constexpr PerceptionObstacle_SubType PerceptionObstacle::ST_TRAFFICCONE;
constexpr PerceptionObstacle_SubType PerceptionObstacle::SubType_MIN;
constexpr PerceptionObstacle_SubType PerceptionObstacle::SubType_MAX;
constexpr int PerceptionObstacle::SubType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerceptionObstacle_Source_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto);
  return file_level_enum_descriptors_autoagric_2fperception_2fperception_5fobstacle_2eproto[4];
}
bool PerceptionObstacle_Source_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PerceptionObstacle_Source PerceptionObstacle::HOST_VEHICLE;
constexpr PerceptionObstacle_Source PerceptionObstacle::V2X;
constexpr PerceptionObstacle_Source PerceptionObstacle::Source_MIN;
constexpr PerceptionObstacle_Source PerceptionObstacle::Source_MAX;
constexpr int PerceptionObstacle::Source_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class BBox2D::_Internal {
 public:
};

BBox2D::BBox2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.perception.BBox2D)
}
BBox2D::BBox2D(const BBox2D& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&xmin_, &from.xmin_,
    static_cast<size_t>(reinterpret_cast<char*>(&ymax_) -
    reinterpret_cast<char*>(&xmin_)) + sizeof(ymax_));
  // @@protoc_insertion_point(copy_constructor:autoagric.perception.BBox2D)
}

inline void BBox2D::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&xmin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ymax_) -
    reinterpret_cast<char*>(&xmin_)) + sizeof(ymax_));
}

BBox2D::~BBox2D() {
  // @@protoc_insertion_point(destructor:autoagric.perception.BBox2D)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BBox2D::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BBox2D::ArenaDtor(void* object) {
  BBox2D* _this = reinterpret_cast< BBox2D* >(object);
  (void)_this;
}
void BBox2D::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BBox2D::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BBox2D::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.perception.BBox2D)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&xmin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ymax_) -
      reinterpret_cast<char*>(&xmin_)) + sizeof(ymax_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BBox2D::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double xmin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          xmin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double ymin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          ymin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double xmax = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          xmax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double ymax = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          ymax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BBox2D::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.perception.BBox2D)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double xmin = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_xmin = this->_internal_xmin();
  uint64_t raw_xmin;
  memcpy(&raw_xmin, &tmp_xmin, sizeof(tmp_xmin));
  if (raw_xmin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_xmin(), target);
  }

  // double ymin = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ymin = this->_internal_ymin();
  uint64_t raw_ymin;
  memcpy(&raw_ymin, &tmp_ymin, sizeof(tmp_ymin));
  if (raw_ymin != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_ymin(), target);
  }

  // double xmax = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_xmax = this->_internal_xmax();
  uint64_t raw_xmax;
  memcpy(&raw_xmax, &tmp_xmax, sizeof(tmp_xmax));
  if (raw_xmax != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_xmax(), target);
  }

  // double ymax = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ymax = this->_internal_ymax();
  uint64_t raw_ymax;
  memcpy(&raw_ymax, &tmp_ymax, sizeof(tmp_ymax));
  if (raw_ymax != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_ymax(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.perception.BBox2D)
  return target;
}

size_t BBox2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.perception.BBox2D)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double xmin = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_xmin = this->_internal_xmin();
  uint64_t raw_xmin;
  memcpy(&raw_xmin, &tmp_xmin, sizeof(tmp_xmin));
  if (raw_xmin != 0) {
    total_size += 1 + 8;
  }

  // double ymin = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ymin = this->_internal_ymin();
  uint64_t raw_ymin;
  memcpy(&raw_ymin, &tmp_ymin, sizeof(tmp_ymin));
  if (raw_ymin != 0) {
    total_size += 1 + 8;
  }

  // double xmax = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_xmax = this->_internal_xmax();
  uint64_t raw_xmax;
  memcpy(&raw_xmax, &tmp_xmax, sizeof(tmp_xmax));
  if (raw_xmax != 0) {
    total_size += 1 + 8;
  }

  // double ymax = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ymax = this->_internal_ymax();
  uint64_t raw_ymax;
  memcpy(&raw_ymax, &tmp_ymax, sizeof(tmp_ymax));
  if (raw_ymax != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BBox2D::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BBox2D::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BBox2D::GetClassData() const { return &_class_data_; }

void BBox2D::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BBox2D *>(to)->MergeFrom(
      static_cast<const BBox2D &>(from));
}


void BBox2D::MergeFrom(const BBox2D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.perception.BBox2D)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_xmin = from._internal_xmin();
  uint64_t raw_xmin;
  memcpy(&raw_xmin, &tmp_xmin, sizeof(tmp_xmin));
  if (raw_xmin != 0) {
    _internal_set_xmin(from._internal_xmin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ymin = from._internal_ymin();
  uint64_t raw_ymin;
  memcpy(&raw_ymin, &tmp_ymin, sizeof(tmp_ymin));
  if (raw_ymin != 0) {
    _internal_set_ymin(from._internal_ymin());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_xmax = from._internal_xmax();
  uint64_t raw_xmax;
  memcpy(&raw_xmax, &tmp_xmax, sizeof(tmp_xmax));
  if (raw_xmax != 0) {
    _internal_set_xmax(from._internal_xmax());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ymax = from._internal_ymax();
  uint64_t raw_ymax;
  memcpy(&raw_ymax, &tmp_ymax, sizeof(tmp_ymax));
  if (raw_ymax != 0) {
    _internal_set_ymax(from._internal_ymax());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BBox2D::CopyFrom(const BBox2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.perception.BBox2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BBox2D::IsInitialized() const {
  return true;
}

void BBox2D::InternalSwap(BBox2D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BBox2D, ymax_)
      + sizeof(BBox2D::ymax_)
      - PROTOBUF_FIELD_OFFSET(BBox2D, xmin_)>(
          reinterpret_cast<char*>(&xmin_),
          reinterpret_cast<char*>(&other->xmin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BBox2D::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_getter, &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_once,
      file_level_metadata_autoagric_2fperception_2fperception_5fobstacle_2eproto[0]);
}

// ===================================================================

class LightStatus::_Internal {
 public:
};

LightStatus::LightStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.perception.LightStatus)
}
LightStatus::LightStatus(const LightStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&brake_visible_, &from.brake_visible_,
    static_cast<size_t>(reinterpret_cast<char*>(&right_turn_switch_on_) -
    reinterpret_cast<char*>(&brake_visible_)) + sizeof(right_turn_switch_on_));
  // @@protoc_insertion_point(copy_constructor:autoagric.perception.LightStatus)
}

inline void LightStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&brake_visible_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&right_turn_switch_on_) -
    reinterpret_cast<char*>(&brake_visible_)) + sizeof(right_turn_switch_on_));
}

LightStatus::~LightStatus() {
  // @@protoc_insertion_point(destructor:autoagric.perception.LightStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LightStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LightStatus::ArenaDtor(void* object) {
  LightStatus* _this = reinterpret_cast< LightStatus* >(object);
  (void)_this;
}
void LightStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LightStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LightStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.perception.LightStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&brake_visible_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&right_turn_switch_on_) -
      reinterpret_cast<char*>(&brake_visible_)) + sizeof(right_turn_switch_on_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LightStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double brake_visible = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          brake_visible_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double brake_switch_on = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          brake_switch_on_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double left_turn_visible = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          left_turn_visible_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double left_turn_switch_on = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          left_turn_switch_on_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double right_turn_visible = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          right_turn_visible_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double right_turn_switch_on = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          right_turn_switch_on_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LightStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.perception.LightStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double brake_visible = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_brake_visible = this->_internal_brake_visible();
  uint64_t raw_brake_visible;
  memcpy(&raw_brake_visible, &tmp_brake_visible, sizeof(tmp_brake_visible));
  if (raw_brake_visible != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_brake_visible(), target);
  }

  // double brake_switch_on = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_brake_switch_on = this->_internal_brake_switch_on();
  uint64_t raw_brake_switch_on;
  memcpy(&raw_brake_switch_on, &tmp_brake_switch_on, sizeof(tmp_brake_switch_on));
  if (raw_brake_switch_on != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_brake_switch_on(), target);
  }

  // double left_turn_visible = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left_turn_visible = this->_internal_left_turn_visible();
  uint64_t raw_left_turn_visible;
  memcpy(&raw_left_turn_visible, &tmp_left_turn_visible, sizeof(tmp_left_turn_visible));
  if (raw_left_turn_visible != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_left_turn_visible(), target);
  }

  // double left_turn_switch_on = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left_turn_switch_on = this->_internal_left_turn_switch_on();
  uint64_t raw_left_turn_switch_on;
  memcpy(&raw_left_turn_switch_on, &tmp_left_turn_switch_on, sizeof(tmp_left_turn_switch_on));
  if (raw_left_turn_switch_on != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_left_turn_switch_on(), target);
  }

  // double right_turn_visible = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right_turn_visible = this->_internal_right_turn_visible();
  uint64_t raw_right_turn_visible;
  memcpy(&raw_right_turn_visible, &tmp_right_turn_visible, sizeof(tmp_right_turn_visible));
  if (raw_right_turn_visible != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_right_turn_visible(), target);
  }

  // double right_turn_switch_on = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right_turn_switch_on = this->_internal_right_turn_switch_on();
  uint64_t raw_right_turn_switch_on;
  memcpy(&raw_right_turn_switch_on, &tmp_right_turn_switch_on, sizeof(tmp_right_turn_switch_on));
  if (raw_right_turn_switch_on != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_right_turn_switch_on(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.perception.LightStatus)
  return target;
}

size_t LightStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.perception.LightStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double brake_visible = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_brake_visible = this->_internal_brake_visible();
  uint64_t raw_brake_visible;
  memcpy(&raw_brake_visible, &tmp_brake_visible, sizeof(tmp_brake_visible));
  if (raw_brake_visible != 0) {
    total_size += 1 + 8;
  }

  // double brake_switch_on = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_brake_switch_on = this->_internal_brake_switch_on();
  uint64_t raw_brake_switch_on;
  memcpy(&raw_brake_switch_on, &tmp_brake_switch_on, sizeof(tmp_brake_switch_on));
  if (raw_brake_switch_on != 0) {
    total_size += 1 + 8;
  }

  // double left_turn_visible = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left_turn_visible = this->_internal_left_turn_visible();
  uint64_t raw_left_turn_visible;
  memcpy(&raw_left_turn_visible, &tmp_left_turn_visible, sizeof(tmp_left_turn_visible));
  if (raw_left_turn_visible != 0) {
    total_size += 1 + 8;
  }

  // double left_turn_switch_on = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left_turn_switch_on = this->_internal_left_turn_switch_on();
  uint64_t raw_left_turn_switch_on;
  memcpy(&raw_left_turn_switch_on, &tmp_left_turn_switch_on, sizeof(tmp_left_turn_switch_on));
  if (raw_left_turn_switch_on != 0) {
    total_size += 1 + 8;
  }

  // double right_turn_visible = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right_turn_visible = this->_internal_right_turn_visible();
  uint64_t raw_right_turn_visible;
  memcpy(&raw_right_turn_visible, &tmp_right_turn_visible, sizeof(tmp_right_turn_visible));
  if (raw_right_turn_visible != 0) {
    total_size += 1 + 8;
  }

  // double right_turn_switch_on = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right_turn_switch_on = this->_internal_right_turn_switch_on();
  uint64_t raw_right_turn_switch_on;
  memcpy(&raw_right_turn_switch_on, &tmp_right_turn_switch_on, sizeof(tmp_right_turn_switch_on));
  if (raw_right_turn_switch_on != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LightStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LightStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LightStatus::GetClassData() const { return &_class_data_; }

void LightStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LightStatus *>(to)->MergeFrom(
      static_cast<const LightStatus &>(from));
}


void LightStatus::MergeFrom(const LightStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.perception.LightStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_brake_visible = from._internal_brake_visible();
  uint64_t raw_brake_visible;
  memcpy(&raw_brake_visible, &tmp_brake_visible, sizeof(tmp_brake_visible));
  if (raw_brake_visible != 0) {
    _internal_set_brake_visible(from._internal_brake_visible());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_brake_switch_on = from._internal_brake_switch_on();
  uint64_t raw_brake_switch_on;
  memcpy(&raw_brake_switch_on, &tmp_brake_switch_on, sizeof(tmp_brake_switch_on));
  if (raw_brake_switch_on != 0) {
    _internal_set_brake_switch_on(from._internal_brake_switch_on());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left_turn_visible = from._internal_left_turn_visible();
  uint64_t raw_left_turn_visible;
  memcpy(&raw_left_turn_visible, &tmp_left_turn_visible, sizeof(tmp_left_turn_visible));
  if (raw_left_turn_visible != 0) {
    _internal_set_left_turn_visible(from._internal_left_turn_visible());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left_turn_switch_on = from._internal_left_turn_switch_on();
  uint64_t raw_left_turn_switch_on;
  memcpy(&raw_left_turn_switch_on, &tmp_left_turn_switch_on, sizeof(tmp_left_turn_switch_on));
  if (raw_left_turn_switch_on != 0) {
    _internal_set_left_turn_switch_on(from._internal_left_turn_switch_on());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right_turn_visible = from._internal_right_turn_visible();
  uint64_t raw_right_turn_visible;
  memcpy(&raw_right_turn_visible, &tmp_right_turn_visible, sizeof(tmp_right_turn_visible));
  if (raw_right_turn_visible != 0) {
    _internal_set_right_turn_visible(from._internal_right_turn_visible());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right_turn_switch_on = from._internal_right_turn_switch_on();
  uint64_t raw_right_turn_switch_on;
  memcpy(&raw_right_turn_switch_on, &tmp_right_turn_switch_on, sizeof(tmp_right_turn_switch_on));
  if (raw_right_turn_switch_on != 0) {
    _internal_set_right_turn_switch_on(from._internal_right_turn_switch_on());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LightStatus::CopyFrom(const LightStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.perception.LightStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LightStatus::IsInitialized() const {
  return true;
}

void LightStatus::InternalSwap(LightStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LightStatus, right_turn_switch_on_)
      + sizeof(LightStatus::right_turn_switch_on_)
      - PROTOBUF_FIELD_OFFSET(LightStatus, brake_visible_)>(
          reinterpret_cast<char*>(&brake_visible_),
          reinterpret_cast<char*>(&other->brake_visible_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LightStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_getter, &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_once,
      file_level_metadata_autoagric_2fperception_2fperception_5fobstacle_2eproto[1]);
}

// ===================================================================

class V2XInformation::_Internal {
 public:
};

V2XInformation::V2XInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  v2x_type_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.perception.V2XInformation)
}
V2XInformation::V2XInformation(const V2XInformation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      v2x_type_(from.v2x_type_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autoagric.perception.V2XInformation)
}

inline void V2XInformation::SharedCtor() {
}

V2XInformation::~V2XInformation() {
  // @@protoc_insertion_point(destructor:autoagric.perception.V2XInformation)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void V2XInformation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void V2XInformation::ArenaDtor(void* object) {
  V2XInformation* _this = reinterpret_cast< V2XInformation* >(object);
  (void)_this;
}
void V2XInformation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void V2XInformation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void V2XInformation::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.perception.V2XInformation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  v2x_type_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* V2XInformation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autoagric.perception.V2XInformation.V2XType v2x_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_v2x_type(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_v2x_type(static_cast<::autoagric::perception::V2XInformation_V2XType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* V2XInformation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.perception.V2XInformation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autoagric.perception.V2XInformation.V2XType v2x_type = 1;
  {
    int byte_size = _v2x_type_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, v2x_type_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.perception.V2XInformation)
  return target;
}

size_t V2XInformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.perception.V2XInformation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autoagric.perception.V2XInformation.V2XType v2x_type = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_v2x_type_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_v2x_type(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _v2x_type_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData V2XInformation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    V2XInformation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*V2XInformation::GetClassData() const { return &_class_data_; }

void V2XInformation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<V2XInformation *>(to)->MergeFrom(
      static_cast<const V2XInformation &>(from));
}


void V2XInformation::MergeFrom(const V2XInformation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.perception.V2XInformation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  v2x_type_.MergeFrom(from.v2x_type_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void V2XInformation::CopyFrom(const V2XInformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.perception.V2XInformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V2XInformation::IsInitialized() const {
  return true;
}

void V2XInformation::InternalSwap(V2XInformation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  v2x_type_.InternalSwap(&other->v2x_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata V2XInformation::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_getter, &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_once,
      file_level_metadata_autoagric_2fperception_2fperception_5fobstacle_2eproto[2]);
}

// ===================================================================

class SensorMeasurement::_Internal {
 public:
  static const ::autoagric::common::Point3D& position(const SensorMeasurement* msg);
  static const ::autoagric::common::Point3D& velocity(const SensorMeasurement* msg);
  static const ::autoagric::perception::BBox2D& box(const SensorMeasurement* msg);
};

const ::autoagric::common::Point3D&
SensorMeasurement::_Internal::position(const SensorMeasurement* msg) {
  return *msg->position_;
}
const ::autoagric::common::Point3D&
SensorMeasurement::_Internal::velocity(const SensorMeasurement* msg) {
  return *msg->velocity_;
}
const ::autoagric::perception::BBox2D&
SensorMeasurement::_Internal::box(const SensorMeasurement* msg) {
  return *msg->box_;
}
void SensorMeasurement::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
void SensorMeasurement::clear_velocity() {
  if (GetArenaForAllocation() == nullptr && velocity_ != nullptr) {
    delete velocity_;
  }
  velocity_ = nullptr;
}
SensorMeasurement::SensorMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.perception.SensorMeasurement)
}
SensorMeasurement::SensorMeasurement(const SensorMeasurement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sensor_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sensor_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sensor_id().empty()) {
    sensor_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sensor_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_position()) {
    position_ = new ::autoagric::common::Point3D(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from._internal_has_velocity()) {
    velocity_ = new ::autoagric::common::Point3D(*from.velocity_);
  } else {
    velocity_ = nullptr;
  }
  if (from._internal_has_box()) {
    box_ = new ::autoagric::perception::BBox2D(*from.box_);
  } else {
    box_ = nullptr;
  }
  ::memcpy(&theta_, &from.theta_,
    static_cast<size_t>(reinterpret_cast<char*>(&sub_type_) -
    reinterpret_cast<char*>(&theta_)) + sizeof(sub_type_));
  // @@protoc_insertion_point(copy_constructor:autoagric.perception.SensorMeasurement)
}

inline void SensorMeasurement::SharedCtor() {
sensor_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sensor_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&position_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sub_type_) -
    reinterpret_cast<char*>(&position_)) + sizeof(sub_type_));
}

SensorMeasurement::~SensorMeasurement() {
  // @@protoc_insertion_point(destructor:autoagric.perception.SensorMeasurement)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SensorMeasurement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sensor_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete velocity_;
  if (this != internal_default_instance()) delete box_;
}

void SensorMeasurement::ArenaDtor(void* object) {
  SensorMeasurement* _this = reinterpret_cast< SensorMeasurement* >(object);
  (void)_this;
}
void SensorMeasurement::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SensorMeasurement::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SensorMeasurement::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.perception.SensorMeasurement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sensor_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && velocity_ != nullptr) {
    delete velocity_;
  }
  velocity_ = nullptr;
  if (GetArenaForAllocation() == nullptr && box_ != nullptr) {
    delete box_;
  }
  box_ = nullptr;
  ::memset(&theta_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sub_type_) -
      reinterpret_cast<char*>(&theta_)) + sizeof(sub_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorMeasurement::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string sensor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sensor_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "autoagric.perception.SensorMeasurement.sensor_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.Point3D position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double theta = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          theta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double width = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double height = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.Point3D velocity = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.PerceptionObstacle.Type type = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::autoagric::perception::PerceptionObstacle_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.PerceptionObstacle.SubType sub_type = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sub_type(static_cast<::autoagric::perception::PerceptionObstacle_SubType>(val));
        } else
          goto handle_unusual;
        continue;
      // double timestamp = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.BBox2D box = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_box(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SensorMeasurement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.perception.SensorMeasurement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string sensor_id = 1;
  if (!this->_internal_sensor_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sensor_id().data(), static_cast<int>(this->_internal_sensor_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "autoagric.perception.SensorMeasurement.sensor_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sensor_id(), target);
  }

  // int32 id = 2;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_id(), target);
  }

  // .autoagric.common.Point3D position = 3;
  if (this->_internal_has_position()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::position(this), target, stream);
  }

  // double theta = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_theta = this->_internal_theta();
  uint64_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_theta(), target);
  }

  // double length = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_length(), target);
  }

  // double width = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = this->_internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_width(), target);
  }

  // double height = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_height = this->_internal_height();
  uint64_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_height(), target);
  }

  // .autoagric.common.Point3D velocity = 8;
  if (this->_internal_has_velocity()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::velocity(this), target, stream);
  }

  // .autoagric.perception.PerceptionObstacle.Type type = 9;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_type(), target);
  }

  // .autoagric.perception.PerceptionObstacle.SubType sub_type = 10;
  if (this->_internal_sub_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_sub_type(), target);
  }

  // double timestamp = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_timestamp = this->_internal_timestamp();
  uint64_t raw_timestamp;
  memcpy(&raw_timestamp, &tmp_timestamp, sizeof(tmp_timestamp));
  if (raw_timestamp != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(11, this->_internal_timestamp(), target);
  }

  // .autoagric.perception.BBox2D box = 12;
  if (this->_internal_has_box()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::box(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.perception.SensorMeasurement)
  return target;
}

size_t SensorMeasurement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.perception.SensorMeasurement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string sensor_id = 1;
  if (!this->_internal_sensor_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sensor_id());
  }

  // .autoagric.common.Point3D position = 3;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // .autoagric.common.Point3D velocity = 8;
  if (this->_internal_has_velocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *velocity_);
  }

  // .autoagric.perception.BBox2D box = 12;
  if (this->_internal_has_box()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *box_);
  }

  // double theta = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_theta = this->_internal_theta();
  uint64_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    total_size += 1 + 8;
  }

  // double length = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    total_size += 1 + 8;
  }

  // int32 id = 2;
  if (this->_internal_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // .autoagric.perception.PerceptionObstacle.Type type = 9;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  // double width = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = this->_internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    total_size += 1 + 8;
  }

  // double height = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_height = this->_internal_height();
  uint64_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    total_size += 1 + 8;
  }

  // double timestamp = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_timestamp = this->_internal_timestamp();
  uint64_t raw_timestamp;
  memcpy(&raw_timestamp, &tmp_timestamp, sizeof(tmp_timestamp));
  if (raw_timestamp != 0) {
    total_size += 1 + 8;
  }

  // .autoagric.perception.PerceptionObstacle.SubType sub_type = 10;
  if (this->_internal_sub_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_sub_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SensorMeasurement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SensorMeasurement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SensorMeasurement::GetClassData() const { return &_class_data_; }

void SensorMeasurement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SensorMeasurement *>(to)->MergeFrom(
      static_cast<const SensorMeasurement &>(from));
}


void SensorMeasurement::MergeFrom(const SensorMeasurement& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.perception.SensorMeasurement)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sensor_id().empty()) {
    _internal_set_sensor_id(from._internal_sensor_id());
  }
  if (from._internal_has_position()) {
    _internal_mutable_position()->::autoagric::common::Point3D::MergeFrom(from._internal_position());
  }
  if (from._internal_has_velocity()) {
    _internal_mutable_velocity()->::autoagric::common::Point3D::MergeFrom(from._internal_velocity());
  }
  if (from._internal_has_box()) {
    _internal_mutable_box()->::autoagric::perception::BBox2D::MergeFrom(from._internal_box());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_theta = from._internal_theta();
  uint64_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    _internal_set_theta(from._internal_theta());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = from._internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    _internal_set_length(from._internal_length());
  }
  if (from._internal_id() != 0) {
    _internal_set_id(from._internal_id());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = from._internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    _internal_set_width(from._internal_width());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_height = from._internal_height();
  uint64_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    _internal_set_height(from._internal_height());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_timestamp = from._internal_timestamp();
  uint64_t raw_timestamp;
  memcpy(&raw_timestamp, &tmp_timestamp, sizeof(tmp_timestamp));
  if (raw_timestamp != 0) {
    _internal_set_timestamp(from._internal_timestamp());
  }
  if (from._internal_sub_type() != 0) {
    _internal_set_sub_type(from._internal_sub_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SensorMeasurement::CopyFrom(const SensorMeasurement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.perception.SensorMeasurement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorMeasurement::IsInitialized() const {
  return true;
}

void SensorMeasurement::InternalSwap(SensorMeasurement* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sensor_id_, lhs_arena,
      &other->sensor_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorMeasurement, sub_type_)
      + sizeof(SensorMeasurement::sub_type_)
      - PROTOBUF_FIELD_OFFSET(SensorMeasurement, position_)>(
          reinterpret_cast<char*>(&position_),
          reinterpret_cast<char*>(&other->position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorMeasurement::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_getter, &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_once,
      file_level_metadata_autoagric_2fperception_2fperception_5fobstacle_2eproto[3]);
}

// ===================================================================

class Trajectory::_Internal {
 public:
};

void Trajectory::clear_trajectory_point() {
  trajectory_point_.Clear();
}
Trajectory::Trajectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  trajectory_point_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.perception.Trajectory)
}
Trajectory::Trajectory(const Trajectory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      trajectory_point_(from.trajectory_point_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  probability_ = from.probability_;
  // @@protoc_insertion_point(copy_constructor:autoagric.perception.Trajectory)
}

inline void Trajectory::SharedCtor() {
probability_ = 0;
}

Trajectory::~Trajectory() {
  // @@protoc_insertion_point(destructor:autoagric.perception.Trajectory)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Trajectory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Trajectory::ArenaDtor(void* object) {
  Trajectory* _this = reinterpret_cast< Trajectory* >(object);
  (void)_this;
}
void Trajectory::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Trajectory::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Trajectory::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.perception.Trajectory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  trajectory_point_.Clear();
  probability_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Trajectory::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double probability = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .autoagric.common.TrajectoryPoint trajectory_point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trajectory_point(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Trajectory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.perception.Trajectory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double probability = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_probability = this->_internal_probability();
  uint64_t raw_probability;
  memcpy(&raw_probability, &tmp_probability, sizeof(tmp_probability));
  if (raw_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_probability(), target);
  }

  // repeated .autoagric.common.TrajectoryPoint trajectory_point = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_trajectory_point_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_trajectory_point(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.perception.Trajectory)
  return target;
}

size_t Trajectory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.perception.Trajectory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autoagric.common.TrajectoryPoint trajectory_point = 2;
  total_size += 1UL * this->_internal_trajectory_point_size();
  for (const auto& msg : this->trajectory_point_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // double probability = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_probability = this->_internal_probability();
  uint64_t raw_probability;
  memcpy(&raw_probability, &tmp_probability, sizeof(tmp_probability));
  if (raw_probability != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Trajectory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Trajectory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Trajectory::GetClassData() const { return &_class_data_; }

void Trajectory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Trajectory *>(to)->MergeFrom(
      static_cast<const Trajectory &>(from));
}


void Trajectory::MergeFrom(const Trajectory& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.perception.Trajectory)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  trajectory_point_.MergeFrom(from.trajectory_point_);
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_probability = from._internal_probability();
  uint64_t raw_probability;
  memcpy(&raw_probability, &tmp_probability, sizeof(tmp_probability));
  if (raw_probability != 0) {
    _internal_set_probability(from._internal_probability());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Trajectory::CopyFrom(const Trajectory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.perception.Trajectory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trajectory::IsInitialized() const {
  return true;
}

void Trajectory::InternalSwap(Trajectory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  trajectory_point_.InternalSwap(&other->trajectory_point_);
  swap(probability_, other->probability_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Trajectory::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_getter, &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_once,
      file_level_metadata_autoagric_2fperception_2fperception_5fobstacle_2eproto[4]);
}

// ===================================================================

class DebugMessage::_Internal {
 public:
};

DebugMessage::DebugMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  trajectory_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.perception.DebugMessage)
}
DebugMessage::DebugMessage(const DebugMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      trajectory_(from.trajectory_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autoagric.perception.DebugMessage)
}

inline void DebugMessage::SharedCtor() {
}

DebugMessage::~DebugMessage() {
  // @@protoc_insertion_point(destructor:autoagric.perception.DebugMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DebugMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DebugMessage::ArenaDtor(void* object) {
  DebugMessage* _this = reinterpret_cast< DebugMessage* >(object);
  (void)_this;
}
void DebugMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DebugMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DebugMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.perception.DebugMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  trajectory_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DebugMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autoagric.perception.Trajectory trajectory = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trajectory(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DebugMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.perception.DebugMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autoagric.perception.Trajectory trajectory = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_trajectory_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_trajectory(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.perception.DebugMessage)
  return target;
}

size_t DebugMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.perception.DebugMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autoagric.perception.Trajectory trajectory = 1;
  total_size += 1UL * this->_internal_trajectory_size();
  for (const auto& msg : this->trajectory_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DebugMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DebugMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DebugMessage::GetClassData() const { return &_class_data_; }

void DebugMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DebugMessage *>(to)->MergeFrom(
      static_cast<const DebugMessage &>(from));
}


void DebugMessage::MergeFrom(const DebugMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.perception.DebugMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  trajectory_.MergeFrom(from.trajectory_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DebugMessage::CopyFrom(const DebugMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.perception.DebugMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugMessage::IsInitialized() const {
  return true;
}

void DebugMessage::InternalSwap(DebugMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  trajectory_.InternalSwap(&other->trajectory_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DebugMessage::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_getter, &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_once,
      file_level_metadata_autoagric_2fperception_2fperception_5fobstacle_2eproto[5]);
}

// ===================================================================

class PerceptionObstacle::_Internal {
 public:
  static const ::autoagric::common::Point3D& position(const PerceptionObstacle* msg);
  static const ::autoagric::common::Point3D& velocity(const PerceptionObstacle* msg);
  static const ::autoagric::common::Point3D& acceleration(const PerceptionObstacle* msg);
  static const ::autoagric::common::Point3D& anchor_point(const PerceptionObstacle* msg);
  static const ::autoagric::perception::BBox2D& bbox2d(const PerceptionObstacle* msg);
  static const ::autoagric::perception::LightStatus& light_status(const PerceptionObstacle* msg);
  static const ::autoagric::perception::DebugMessage& msg(const PerceptionObstacle* msg);
  static const ::autoagric::perception::V2XInformation& v2x_info(const PerceptionObstacle* msg);
};

const ::autoagric::common::Point3D&
PerceptionObstacle::_Internal::position(const PerceptionObstacle* msg) {
  return *msg->position_;
}
const ::autoagric::common::Point3D&
PerceptionObstacle::_Internal::velocity(const PerceptionObstacle* msg) {
  return *msg->velocity_;
}
const ::autoagric::common::Point3D&
PerceptionObstacle::_Internal::acceleration(const PerceptionObstacle* msg) {
  return *msg->acceleration_;
}
const ::autoagric::common::Point3D&
PerceptionObstacle::_Internal::anchor_point(const PerceptionObstacle* msg) {
  return *msg->anchor_point_;
}
const ::autoagric::perception::BBox2D&
PerceptionObstacle::_Internal::bbox2d(const PerceptionObstacle* msg) {
  return *msg->bbox2d_;
}
const ::autoagric::perception::LightStatus&
PerceptionObstacle::_Internal::light_status(const PerceptionObstacle* msg) {
  return *msg->light_status_;
}
const ::autoagric::perception::DebugMessage&
PerceptionObstacle::_Internal::msg(const PerceptionObstacle* msg) {
  return *msg->msg_;
}
const ::autoagric::perception::V2XInformation&
PerceptionObstacle::_Internal::v2x_info(const PerceptionObstacle* msg) {
  return *msg->v2x_info_;
}
void PerceptionObstacle::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
void PerceptionObstacle::clear_velocity() {
  if (GetArenaForAllocation() == nullptr && velocity_ != nullptr) {
    delete velocity_;
  }
  velocity_ = nullptr;
}
void PerceptionObstacle::clear_polygon_point() {
  polygon_point_.Clear();
}
void PerceptionObstacle::clear_drops() {
  drops_.Clear();
}
void PerceptionObstacle::clear_acceleration() {
  if (GetArenaForAllocation() == nullptr && acceleration_ != nullptr) {
    delete acceleration_;
  }
  acceleration_ = nullptr;
}
void PerceptionObstacle::clear_anchor_point() {
  if (GetArenaForAllocation() == nullptr && anchor_point_ != nullptr) {
    delete anchor_point_;
  }
  anchor_point_ = nullptr;
}
PerceptionObstacle::PerceptionObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  polygon_point_(arena),
  point_cloud_(arena),
  drops_(arena),
  measurements_(arena),
  position_covariance_(arena),
  velocity_covariance_(arena),
  acceleration_covariance_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.perception.PerceptionObstacle)
}
PerceptionObstacle::PerceptionObstacle(const PerceptionObstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      polygon_point_(from.polygon_point_),
      point_cloud_(from.point_cloud_),
      drops_(from.drops_),
      measurements_(from.measurements_),
      position_covariance_(from.position_covariance_),
      velocity_covariance_(from.velocity_covariance_),
      acceleration_covariance_(from.acceleration_covariance_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    position_ = new ::autoagric::common::Point3D(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from._internal_has_velocity()) {
    velocity_ = new ::autoagric::common::Point3D(*from.velocity_);
  } else {
    velocity_ = nullptr;
  }
  if (from._internal_has_acceleration()) {
    acceleration_ = new ::autoagric::common::Point3D(*from.acceleration_);
  } else {
    acceleration_ = nullptr;
  }
  if (from._internal_has_anchor_point()) {
    anchor_point_ = new ::autoagric::common::Point3D(*from.anchor_point_);
  } else {
    anchor_point_ = nullptr;
  }
  if (from._internal_has_bbox2d()) {
    bbox2d_ = new ::autoagric::perception::BBox2D(*from.bbox2d_);
  } else {
    bbox2d_ = nullptr;
  }
  if (from._internal_has_light_status()) {
    light_status_ = new ::autoagric::perception::LightStatus(*from.light_status_);
  } else {
    light_status_ = nullptr;
  }
  if (from._internal_has_msg()) {
    msg_ = new ::autoagric::perception::DebugMessage(*from.msg_);
  } else {
    msg_ = nullptr;
  }
  if (from._internal_has_v2x_info()) {
    v2x_info_ = new ::autoagric::perception::V2XInformation(*from.v2x_info_);
  } else {
    v2x_info_ = nullptr;
  }
  ::memcpy(&theta_, &from.theta_,
    static_cast<size_t>(reinterpret_cast<char*>(&source_) -
    reinterpret_cast<char*>(&theta_)) + sizeof(source_));
  // @@protoc_insertion_point(copy_constructor:autoagric.perception.PerceptionObstacle)
}

inline void PerceptionObstacle::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&position_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&source_) -
    reinterpret_cast<char*>(&position_)) + sizeof(source_));
}

PerceptionObstacle::~PerceptionObstacle() {
  // @@protoc_insertion_point(destructor:autoagric.perception.PerceptionObstacle)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PerceptionObstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete velocity_;
  if (this != internal_default_instance()) delete acceleration_;
  if (this != internal_default_instance()) delete anchor_point_;
  if (this != internal_default_instance()) delete bbox2d_;
  if (this != internal_default_instance()) delete light_status_;
  if (this != internal_default_instance()) delete msg_;
  if (this != internal_default_instance()) delete v2x_info_;
}

void PerceptionObstacle::ArenaDtor(void* object) {
  PerceptionObstacle* _this = reinterpret_cast< PerceptionObstacle* >(object);
  (void)_this;
}
void PerceptionObstacle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PerceptionObstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PerceptionObstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.perception.PerceptionObstacle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  polygon_point_.Clear();
  point_cloud_.Clear();
  drops_.Clear();
  measurements_.Clear();
  position_covariance_.Clear();
  velocity_covariance_.Clear();
  acceleration_covariance_.Clear();
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && velocity_ != nullptr) {
    delete velocity_;
  }
  velocity_ = nullptr;
  if (GetArenaForAllocation() == nullptr && acceleration_ != nullptr) {
    delete acceleration_;
  }
  acceleration_ = nullptr;
  if (GetArenaForAllocation() == nullptr && anchor_point_ != nullptr) {
    delete anchor_point_;
  }
  anchor_point_ = nullptr;
  if (GetArenaForAllocation() == nullptr && bbox2d_ != nullptr) {
    delete bbox2d_;
  }
  bbox2d_ = nullptr;
  if (GetArenaForAllocation() == nullptr && light_status_ != nullptr) {
    delete light_status_;
  }
  light_status_ = nullptr;
  if (GetArenaForAllocation() == nullptr && msg_ != nullptr) {
    delete msg_;
  }
  msg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && v2x_info_ != nullptr) {
    delete v2x_info_;
  }
  v2x_info_ = nullptr;
  ::memset(&theta_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&source_) -
      reinterpret_cast<char*>(&theta_)) + sizeof(source_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PerceptionObstacle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.Point3D position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double theta = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          theta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.Point3D velocity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double width = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double height = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .autoagric.common.Point3D polygon_point = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_polygon_point(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // double tracking_time = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          tracking_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.PerceptionObstacle.Type type = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::autoagric::perception::PerceptionObstacle_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // double timestamp = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double point_cloud = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_point_cloud(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 97) {
          _internal_add_point_cloud(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double confidence = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.PerceptionObstacle.ConfidenceType confidence_type = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_confidence_type(static_cast<::autoagric::perception::PerceptionObstacle_ConfidenceType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .autoagric.common.Point3D drops = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drops(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.Point3D acceleration = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_acceleration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.Point3D anchor_point = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_anchor_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.BBox2D bbox2d = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_bbox2d(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.PerceptionObstacle.SubType sub_type = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sub_type(static_cast<::autoagric::perception::PerceptionObstacle_SubType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .autoagric.perception.SensorMeasurement measurements = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_measurements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // double height_above_ground = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          height_above_ground_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double position_covariance = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_position_covariance(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 177) {
          _internal_add_position_covariance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double velocity_covariance = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_velocity_covariance(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 185) {
          _internal_add_velocity_covariance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double acceleration_covariance = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_acceleration_covariance(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 193) {
          _internal_add_acceleration_covariance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.LightStatus light_status = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_light_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.DebugMessage msg = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.PerceptionObstacle.Source source = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_source(static_cast<::autoagric::perception::PerceptionObstacle_Source>(val));
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.V2XInformation v2x_info = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_v2x_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PerceptionObstacle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.perception.PerceptionObstacle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // .autoagric.common.Point3D position = 2;
  if (this->_internal_has_position()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::position(this), target, stream);
  }

  // double theta = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_theta = this->_internal_theta();
  uint64_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_theta(), target);
  }

  // .autoagric.common.Point3D velocity = 4;
  if (this->_internal_has_velocity()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::velocity(this), target, stream);
  }

  // double length = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_length(), target);
  }

  // double width = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = this->_internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_width(), target);
  }

  // double height = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_height = this->_internal_height();
  uint64_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_height(), target);
  }

  // repeated .autoagric.common.Point3D polygon_point = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_polygon_point_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_polygon_point(i), target, stream);
  }

  // double tracking_time = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tracking_time = this->_internal_tracking_time();
  uint64_t raw_tracking_time;
  memcpy(&raw_tracking_time, &tmp_tracking_time, sizeof(tmp_tracking_time));
  if (raw_tracking_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(9, this->_internal_tracking_time(), target);
  }

  // .autoagric.perception.PerceptionObstacle.Type type = 10;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_type(), target);
  }

  // double timestamp = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_timestamp = this->_internal_timestamp();
  uint64_t raw_timestamp;
  memcpy(&raw_timestamp, &tmp_timestamp, sizeof(tmp_timestamp));
  if (raw_timestamp != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(11, this->_internal_timestamp(), target);
  }

  // repeated double point_cloud = 12;
  if (this->_internal_point_cloud_size() > 0) {
    target = stream->WriteFixedPacked(12, _internal_point_cloud(), target);
  }

  // double confidence = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = this->_internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(13, this->_internal_confidence(), target);
  }

  // .autoagric.perception.PerceptionObstacle.ConfidenceType confidence_type = 14;
  if (this->_internal_confidence_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      14, this->_internal_confidence_type(), target);
  }

  // repeated .autoagric.common.Point3D drops = 15;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_drops_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, this->_internal_drops(i), target, stream);
  }

  // .autoagric.common.Point3D acceleration = 16;
  if (this->_internal_has_acceleration()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        16, _Internal::acceleration(this), target, stream);
  }

  // .autoagric.common.Point3D anchor_point = 17;
  if (this->_internal_has_anchor_point()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::anchor_point(this), target, stream);
  }

  // .autoagric.perception.BBox2D bbox2d = 18;
  if (this->_internal_has_bbox2d()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        18, _Internal::bbox2d(this), target, stream);
  }

  // .autoagric.perception.PerceptionObstacle.SubType sub_type = 19;
  if (this->_internal_sub_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      19, this->_internal_sub_type(), target);
  }

  // repeated .autoagric.perception.SensorMeasurement measurements = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_measurements_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_measurements(i), target, stream);
  }

  // double height_above_ground = 21;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_height_above_ground = this->_internal_height_above_ground();
  uint64_t raw_height_above_ground;
  memcpy(&raw_height_above_ground, &tmp_height_above_ground, sizeof(tmp_height_above_ground));
  if (raw_height_above_ground != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(21, this->_internal_height_above_ground(), target);
  }

  // repeated double position_covariance = 22;
  if (this->_internal_position_covariance_size() > 0) {
    target = stream->WriteFixedPacked(22, _internal_position_covariance(), target);
  }

  // repeated double velocity_covariance = 23;
  if (this->_internal_velocity_covariance_size() > 0) {
    target = stream->WriteFixedPacked(23, _internal_velocity_covariance(), target);
  }

  // repeated double acceleration_covariance = 24;
  if (this->_internal_acceleration_covariance_size() > 0) {
    target = stream->WriteFixedPacked(24, _internal_acceleration_covariance(), target);
  }

  // .autoagric.perception.LightStatus light_status = 25;
  if (this->_internal_has_light_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::light_status(this), target, stream);
  }

  // .autoagric.perception.DebugMessage msg = 26;
  if (this->_internal_has_msg()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        26, _Internal::msg(this), target, stream);
  }

  // .autoagric.perception.PerceptionObstacle.Source source = 27;
  if (this->_internal_source() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      27, this->_internal_source(), target);
  }

  // .autoagric.perception.V2XInformation v2x_info = 28;
  if (this->_internal_has_v2x_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        28, _Internal::v2x_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.perception.PerceptionObstacle)
  return target;
}

size_t PerceptionObstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.perception.PerceptionObstacle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autoagric.common.Point3D polygon_point = 8;
  total_size += 1UL * this->_internal_polygon_point_size();
  for (const auto& msg : this->polygon_point_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated double point_cloud = 12;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_point_cloud_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated .autoagric.common.Point3D drops = 15;
  total_size += 1UL * this->_internal_drops_size();
  for (const auto& msg : this->drops_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autoagric.perception.SensorMeasurement measurements = 20;
  total_size += 2UL * this->_internal_measurements_size();
  for (const auto& msg : this->measurements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated double position_covariance = 22;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_position_covariance_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated double velocity_covariance = 23;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_velocity_covariance_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated double acceleration_covariance = 24;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_acceleration_covariance_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // .autoagric.common.Point3D position = 2;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // .autoagric.common.Point3D velocity = 4;
  if (this->_internal_has_velocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *velocity_);
  }

  // .autoagric.common.Point3D acceleration = 16;
  if (this->_internal_has_acceleration()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *acceleration_);
  }

  // .autoagric.common.Point3D anchor_point = 17;
  if (this->_internal_has_anchor_point()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *anchor_point_);
  }

  // .autoagric.perception.BBox2D bbox2d = 18;
  if (this->_internal_has_bbox2d()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bbox2d_);
  }

  // .autoagric.perception.LightStatus light_status = 25;
  if (this->_internal_has_light_status()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *light_status_);
  }

  // .autoagric.perception.DebugMessage msg = 26;
  if (this->_internal_has_msg()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *msg_);
  }

  // .autoagric.perception.V2XInformation v2x_info = 28;
  if (this->_internal_has_v2x_info()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *v2x_info_);
  }

  // double theta = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_theta = this->_internal_theta();
  uint64_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    total_size += 1 + 8;
  }

  // double length = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = this->_internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    total_size += 1 + 8;
  }

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // .autoagric.perception.PerceptionObstacle.Type type = 10;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  // double width = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = this->_internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    total_size += 1 + 8;
  }

  // double height = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_height = this->_internal_height();
  uint64_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    total_size += 1 + 8;
  }

  // double tracking_time = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tracking_time = this->_internal_tracking_time();
  uint64_t raw_tracking_time;
  memcpy(&raw_tracking_time, &tmp_tracking_time, sizeof(tmp_tracking_time));
  if (raw_tracking_time != 0) {
    total_size += 1 + 8;
  }

  // double timestamp = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_timestamp = this->_internal_timestamp();
  uint64_t raw_timestamp;
  memcpy(&raw_timestamp, &tmp_timestamp, sizeof(tmp_timestamp));
  if (raw_timestamp != 0) {
    total_size += 1 + 8;
  }

  // double confidence = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = this->_internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    total_size += 1 + 8;
  }

  // .autoagric.perception.PerceptionObstacle.ConfidenceType confidence_type = 14;
  if (this->_internal_confidence_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_confidence_type());
  }

  // .autoagric.perception.PerceptionObstacle.SubType sub_type = 19;
  if (this->_internal_sub_type() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_sub_type());
  }

  // double height_above_ground = 21;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_height_above_ground = this->_internal_height_above_ground();
  uint64_t raw_height_above_ground;
  memcpy(&raw_height_above_ground, &tmp_height_above_ground, sizeof(tmp_height_above_ground));
  if (raw_height_above_ground != 0) {
    total_size += 2 + 8;
  }

  // .autoagric.perception.PerceptionObstacle.Source source = 27;
  if (this->_internal_source() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_source());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PerceptionObstacle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PerceptionObstacle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PerceptionObstacle::GetClassData() const { return &_class_data_; }

void PerceptionObstacle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PerceptionObstacle *>(to)->MergeFrom(
      static_cast<const PerceptionObstacle &>(from));
}


void PerceptionObstacle::MergeFrom(const PerceptionObstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.perception.PerceptionObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  polygon_point_.MergeFrom(from.polygon_point_);
  point_cloud_.MergeFrom(from.point_cloud_);
  drops_.MergeFrom(from.drops_);
  measurements_.MergeFrom(from.measurements_);
  position_covariance_.MergeFrom(from.position_covariance_);
  velocity_covariance_.MergeFrom(from.velocity_covariance_);
  acceleration_covariance_.MergeFrom(from.acceleration_covariance_);
  if (from._internal_has_position()) {
    _internal_mutable_position()->::autoagric::common::Point3D::MergeFrom(from._internal_position());
  }
  if (from._internal_has_velocity()) {
    _internal_mutable_velocity()->::autoagric::common::Point3D::MergeFrom(from._internal_velocity());
  }
  if (from._internal_has_acceleration()) {
    _internal_mutable_acceleration()->::autoagric::common::Point3D::MergeFrom(from._internal_acceleration());
  }
  if (from._internal_has_anchor_point()) {
    _internal_mutable_anchor_point()->::autoagric::common::Point3D::MergeFrom(from._internal_anchor_point());
  }
  if (from._internal_has_bbox2d()) {
    _internal_mutable_bbox2d()->::autoagric::perception::BBox2D::MergeFrom(from._internal_bbox2d());
  }
  if (from._internal_has_light_status()) {
    _internal_mutable_light_status()->::autoagric::perception::LightStatus::MergeFrom(from._internal_light_status());
  }
  if (from._internal_has_msg()) {
    _internal_mutable_msg()->::autoagric::perception::DebugMessage::MergeFrom(from._internal_msg());
  }
  if (from._internal_has_v2x_info()) {
    _internal_mutable_v2x_info()->::autoagric::perception::V2XInformation::MergeFrom(from._internal_v2x_info());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_theta = from._internal_theta();
  uint64_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    _internal_set_theta(from._internal_theta());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_length = from._internal_length();
  uint64_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    _internal_set_length(from._internal_length());
  }
  if (from._internal_id() != 0) {
    _internal_set_id(from._internal_id());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_width = from._internal_width();
  uint64_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    _internal_set_width(from._internal_width());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_height = from._internal_height();
  uint64_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    _internal_set_height(from._internal_height());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_tracking_time = from._internal_tracking_time();
  uint64_t raw_tracking_time;
  memcpy(&raw_tracking_time, &tmp_tracking_time, sizeof(tmp_tracking_time));
  if (raw_tracking_time != 0) {
    _internal_set_tracking_time(from._internal_tracking_time());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_timestamp = from._internal_timestamp();
  uint64_t raw_timestamp;
  memcpy(&raw_timestamp, &tmp_timestamp, sizeof(tmp_timestamp));
  if (raw_timestamp != 0) {
    _internal_set_timestamp(from._internal_timestamp());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = from._internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    _internal_set_confidence(from._internal_confidence());
  }
  if (from._internal_confidence_type() != 0) {
    _internal_set_confidence_type(from._internal_confidence_type());
  }
  if (from._internal_sub_type() != 0) {
    _internal_set_sub_type(from._internal_sub_type());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_height_above_ground = from._internal_height_above_ground();
  uint64_t raw_height_above_ground;
  memcpy(&raw_height_above_ground, &tmp_height_above_ground, sizeof(tmp_height_above_ground));
  if (raw_height_above_ground != 0) {
    _internal_set_height_above_ground(from._internal_height_above_ground());
  }
  if (from._internal_source() != 0) {
    _internal_set_source(from._internal_source());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PerceptionObstacle::CopyFrom(const PerceptionObstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.perception.PerceptionObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerceptionObstacle::IsInitialized() const {
  return true;
}

void PerceptionObstacle::InternalSwap(PerceptionObstacle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  polygon_point_.InternalSwap(&other->polygon_point_);
  point_cloud_.InternalSwap(&other->point_cloud_);
  drops_.InternalSwap(&other->drops_);
  measurements_.InternalSwap(&other->measurements_);
  position_covariance_.InternalSwap(&other->position_covariance_);
  velocity_covariance_.InternalSwap(&other->velocity_covariance_);
  acceleration_covariance_.InternalSwap(&other->acceleration_covariance_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PerceptionObstacle, source_)
      + sizeof(PerceptionObstacle::source_)
      - PROTOBUF_FIELD_OFFSET(PerceptionObstacle, position_)>(
          reinterpret_cast<char*>(&position_),
          reinterpret_cast<char*>(&other->position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PerceptionObstacle::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_getter, &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_once,
      file_level_metadata_autoagric_2fperception_2fperception_5fobstacle_2eproto[6]);
}

// ===================================================================

class CIPVInfo::_Internal {
 public:
};

CIPVInfo::CIPVInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  potential_cipv_id_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.perception.CIPVInfo)
}
CIPVInfo::CIPVInfo(const CIPVInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      potential_cipv_id_(from.potential_cipv_id_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  cipv_id_ = from.cipv_id_;
  // @@protoc_insertion_point(copy_constructor:autoagric.perception.CIPVInfo)
}

inline void CIPVInfo::SharedCtor() {
cipv_id_ = 0;
}

CIPVInfo::~CIPVInfo() {
  // @@protoc_insertion_point(destructor:autoagric.perception.CIPVInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CIPVInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CIPVInfo::ArenaDtor(void* object) {
  CIPVInfo* _this = reinterpret_cast< CIPVInfo* >(object);
  (void)_this;
}
void CIPVInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CIPVInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CIPVInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.perception.CIPVInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  potential_cipv_id_.Clear();
  cipv_id_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CIPVInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 cipv_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          cipv_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 potential_cipv_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_potential_cipv_id(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_potential_cipv_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CIPVInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.perception.CIPVInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 cipv_id = 1;
  if (this->_internal_cipv_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_cipv_id(), target);
  }

  // repeated int32 potential_cipv_id = 2;
  {
    int byte_size = _potential_cipv_id_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_potential_cipv_id(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.perception.CIPVInfo)
  return target;
}

size_t CIPVInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.perception.CIPVInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 potential_cipv_id = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->potential_cipv_id_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _potential_cipv_id_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int32 cipv_id = 1;
  if (this->_internal_cipv_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_cipv_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CIPVInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CIPVInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CIPVInfo::GetClassData() const { return &_class_data_; }

void CIPVInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CIPVInfo *>(to)->MergeFrom(
      static_cast<const CIPVInfo &>(from));
}


void CIPVInfo::MergeFrom(const CIPVInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.perception.CIPVInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  potential_cipv_id_.MergeFrom(from.potential_cipv_id_);
  if (from._internal_cipv_id() != 0) {
    _internal_set_cipv_id(from._internal_cipv_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CIPVInfo::CopyFrom(const CIPVInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.perception.CIPVInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CIPVInfo::IsInitialized() const {
  return true;
}

void CIPVInfo::InternalSwap(CIPVInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  potential_cipv_id_.InternalSwap(&other->potential_cipv_id_);
  swap(cipv_id_, other->cipv_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CIPVInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_getter, &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_once,
      file_level_metadata_autoagric_2fperception_2fperception_5fobstacle_2eproto[7]);
}

// ===================================================================

class PerceptionObstacles::_Internal {
 public:
  static const ::autoagric::common::Header& header(const PerceptionObstacles* msg);
  static const ::autoagric::perception::CIPVInfo& cipv_info(const PerceptionObstacles* msg);
};

const ::autoagric::common::Header&
PerceptionObstacles::_Internal::header(const PerceptionObstacles* msg) {
  return *msg->header_;
}
const ::autoagric::perception::CIPVInfo&
PerceptionObstacles::_Internal::cipv_info(const PerceptionObstacles* msg) {
  return *msg->cipv_info_;
}
void PerceptionObstacles::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
PerceptionObstacles::PerceptionObstacles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  perception_obstacle_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:autoagric.perception.PerceptionObstacles)
}
PerceptionObstacles::PerceptionObstacles(const PerceptionObstacles& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      perception_obstacle_(from.perception_obstacle_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::autoagric::common::Header(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_cipv_info()) {
    cipv_info_ = new ::autoagric::perception::CIPVInfo(*from.cipv_info_);
  } else {
    cipv_info_ = nullptr;
  }
  error_code_ = from.error_code_;
  // @@protoc_insertion_point(copy_constructor:autoagric.perception.PerceptionObstacles)
}

inline void PerceptionObstacles::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&header_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&error_code_) -
    reinterpret_cast<char*>(&header_)) + sizeof(error_code_));
}

PerceptionObstacles::~PerceptionObstacles() {
  // @@protoc_insertion_point(destructor:autoagric.perception.PerceptionObstacles)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PerceptionObstacles::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete cipv_info_;
}

void PerceptionObstacles::ArenaDtor(void* object) {
  PerceptionObstacles* _this = reinterpret_cast< PerceptionObstacles* >(object);
  (void)_this;
}
void PerceptionObstacles::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PerceptionObstacles::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PerceptionObstacles::Clear() {
// @@protoc_insertion_point(message_clear_start:autoagric.perception.PerceptionObstacles)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  perception_obstacle_.Clear();
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && cipv_info_ != nullptr) {
    delete cipv_info_;
  }
  cipv_info_ = nullptr;
  error_code_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PerceptionObstacles::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autoagric.perception.PerceptionObstacle perception_obstacle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_perception_obstacle(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.Header header = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autoagric.common.ErrorCode error_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_error_code(static_cast<::autoagric::common::ErrorCode>(val));
        } else
          goto handle_unusual;
        continue;
      // .autoagric.perception.CIPVInfo cipv_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_cipv_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PerceptionObstacles::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autoagric.perception.PerceptionObstacles)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autoagric.perception.PerceptionObstacle perception_obstacle = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_perception_obstacle_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_perception_obstacle(i), target, stream);
  }

  // .autoagric.common.Header header = 2;
  if (this->_internal_has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::header(this), target, stream);
  }

  // .autoagric.common.ErrorCode error_code = 3;
  if (this->_internal_error_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_error_code(), target);
  }

  // .autoagric.perception.CIPVInfo cipv_info = 5;
  if (this->_internal_has_cipv_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::cipv_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autoagric.perception.PerceptionObstacles)
  return target;
}

size_t PerceptionObstacles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autoagric.perception.PerceptionObstacles)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autoagric.perception.PerceptionObstacle perception_obstacle = 1;
  total_size += 1UL * this->_internal_perception_obstacle_size();
  for (const auto& msg : this->perception_obstacle_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .autoagric.common.Header header = 2;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  // .autoagric.perception.CIPVInfo cipv_info = 5;
  if (this->_internal_has_cipv_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cipv_info_);
  }

  // .autoagric.common.ErrorCode error_code = 3;
  if (this->_internal_error_code() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PerceptionObstacles::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PerceptionObstacles::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PerceptionObstacles::GetClassData() const { return &_class_data_; }

void PerceptionObstacles::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PerceptionObstacles *>(to)->MergeFrom(
      static_cast<const PerceptionObstacles &>(from));
}


void PerceptionObstacles::MergeFrom(const PerceptionObstacles& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autoagric.perception.PerceptionObstacles)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  perception_obstacle_.MergeFrom(from.perception_obstacle_);
  if (from._internal_has_header()) {
    _internal_mutable_header()->::autoagric::common::Header::MergeFrom(from._internal_header());
  }
  if (from._internal_has_cipv_info()) {
    _internal_mutable_cipv_info()->::autoagric::perception::CIPVInfo::MergeFrom(from._internal_cipv_info());
  }
  if (from._internal_error_code() != 0) {
    _internal_set_error_code(from._internal_error_code());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PerceptionObstacles::CopyFrom(const PerceptionObstacles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autoagric.perception.PerceptionObstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerceptionObstacles::IsInitialized() const {
  return true;
}

void PerceptionObstacles::InternalSwap(PerceptionObstacles* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  perception_obstacle_.InternalSwap(&other->perception_obstacle_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PerceptionObstacles, error_code_)
      + sizeof(PerceptionObstacles::error_code_)
      - PROTOBUF_FIELD_OFFSET(PerceptionObstacles, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PerceptionObstacles::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_getter, &descriptor_table_autoagric_2fperception_2fperception_5fobstacle_2eproto_once,
      file_level_metadata_autoagric_2fperception_2fperception_5fobstacle_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace perception
}  // namespace autoagric
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::autoagric::perception::BBox2D* Arena::CreateMaybeMessage< ::autoagric::perception::BBox2D >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::perception::BBox2D >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::perception::LightStatus* Arena::CreateMaybeMessage< ::autoagric::perception::LightStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::perception::LightStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::perception::V2XInformation* Arena::CreateMaybeMessage< ::autoagric::perception::V2XInformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::perception::V2XInformation >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::perception::SensorMeasurement* Arena::CreateMaybeMessage< ::autoagric::perception::SensorMeasurement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::perception::SensorMeasurement >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::perception::Trajectory* Arena::CreateMaybeMessage< ::autoagric::perception::Trajectory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::perception::Trajectory >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::perception::DebugMessage* Arena::CreateMaybeMessage< ::autoagric::perception::DebugMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::perception::DebugMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::perception::PerceptionObstacle* Arena::CreateMaybeMessage< ::autoagric::perception::PerceptionObstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::perception::PerceptionObstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::perception::CIPVInfo* Arena::CreateMaybeMessage< ::autoagric::perception::CIPVInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::perception::CIPVInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::autoagric::perception::PerceptionObstacles* Arena::CreateMaybeMessage< ::autoagric::perception::PerceptionObstacles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autoagric::perception::PerceptionObstacles >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
