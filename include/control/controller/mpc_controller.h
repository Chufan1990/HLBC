#pragma once
#include <memory>

#include "Eigen/Core"
#include "autoagric/common/vehicle_config.pb.h"
#include "common/math/mpc_ipopt.h"
#include "common/vehicle_state/vehicle_state_provider.h"
#include "control/common/interpolation_1d.h"
#include "control/common/interpolation_2d.h"
#include "control/common/pid_controller.h"
#include "control/common/trajectory_analyzer.h"
#include "control/controller/controller.h"

namespace autoagric {
namespace control {

class MPCController : public Controller {
 public:
  typedef CPPAD_TESTVECTOR(double) Dvector;
  /**
   * @brief constructor
   */
  MPCController();

  /**
   * @brief copy constructor
   */
  MPCController(MPCController& other) = default;

  /**
   * @brief move constructor
   */
  MPCController(MPCController&& other) = default;

  /**
   * @brief destructor
   */
  virtual ~MPCController();

  /**
   * @brief initialize lateral controller
   * @param control_conf control_configuration
   * @return Status initialization status
   */
  autoagric::common::Status Init(std::shared_ptr<DependencyInjector> injector,
                                 const ControlConf* control_conf) override;

  /**
   * @brief compute steering target based on current vehicle status and target
   * trajectory
   * @param locolization vehicle location
   * @param chassis vehicle status e.g., speed, acceleration
   * @param trajectory trajectory generated by planning
   * @param cmd control command
   * @return Status computation Status
   */
  autoagric::common::Status ComputeControlCommand(
      const localization::LocalizationEstimate* localization,
      const canbus::Chassis* chassis,
      const planning::ADCTrajectory* planning_published_trajectory,
      ControlCommand* cmd) override;

  /**
   * @brief reset lateral controller
   * @return Status reset status
   */
  autoagric::common::Status Reset() override;

  /**
   * @brief stop lateral controller
   * @return Status stop status
   */
  void Stop() override;

  /**
   * @brief lateral controller name
   * @return string controller name in string
   */
  std::string Name() const override;

  std::vector<autoagric::common::TrajectoryPoint> resampled_trajectory()
      const;

  std::vector<autoagric::common::TrajectoryPoint> warmstart_solution()
      const;

 private:
  bool LoadControlConf(const ControlConf* control_conf);

  void LoadControlCalibrationTable(
      const MPCControllerConf& mpc_controller_conf);

  void LoadMPCGainScheduler(const MPCControllerConf& mpc_controller_conf);

  void UpdateState(const autoagric::common::PathPoint& matched_point);

  inline double Wheel2SteerPct(const double wheel_angle) {
    return wheel_angle / wheel_single_direction_max_degree_ * 100;
  }

  inline double SteerPct2Wheel(const double steer_pct) {
    return steer_pct / 100 * wheel_single_direction_max_degree_;
  }
  // vehicle
  const ControlConf* control_conf_ = nullptr;

  // vehicle parameter
  autoagric::common::VehicleParam vehicle_param_;

  // a proxy to analyze the planning trajectory
  TrajectoryAnalyzer trajectory_analyzer_;

  std::unique_ptr<Interpolation2D> control_interpolation_;

  std::unique_ptr<Interpolation1D> lat_err_interpolation_;

  std::unique_ptr<Interpolation1D> heading_err_interpolation_;

  std::unique_ptr<Interpolation1D> feedforwardterm_interpolation_;

  std::unique_ptr<Interpolation1D> steer_weight_interpolation_;

  std::shared_ptr<DependencyInjector> injector_;

  std::shared_ptr<autoagric::common::math::MpcIpopt> mpc_ipopt_solver_;

  // the following parameters are vehicle physics related.
  // control time interval
  double ts_ = 0.0;
  // corner stiffness; front
  double cf_ = 0.0;
  // corner stiffness; rear
  double cr_ = 0.0;
  // distance between front and rear wheel center
  double wheelbase_ = 0.0;
  // mass of the vehicle
  double mass_ = 0.0;
  // distance from front wheel center to COM
  double lf_ = 0.0;
  // distance from rear wheel center to COM
  double lr_ = 0.0;
  // rotational inertia
  double iz_ = 0.0;
  // the ratio between the turn of the steering wheel and the turn of the wheels
  double steer_ratio_ = 0.0;
  // the maximum turn of steer
  double steer_single_direction_max_degree_ = 0.0;
  // the maximum turn of vehicle wheel
  double wheel_single_direction_max_degree_ = 0.0;

  // limit steering to maximum theoretical lateral acceleration
  double max_lat_acc_ = 0.0;

  // number of states, includes
  // lateral error, lateral error rate, heading error, heading error rate,
  // station error, velocity error,
  const int basic_state_size_ = 4;

  const int controls_ = 2;

  const int horizon_ = 10;

  const std::string name_;

  double max_acceleration_when_stopped_ = 0.0;

  double max_abs_speed_when_stopped_ = 0.0;

  double standstill_acceleration_ = 0.0;

  double throttle_lowerbound_ = 0.0;

  double brake_lowerbound_ = 0.0;

  double steer_angle_feedforwardterm_ = 0.0;

  double steer_angle_feedforwardterm_updated_ = 0.0;

  double max_acceleration_ = 0.0;

  double max_deceleration_ = 0.0;

  double minimum_speed_protection_ = 0.1;

  // Enable the feedback-gain-related compensation components in the feedfoward
  // term for steering control
  bool enable_mpc_feedforward_compensation_ = false;

  // Limitation for judging if the unconstrained analytical control is close
  // enough to the solver's output with constraint
  double unconstrained_control_diff_limit_ = 5.0;

  double current_trajectory_timestamp_ = -1.0;

  int latency_steps_ = 0;

  double max_forward_speed_;

  double max_backward_speed_;

  double max_driving_acceleration_;

  double max_driving_deceleration_;

  Dvector vars_;

  Dvector vars_lowerbound_;

  Dvector vars_upperbound_;

  Dvector constraints_lowerbound_;

  Dvector constraints_upperbound_;

  size_t x_start_;

  size_t y_start_;

  size_t heading_start_;

  size_t speed_start_;

  size_t steer_start_;

  size_t accel_start_;

  std::string ipopt_options_;

  Eigen::MatrixXd matrix_r_;
  // updated control authority weighting matrix
  Eigen::MatrixXd matrix_r_updated_;
  // state weighting matrix
  Eigen::MatrixXd matrix_q_;
  // updated state weighting matrix
  Eigen::MatrixXd matrix_q_updated_;

  std::vector<autoagric::common::TrajectoryPoint> resampled_trajectory_;

  std::vector<autoagric::common::TrajectoryPoint> warmstart_solution_;

  std::shared_ptr<MPCController> ConstPtr_;

  std::unique_ptr<autoagric::control::common::PIDController>
      brake_pid_controller_;

  autoagric::common::PathPoint matched_point_;
};

}  // namespace control
}  // namespace autoagric